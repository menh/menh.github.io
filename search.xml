<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux-虚拟地址空间</title>
      <link href="/2020/04/07/linux-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
      <url>/2020/04/07/linux-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="linux虚拟地址.jpg" alt="linux虚拟地址空间"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-鸟哥的linux私房菜</title>
      <link href="/2020/04/07/linux-%E9%B8%9F%E5%93%A5%E7%9A%84linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
      <url>/2020/04/07/linux-%E9%B8%9F%E5%93%A5%E7%9A%84linux%E7%A7%81%E6%88%BF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-makefile使用</title>
      <link href="/2020/04/06/CS-makefile%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/06/CS-makefile%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><p>  目标：依赖<br>    命令</p><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>$&lt; 当前规则中的第一个依赖<br>$@  当前规则中的目标<br>$^  规则中的所有依赖</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>获取指定目录下的所有.c文件<br>src=$(wildcard ./*.c)</p><p>.c替换为.o<br>obj=$(patsubst ./%.o, ./%.c, $(src))</p><h5 id="version-1"><a href="#version-1" class="headerlink" title="version_1:"></a>version_1:</h5><p>app:main.c add.c sub.c mul.c<br>  gcc main.c add.c sub.c mul.c -o app</p><h5 id="version-2"><a href="#version-2" class="headerlink" title="version_2:"></a>version_2:</h5><p>app:main.o add.o sub.o mul.o<br>  gcc main.o add.o sub.o mul.o -o app</p><p>main.o:main.c<br>  gcc -c main.c</p><p>add.o:add.c<br>  gcc -c add.c</p><p>sub.o:sub.c<br>  gcc -c sub.c</p><p>mul.o:mul.c<br>  gcc -c mul.c</p><h5 id="verson-3"><a href="#verson-3" class="headerlink" title="verson_3:"></a>verson_3:</h5><p>obj=main.o add.o sub.o mul.o<br>target=app<br>CC = gcc<br>CPPFLAGS = -I<br>$(target) : $(obj)<br>  $(CC) $(obj) -o $(target)</p><p>%.o:%.c<br>  $(CC) -c $&lt; -o $@</p><h4 id="version-4"><a href="#version-4" class="headerlink" title="version_4:"></a>version_4:</h4><p>target=app<br>CC = gcc<br>CPPFLAGS = -I<br>src=$(wildcard ./*.c)<br>obj=$(patsubst ./%.o, ./%.c, $(src))</p><p>$(target) : $(obj)<br>  $(CC) $(obj) -o $(target)</p><p>%.o:%.c<br>  $(CC) -c $&lt; -o $@</p><p>.PHONY:clean<br>clean:<br>  rm $(obj) $(target) -f</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-tmux使用</title>
      <link href="/2020/04/06/CS-tmux%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/06/CS-tmux%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>新创建一个会话以“ccc”命名。<br>tmux new -s ccc</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-GDB调试</title>
      <link href="/2020/04/05/CS-GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2020/04/05/CS-GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>启动gdb<br>编译 g++ <CODE.cpp> -o <OBJECT> -g<br>启动gdb gdb <OBJECT><br>执行 start/run</p></li><li><p>查看代码<br>l + <FILE_NAME>:<FUNC|LINE> 默认打开包含吧main函数文件</p></li><li><p>设置断点<br> 设置当前文件的断点<br>   b(break) + &lt;行号&gt;<br> 设置指定文件的断点<br>   b + <FILE_NAME>:<FUNC|LINE><br> 设置条件断点<br>   b(break) + &lt;行号&gt; + 条件</p><pre><code> 例: b 22 if i == 1</code></pre><p> 删除断点 d + 断点编号</p></li><li>查看设置的断点<br> i(info) + b(break)</li><li>开始执行gdb调试<br> 开始gdb start<br> 执行一步操作 n<br> 执行多步，直到停在断点处 c</li><li>单步调试<br> 进入函数体内部 s<br> 从函数体内部跳出 finish<br> 退出当前循环 u</li><li>查看变量的值<br> p + 变量名</li><li>查看变量的类型<br> ptype + 变量名</li><li>设置变量的值<br> set var 变量名 = 值<br>   例子 set var i = 10</li><li><p>设置追踪变量<br>  display + 变量名</p><p>获取变量编号<br>  i(info) display</p><p>取消追踪变量<br>  undisplay + 变量编号</p></li><li><p>退出gdb调试<br>quit</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-基于linux的CPP_linux系统编程基础12_学堂在线</title>
      <link href="/2020/03/25/CS-%E5%9F%BA%E4%BA%8Elinux%E7%9A%84CPP-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%8012-%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/"/>
      <url>/2020/03/25/CS-%E5%9F%BA%E4%BA%8Elinux%E7%9A%84CPP-linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%8012-%E5%AD%A6%E5%A0%82%E5%9C%A8%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux 命令行规范<br>  短参数：以单行开头，后跟单一字符，例：ls -h<br>  长参数：以双横开头，后跟字符串，例：ls —help</p><p>linux 环境变量<br>  USER  用户名<br>  HOME 主目录<br>  PATH 分号分隔的linux查找命令的目录列表</p><p>makefile 负责C/C++ 程序编译与链接<br>makefile 文件格式<br>  target…: prerequisites…<br>  [Tab] commands</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-学习</title>
      <link href="/2020/03/24/linux-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/24/linux-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>命令<br>history ctrl + p / ctrl + n</p><p>光标移动 字符移动 ctrl + b / ctrl + f</p><pre><code>   跳到行首行尾 ctrl + a / ctrl + e   删除字符 ctrl + h / ctrl + d   删除所有 ctrl + u</code></pre></li><li><p>Linux 目录结构</p><ol><li>根目录 /<br>/root 超管目录<br>/bin binary 存储命令<br>/boot 存储启动linux使用的一些核心文件，包括一些链接文件以及镜像文件<br>/dev  Device 存放linux的外部设备<br>/etc  存放所有的系统管理所需要的配置文件子目录<br>/home 用户主目录<br>/var<br>/lib  基本的动态链接共享库<br>/lost + found 一般为空，系统非法关机后存放的一些文件<br>/usr  用户应用软件资源目录<br>/media  linux自动识别的一些设备，例如 U盘，光驱等等 自动挂载<br>/mnt  系统提供该目录为了让用户临时挂载别的文件系统的 手动挂载</li></ol><p>～ 宿主文件目录<br>$ 普通用户</p><h1 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h1></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-歇息</title>
      <link href="/2020/03/24/linux-%E6%AD%87%E6%81%AF/"/>
      <url>/2020/03/24/linux-%E6%AD%87%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-C++</title>
      <link href="/2020/03/20/%E9%9D%A2%E7%BB%8F-C/"/>
      <url>/2020/03/20/%E9%9D%A2%E7%BB%8F-C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>第一: private,public,protected的访问范围:<br>private: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br>protected: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br>public: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p></li><li><p>三种继承<br>public继承，父类成员在子类中保持原有的访问方式<br>protected继承，父类中public成员会变成protected</p><pre><code>         父类中protected成员仍然为protected         父类中private成员仍然为private</code></pre><p>private继承，父类成员在子类中变为private成员</p><p>private成员在子类中依然存在，但是却无法访问到。不论种方式继承基类，派生类都不能直接使用基类的私有成员。</p></li><li><p>虚函数实现机制和底层原理<br>C++中的虚函数的作用主要是实现了多态的机制。<br>实现原理：虚函数表+虚表指针<br>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p><p>使用虚函数后的变化：</p><ol><li>对象将增加一个存储地址的空间（32位系统为4字节，64位为8字节）。</li><li>每个类编译器都创建一个虚函数地址表</li><li>对每个函数调用都需要增加在表中查找地址的操作。<br>虚函数的注意事项</li><li>基类方法中声明了方法为虚后，该方法在基类派生类中是虚的。</li><li>若使用指向对象的引用或指针调用虚方法，程序将根据对象类型来调用方法，而不是指针的类型。</li><li>如果定义的类被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚。</li></ol></li><li><p>STL相关</p><ol><li>vector:底层数据结构为数组 ，支持快速随机访问。</li><li>list:底层数据结构为双向链表，支持快速增删。</li><li>deque:底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问。<pre><code> 即双端队列。是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，相比list增加[]运算符重载。</code></pre></li><li>stack:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</li><li>queue:底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</li><li>priority_queue:的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li><li>set:底层数据结构为红黑树，有序，不重复。</li><li>map:底层数据结构为红黑树，有序，不重复。</li></ol></li><li><p>std::vector的底层（存储）机制。<br>vector就是一个动态数组，里面有一个指针指向一片连续的内存空间，当空间不够装下数据时，会自动申请另一片更大的空间（一般是增加当前容量的50%或100%），然后把原来的数据拷贝过去，接着释放原来的那片空间；当释放或者删除里面的数据时，其存储空间不释放，仅仅是清空了里面的数据</p></li><li><p>为什么vector的插入操作可能会导致迭代器失效？<br>vector动态增加大小时，并不是在原空间后增加新的空间，而是以原大小的两倍在另外配置一片较大的新空间，然后将内容拷贝过来，并释放原来的空间。由于操作改变了空间，所以迭代器失效。</p></li><li><p>你怎样理解迭代器？<br>Iterator(迭代器)用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，相当于智能指针。</p></li><li><p>vector每次insert或erase之后，以前保存的iterator会不会失效？</p><p> 理论上会失效，理论上每次insert或者erase之后，所有的迭代器就重新计算的，所以都可以看作会失效，原则上是不能使用过期的内存<br> 但是vector一般底层是用数组实现的，我们仔细考虑数组的特性，不难得出另一个结论，</p><p> insert时，假设insert位置在p，分两种情况：<br> a) 容器还有空余空间，不重新分配内存，那么p之前的迭代器都有效，p之后的迭代器都失效<br> b) 容器重新分配了内存，那么p之后的迭代器都无效咯<br> erase时，假设erase位置在p，则p之前的迭代器都有效并且p指向下一个元素位置（如果之前p在尾巴上，则p指向无效尾end），p之后的迭代器都无效</p></li><li><p>vector中erase方法与algorithn中的remove方法区别<br>vector中erase方法真正删除了元素，迭代器不能访问了<br>remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除。</p></li><li><p>vector、list、map、deque用erase（it）后，迭代器的变化。<br>vector和deque是序列式容器，其内存分别是连续空间和分段连续空间，删除迭代器it后，其后面的迭代器都失效了，此时it及其后面的迭代器会自动加1，使it指向被删除元素的下一个元素。<br>list删除迭代器it时，其后面的迭代器都不会失效，将前面和后面连接起来即可。<br>map也是只能使当前删除的迭代器失效，其后面的迭代器依然有效。</p></li><li><p>红黑树的性质</p><ol><li>节点是红色或黑色。</li><li>根节点是黑色。</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol></li><li><p>智能指针<br>负责自动释放所指向的对象，防止内存泄漏<br>封装普通指针使其表现的像普通指针一样。超过类的作用域，将会自己调用析构函数，自动释放资源</p><p>shared_ptr: 多个指针指向相同的对象</p><pre><code>      shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。      创建方式：1. 使用函数make_shared(会根据传递的参数调用动态对象的构造函数)。 2. 使用构造函数(可从原生指针、unique_ptr、另一个shared_ptr创建)      拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。      注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。      注意避免循环引用: 两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用。      解决循环引用：使用弱引用的智能指针打破这种循环引用。      强引用和弱引用      一个强引用当被引用的对象活着的话，这个引用也存在（就是说，当至少有一个强引用，那么这个对象就不能被释放）。      boost::share_ptr就是强引用。相对而言，弱引用当引用的对象活着的时候不一定存在。仅仅是当它存在的时候的一个引用。      弱引用并不修改该对象的引用计数，这意味这弱引用它并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</code></pre><p>auto_ptr：不可以用于容器，不建议使用，不支持复制和赋值，如果进行了赋值和复制操作，并不报错<br>unique_ptr：则“独占”所指向的对象，不支持复制和赋值，直接赋值会报错，同一时刻对象仅能拥有一个unique_ptr指向自身<br>weak_ptr：它是一种弱引用，指向shared_ptr所管理的对象，不控制对象生命周期的智能指针，只提供了管理对象的访问手段，用于协助shared_ptr的工作，用于观测资源的使用情况。use_count()可以一观察资源的应用数。</p></li><li><p>强制类型转换<br>static_cast 用于基本类型之间、有继承关系的类对象之间、类指针之间的转换不能用于基本类型指针之间的转换<br>const_cast 用于去除变量的只读属性 强制转换的目标类型必须是指针或引用<br>reinterpret_cast 用于指针类型之间、整数和指针类型之间的转换<br>dynamic_cast 用于有继承关系的类指针之间、有交叉关系的类指针之间的转换，具有类型检查的功能，需要虚函数的支持</p></li><li><p>static_cast 和 dynamic_cast 的区别<br>static_cast 没有运行时检查</p><ol><li>用于类层次结构中基类和子类之间指针或引用的转换<br>进行上行转换（把子类的指针或引用转换成基类表示）是安全的；<br>进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。</li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li>把空指针转换成目标类型的空指针。</li><li>把任何类型的表达式转换成void类型。<br>dynamic_cast 有运行时检查，需要虚函数表<br>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；<br>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</li></ol></li><li><p>C++ 11 了解多少<br>nullptr 关键字，专门用来区分空指针、0。<br>auto 和 decltype 这两个关键字实现了类型推导<br>序列for循环 变长參数的模板 更加优雅的初始化方法<br>constexpr 将变量声明为constexpr类型以便由编译器来验证变量的值是否为一个常量表达式，必须在编译期间计算出它的值并且它的值不可以被改变<br>   Const只能保证在运行时是常量，即具有运行时数据的不可更改性。<br>lambada 表达式</p></li><li><p>子类调用父类的构造函数</p><ol><li>子类默认调用父类的无参构造</li><li>若父类定义了有参构造函数，没有定义无参构造函数，会报错</li><li>如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式</li></ol></li><li><p>类默认的6个方法</p><ol><li>构造函数</li><li>析构函数</li><li>拷贝构造函数</li><li>赋值运算符号重载函数</li><li>取地址操作符重载</li><li>const修饰的取地址操作符的重载</li><li>C++primer</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>书-牧羊人的奇幻漂流</title>
      <link href="/2020/03/19/%E4%B9%A6-%E7%89%A7%E7%BE%8A%E4%BA%BA%E7%9A%84%E5%A5%87%E5%B9%BB%E6%BC%82%E6%B5%81/"/>
      <url>/2020/03/19/%E4%B9%A6-%E7%89%A7%E7%BE%8A%E4%BA%BA%E7%9A%84%E5%A5%87%E5%B9%BB%E6%BC%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1、男孩圣地亚哥神学院毕业，通晓拉丁文、西班牙文和神学，但他不想成为神甫，要云游四方，于是，选择去牧羊，过着居无定所、风餐露宿的生活。<br>2、男孩喜欢看书，在连续几天的夜里做着同一样的梦，梦到一个小孩带着他去了埃及金字塔，说：“假如你来到这里，将会找到一处隐秘的宝藏”。<br>3、男孩找到了吉卜赛老妇人，遇见了撒冷王，开始了奇幻的寻宝之旅。<br>4、被骗身无分文时到水晶商贩处打工，然后在沙漠里遇见英国人和炼金术士，然后到了金字塔，最后，又回到了出发的地方、做梦的地方，发现了宝藏。故事很简单，但，它试图诠释着世界、万物、人生，以及人生来就有的天命!</p><p>一个叫做圣地亚哥的男孩，不想过着日复一日的牧羊生活，<br>在连续几天的夜里做着同一样的梦，梦到一个小孩带着他去了埃及金字塔，说：“假如你来到这里，将会找到一处隐秘的宝藏”。<br>决定前往金字塔附近寻找自己的宝藏。途中认识了一位圣王，圣王教会他认识到了自己的天命，坚定追寻自己的宝藏；<br>被骗光身上财宝时，绝望之际，从羊群那儿学会了用不同的角度看待问题；<br>沙漠绿洲中遇到自己喜爱的女人；<br>随之炼金术士引领男孩去实现自己的天命，与他结伴前行，一路上，炼金术士通过许多智慧话语让男孩自己学会了与世界灵魂的语言，与自己的心灵沟通，成为一位新的炼金术士。<br>最后，又回到了出发的地方、做梦的地方，发现了宝藏。</p><p>这是一场奇幻之旅会，是成长之旅，是不断聆听自己心灵的声音，追寻自己内心所想，求的内心的一片安宁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-腾讯面经</title>
      <link href="/2020/03/18/%E9%9D%A2%E7%BB%8F-%E8%85%BE%E8%AE%AF%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/03/18/%E9%9D%A2%E7%BB%8F-%E8%85%BE%E8%AE%AF%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/soipray/article/details/56279623" target="_blank" rel="noopener">https://blog.csdn.net/soipray/article/details/56279623</a></p><p>linux和os:</p><p>netstat tcpdump ipcs ipcrm （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)</p><p>netstat<br>  -t ：TCP<br>  -u ：UDP<br>  netstat –r 路由<br>  netstat -p<br><a href="https://www.cnblogs.com/ftl1012/p/netstat.html" target="_blank" rel="noopener">https://www.cnblogs.com/ftl1012/p/netstat.html</a></p><p>tcpdump<br>  tcpdump -i eth1 监听指定网络端口包<br>  tcpdump host 210.27.48.1监听主机<br>  tcpdump tcp port 23 and host 210.27.48.1<br><a href="https://www.cnblogs.com/williamjie/p/9983958.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9983958.html</a></p><p>ipcs<br>  ipcs -a<br>  ipcs -q 队列<br>  ipcs -s 信号量<br>  ipcs -m 共享内存<br><a href="https://blog.csdn.net/huangyimo/article/details/80236181" target="_blank" rel="noopener">https://blog.csdn.net/huangyimo/article/details/80236181</a></p><p>ipcrm<br>  ipcrm -m 18602 删除共享内存<br><a href="https://ipcmen.com/ipcrm" target="_blank" rel="noopener">https://ipcmen.com/ipcrm</a></p><p>cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握<br>cpu<br>  iostat 监视系统输入输出设备和CPU的使用情况<br>内存<br>  vmstat 显示虚拟内存状态<br>  free 指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。<br>磁盘<br>  df 文件系统的磁盘使用情况统计。</p><p><a href="https://blog.csdn.net/guoxiaojie_415/article/details/80526667" target="_blank" rel="noopener">https://blog.csdn.net/guoxiaojie_415/article/details/80526667</a><br>awk AWK是一种处理文本文件的语言，是一个强大的文本分析工具。<br>sed 可依照script的指令，来处理、编辑文本文件。</p><p>共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）<br><a href="https://blog.csdn.net/al_xin/article/details/38602093" target="_blank" rel="noopener">https://blog.csdn.net/al_xin/article/details/38602093</a><br>共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以。<br>内存映射段<br><a href="https://blog.csdn.net/ypbsyy/article/details/79915117" target="_blank" rel="noopener">https://blog.csdn.net/ypbsyy/article/details/79915117</a></p><p>c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）<br>栈<br>堆<br>为初始化区<br>初始化区<br>数据段</p><p>ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）<br><a href="https://blog.csdn.net/liuzk2014/article/details/54409466" target="_blank" rel="noopener">https://blog.csdn.net/liuzk2014/article/details/54409466</a><br>可执行链接文件<br>是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。<br>1.可重定位文件(Relocateable)这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类，如.o文件。<br>2.可执行文件(Executable file)这类文件包含了直接执行的程序，如/bin/bash等。<br>3.共享目录(shared object file)链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接，产生新的目标文件；动态链接器可以将几个共享目标文件与可执行文件结合，作为进程映像的一部分来运行，如glibc<em>*</em>.so。<br>4.核心转储文件(core dump file)当进程意外终止时，系统可以将该进程的地址空间内容及终止时的一些其他信息转储到核心转储文件。</p><p>.bss段在elf仅占用一个占位符，不占用磁盘空间<br>可以减少重新编程重新编译的代码。</p><p>使用过哪些进程间通讯机制，并详细说明（重点）<br>管道（无名管道和有名管道）共享内存 消息队列 信号 信号量 套接字</p><p>makefile编写，虽然比较基础，但是会被问到<br>预处理、编译、汇编、文本链接四个步骤，每次得到的文件是：test.i，test.s，test.o，test<br><a href="https://www.cnblogs.com/tp-16b/p/8955462.html" target="_blank" rel="noopener">https://www.cnblogs.com/tp-16b/p/8955462.html</a><br>    $^ 代表所有的依赖文件<br>　　$@  代表所有的目标文件<br>　　$&lt;   代表第一个依赖文件<br>Makefile的编写规则：<br>  目标文件：执行文件<br>  命令（注意：命令前必须以tab键开头）</p><p>gdb调试相关的经验，会被问到</p><p>如何定位内存泄露？<br>内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的、大小任意的(内存块的大小可以在程序运行期决定)、使用完后必须显示释放的内存。应用程序一般使用malloc、realloc、new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块。否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。<br>只能使用top指令观察进程的动态内存总额<br>ps、kill两个命令检测内存使用情况和进行回收。</p><p>  内存泄漏的原因</p><pre><code>* 在类的构造函数和析构函数中没有匹配的调用new和delete函数* 程序循环new创建出来的对象没有及时的delete掉，导致了内存的泄露* delete掉一个void*类型的指针，导致没有调用到对象的析构函数，析构的所有清理工作都没有去执行从而导致内存的泄露；* new创建了一组对象数组，内存回收的时候却只调用了delete而非delete []来处理，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收，导致内存泄露；* 指向对象的指针数组不等同于对象数组* 缺少拷贝构造函数 如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符* 缺少重载赋值运算符* 没有将基类的析构函数定义为虚函数</code></pre><p>  造成野指针的原因：</p><pre><code>* 指针变量没有被初始化（如果值不定，可以初始化为NULL）* 指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置 为NULL.* 指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</code></pre><p><a href="https://blog.csdn.net/u012662731/article/details/78652651" target="_blank" rel="noopener">https://blog.csdn.net/u012662731/article/details/78652651</a></p><p>valgrind<br>  <a href="https://blog.csdn.net/ydyang1126/article/details/72667411" target="_blank" rel="noopener">https://blog.csdn.net/ydyang1126/article/details/72667411</a><br>  1、使用未初始化的内存<br>  2、内存读写越界<br>  3、内存覆盖<br>  4、动态内存管理错误<br>  5、内存泄漏</p><p>  工具<br>  1.Memcheck:这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够给发现开发中绝大多数的内存错误使用的情况，比如：使用未初始化<br>  2.callgrind：它主要用来检查程序中函数中调用过程中出现的问题<br>  3.cachegrind：它主要用来检查程序中缓存使用出现的问题<br>  4.Helgrind：它主要用来检查多线程中出现的竞争问题<br>  5.Massif:它主要用来检查程序中堆栈使用中出现的问题<br>  6.Extension:可以使用core提供的 功能，自己编写特定的内存调试工具</p><p>动态链接和静态链接的区别<br>动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统带的dll文件中，当程序运行时直接从操作系统中找。 而静态链接就是把所有用到的函数全部链接到exe文件中。</p><p>动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入;而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。</p><p>32位系统一个进程最多多少堆内存</p><p>多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）<br><a href="https://www.php.cn/faq/416853.html" target="_blank" rel="noopener">https://www.php.cn/faq/416853.html</a></p><p>写一个c程序辨别系统是64位 or 32位</p><h1 id="include-“stdio-h”"><a href="#include-“stdio-h”" class="headerlink" title="include “stdio.h”"></a>include “stdio.h”</h1><p>int main(int argc,char <em> argv[])<br>{<br>    void</em> number =  0;<br>    printf(“%d\n”,sizeof(&amp;number));<br>}</p><p>不用sizeof判断16位还是32位的例子</p><p>写一个c程序辨别系统是大端or小端字节序<br>typedef union {<br>    int i;<br>    char c;<br>} myUnion;<br>// 1: Little Endian; 0: Big Endian.<br>int isLittleEndian02(void)<br>{<br>    myUnion u;<br>    u.i = 1;<br>    return (u.i == u.c);<br>}</p><p>信号：列出常见的信号，信号怎么处理？<br>发送给进程的唯一信息通常是一个数<br>信号的两个主要目的：让进程知道已经发生了一个特定的事件；强迫进程执行它自己代码中的信号处理程序。<br><a href="https://blog.csdn.net/u010318270/article/details/81058037" target="_blank" rel="noopener">https://blog.csdn.net/u010318270/article/details/81058037</a></p><p>i++是否原子操作？并解释为什么？<br>内存到寄存器<br>寄存器自增<br>写回内存<br>这三个阶段中间都可以被中断分离开.</p><p>说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）<br><a href="https://www.cnblogs.com/liuwei0773/articles/9506748.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuwei0773/articles/9506748.html</a><br>原子操作：<br>自旋锁<br>  自旋锁的特点就是当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，<br>读写自旋锁<br>  读锁之间是共享的<br>  互斥的<br>信号量<br>  线程获取不到信号量的时候，不会像自旋锁一样循环区试图获取锁，而是进入睡眠，直至有信号量释放出来时，才会唤醒睡眠的线程，进入临界区执行。<br>读写信号量<br>互斥量<br>mutex<br>  mutex 计数值只能为 1，也就是说最多允许一个线程访问临界区。</p><p>顺序锁<br>它的特点是，读锁被获取的情况下，写锁仍然可以被获取。<br>使用顺序锁的读操作在读之前和读之后都会检查顺序锁的序列值。如果前后值不服，这说明在读的过程中有写的操作发生。那么该操作会重新执行一次，直至读前后的序列值是一样的。</p><p>1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放<br>2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用<br>4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。</p><p>预防死锁：<br>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）<br>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）<br>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）<br>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><p>解除死锁:</p><p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><p>列举说明linux系统的各类异步机制<br>信号，这是一种进程间通信的异步机制；<br>epoll，这是一种高效处理IO的异步通信机制。</p><p>exit()和_exit()的区别？<br>exit()会首先将所有使用atexit注册的函数进行调用以后再推出，而_exit()则是直接结束程序。<br>在exit()函数里会调用_exit()函数</p><p>如何实现守护进程？<br>守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种很有用的进程。<br><a href="https://blog.csdn.net/qq_26499321/article/details/72724173" target="_blank" rel="noopener">https://blog.csdn.net/qq_26499321/article/details/72724173</a></p><p>linux的内存管理机制是什么？<br><a href="https://blog.csdn.net/u013616945/article/details/77435607" target="_blank" rel="noopener">https://blog.csdn.net/u013616945/article/details/77435607</a><br>单一连续区<br>固定分区<br>可变分区<br>页式存储管理方案<br>  用户进程地址空间被划分成大小相等的部分，称为页或者页面，从0开始编号。<br>  内存空间按同样的大小分成划分成大小相等的区域，称为页框。从0开始编号。<br>  以页为单位来进行内存分配，按照进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。典型的页面尺寸是4K或4M。<br>  从进程的地址空间转换到实际的内存空间是通过查页表项（记录了逻辑页与页框号的对应关系，每一个进程一个页表，存放在内存）来实现的。CPU取到逻辑地址，自动划 分为页号和页内地址;用页号查页表，得到页框号，再与页内偏移拼接成物理地址。</p><p>段式存储管理方案<br>    用户进程地址空间按照程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名。<br>    内存空间被动态划分成若干长度不相同的区域，称为物理段，每个物理段有起始地址和长度决定<br>    内存分配规则：以段为单位进行分配，每段在内存占据连续空间，但各段之间可以不相邻。<br>    逻辑地址为段号+段内地址。</p><p>段页式存储管理方案<br>  用户进程地址空间先按段进行划分，每一段再按页面进行划分。<br>  内存空间：同页式存储方案。<br>  内存分配规则：同页式存储方案。<br>  逻辑地址如下：<br>虚拟内存技术<br>  基本思想：每个程序拥有自己的地址空间，这个空间被分割成很多个块，每一个块称为页面。每一页都有连续的地址范围。这些页被映射到物理内存，但并不是所有页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不再物理内存中的地址空间时，由操作系统（缺页异常）负责将缺失的部分装入物理内存并重新执行失败的指令。</p><p>linux的任务调度机制是什么？<br>先来先服务（队列）<br>最短优先（优先队列）<br>优先权调度算法的类型<br>高响应比优先调度算法<br>时间片轮转法<br>多级反馈队列调度算法<br>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。<br>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。<br>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p><p>标准库函数和系统调用的区别？<br>  系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。<br>  库函数调用则是面向应用开发的，库函数把系统调用进行封装或者组合，可以实现更多的功能<br>  库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分<br>  库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大<br>  库函数是有缓冲的，系统调用是无缓冲的<br>  系统调用依赖于平台，库函数并不依赖</p><p>补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？（这一题哥没有答出来）<br>  ：内核在进程所在的进程表项的信号域设置对应的信号的位，进程会维护一个未决信号的链表，处于用户态时就会处理信号。<br>  内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。<br>  进程检查信号的时机是：进程即将从内核态返回用户态时。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则唤醒。<br>进程有一个链表的数据结构，维护一个未决信号的链表。<br>信号在进程中注册，其实就是把该信号加入到这个未决信号链表当中。<br>可靠信号不管链表中是否已经有这个信号了，还是会加进去。不可靠信号，如果链表中已经有这个信号了，就会忽略。<br>进程处理信号的时机就是从内核态即将返回用户态的时候。<br>执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。<br>被屏蔽的信号，取消屏蔽后还会被检查。<br>c语言：</p><p>宏定义和展开（必须精通）</p><p>位操作（必须精通）</p><p>指针操作和计算（必须精通）</p><p>内存分配（必须精通）</p><p>sizeof必考</p><p>各类库函数必须非常熟练的实现</p><p>哪些库函数属于高危函数，为什么？（strcpy等等）<br>strcpy 赋值到目标区间可能会造成缓冲区溢出！</p><p>c++：<br>一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）</p><p>虚函数的作用和实现原理（必问必考，实现原理必须很熟）</p><p>sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）<br>  一个对象的大小大于等于所有非静态成员大小的总和。<br>  １. 为类的非静态成员数据的类型大小之和．<br>  ２. 编译器额外加入的成员变量的大小，用来支持语言的某些特性（如：指向虚函数的指针）．<br>  ３. 为了优化存取效率，进行的边缘调整（对齐<br>  ４. 与类中的构造函数，析构函数以及其他的成员函数无关．</p><p>指针和引用的区别（一般都会问到）</p><p>多重类构造和析构的顺序</p><p>stl各容器的实现原理（必考）</p><p>extern c 是干啥的，（必须将编译器的函数名修饰的机制解答的很透彻）<br>  主要作用就是为了能够正确实现C++代码调用其他C语言代码<br>  由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p><p>volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻）<br>  访问寄存器比访问内存单元要快,编译器会优化减少内存的读取，可能会读脏数据。声明变量为volatile，编译器不再对访问该变量的代码优化，仍然从内存读取，使访问稳定。<br>  特别在两个或多个进程之间通讯时,<br>  例如:进程A有变量volatile BOOL fOK;<br>进程B中某个线程B1一直处于等待状态,直到进程A的变量fOK为TRUE,结束等待.</p><p>static const等等的用法，（能说出越多越好）</p><p>数据结构或者算法：</p><p>《离散数学》范围内的一切问题皆由可能被深入问到（这个最坑爹，最重要，最体现功底，最能加分，特别是各类树结构的实现和应用）</p><p>各类排序：大根堆的实现，快排（如何避免最糟糕的状态？），bitmap的运用等等</p><p>hash， 任何一个技术面试官必问（例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞）<br>  危险出现在当假设所选非素数m=x*y，如果需要hash的key正好跟这个约数x存在关系就惨了，最坏情况假设都为x的倍数<br>  减少碰撞</p><p>  开放地址法 线性探测再散列。<br>  再哈希法<br>  链地址法<br>  建立一个公共溢出区<br>网络编程：<br>tcp与udp的区别（必问）</p><p>udp调用connect有什么作用？</p><p>tcp连接中时序图，状态图，必须非常非常熟练</p><p>socket服务端的实现，select和epoll的区别(必问)<br>  select和epoll属于I/O多路复用模型，用于持续监听多个socket，获取其IO事件。</p><p>  select 调用时轮询一次所有描述字，超时时再轮询一次。如果没有描述字准备好，则返回0；中途错误返回-1；有描述字准备好，则将其对应位置为1，其他描述字置为0，返回准备好的描述字个数。<br>    缺点</p><pre><code>  1. 最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，  2. 效率问题， select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，  3. 内核 / 用户空间 内存拷贝问题</code></pre><p>  epoll（触发）<br>  epoll采用了中断注册回调的方式，socket IO就绪时发出中断，然后将socket加入就绪队列。由三个系统调用：epoll_create，epoll_ctl，epoll_wait。<br>  能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率：它会复用文件描述符集合来传递结果，不需要每次等待事件之前都重新准备要被侦听的文件描述符集合；获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合。<br>  select/epoll都需要在内核和用户空间之间复制数据，epoll使用了内存映射(mmap)技术，将内核和用户空间指向同一块内存。</p><pre><code>1. Epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目2. 效率提升， Epoll 最大的优点就在于它只管你“活跃”的连接 ，而跟连接总数无关，3. Epoll 使用了“共享内存 ”</code></pre><p>  epoll_create 创建一个epoll句柄，size-监听套接字的数。当创建好epoll句柄后，会占用一个fd值，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗完。<br>  epoll_ctl 事件注册函数<br>  epoll_wait。 等待函数</p><p>  select - 如果同时建立很多连接，但只有少数事件发生，这种轮询会造成效率很低；频繁从内核拷贝、复制描述字；监听描述字受限于内核的FD_SETSIZE；<br>  epoll - 这种回调触发式操作会保证效率；不需要频繁的拷贝；监听描述字没有限止，只与系统资源有关；epoll返回时已经明确的知道哪个sokcet fd发生了事件，不用再一个个比对。</p><p>epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）<br>  Edge Triggered(简称ET) 仅当状态发生变化时才会通知<br>  Level Triggered(简称LT).,采用LT模式类似于原来的select/poll操作,只要还有没有处理的事件就会一直通知.</p><p>大规模连接上来，并发模型怎么设计<br>  TCP循环服务器 首先TCP服务器接受一个客户端的连接请求，处理连接请求，在完成这个客户端的所有请求后断开连接，然后再接受下一个客户端的请求。<br>  TCP并发服务器 并发服务器的思想是每一个客户端的请求并不由服务器的主进程直接处理，而是服务器主进程创建一个子进程来处理。<br>  UDP循环服务器 UDP服务器每次从套接字上读取一个客户端的数据报请求，处理接收到的UDP数据报，然后将结果返回给客户机。<br>  多路复用I/O并发服务器 创建子进程会带来系统资源的大量消耗，为了解决这个问题，采用多路复用I/O模型的并发服务器。采用select函数创建多路复用I/O模型的并发服务器</p><p>tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免time_wait状态占用资源（必须回答的详细）</p><p>tcp头多少字节？哪些字段?(必问)<br>  20 源端口 目的端口 序号 确认号 数据偏移 窗口 检验和 紧急指针 选项 填充<br>  <a href="https://www.cnblogs.com/Mr-F/p/9167917.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mr-F/p/9167917.html</a></p><p>  8个字节</p><p>什么是滑动窗口（必问）</p><p>conntect会阻塞，怎么解决?(必考必问，提示：设置非阻塞，返回之后用select检测状态)<br>  1.使用定时器；（最常用也最有效的一种方法）<br>  2.采用非阻塞模式：设置非阻塞，返回之后用select检测状态。</p><p>如果select返回可读，结果只读到0字节，什么情况？<br>  某个套接字集合中没有准备好，可能会select内存用FD_CLR清该位为0.</p><p>udp调用connect有什么作用<br>  1.因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。</p><p>keepalive 是什么东东？如何使用？<br>  TCP的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次心跳包，如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。</p><p>  HTTP的keep-alive一般我们都会带上中间的横杠，普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。</p><p>列举你所知道的tcp选项，并说明其作用。<br>  1、kind=0，选项表结束（EOP）选项<br>    一个报文段仅用一次。放在末尾用于填充，用途是说明：首部已经没有更多的消息，应用数据在下一个32位字开始处<br>  2、kind=1，空操作（NOP）选项<br>    没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍<br>  3、kind=2，最大报文段长度（MSS）选项<br>    TCP连接初始化时，通信双方使用该选项来协商最大报文段长度。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。<br>  4、kind=3，窗口扩大因子选项<br>    TCP连接初始化时，通信双方使用该选项来协商接收窗口的扩大因子。在TCP的头部中，接收窗口大小是用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。<br>    假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N*2M，或者说N左移M位。注意，M的取值范围是0～14。我们可以通过修改 /proc/sys/net/ipv4/tcp_window_scaling 内核变量来启用或关闭窗口扩大因子选项。<br>    和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收窗口大小就是该TCP报文段的实际接收窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。</p><p>  5、kind=4，选择性确认（Selective Acknowledgment，SACK）选项</p><pre><code>TCP通信时，如果某个TCP报文段丢失，则TCP会重传最后被确认的TCP报文段后续的所有报文段，这样原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能。SACK技术正是为改善这种情况而产生的，它使TCP只重新发送丢失的TCP报文段，而不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改 /proc/sys/net/ipv4/tcp_sack 内核变量来启用或关闭选择性确认选项。</code></pre><p>  6、kind=5，SACK实际工作的选项<br>    该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块（考虑选项类型和长度占用的2字节）。</p><p>  7、kind=8，时间戳选项。<br>    该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为TCP流量控制提供重要信息。我们可以通过修改 /proc/sys/net/ipv4/tcp_timestamps 内核变量来启用或关闭时间戳选项。</p><p>socket什么情况下可读？</p><p>db:<br>mysql，会考sql语言，服务器数据库大规模数据怎么设计，db各种性能指标</p><p>最后：补充一个最最重要，最最坑爹，最最有难度的一个题目：一个每秒百万级访问量的互联网服务器，每个访问都有数据计算和I/O操作，如果让你设计，你怎么设计？</p><p>1， 使用Linux epoll模型，水平触发模式（Level-Triggered）；当socket可写时，会不停的触发socket可写的事件，如何处理？</p><p>2， 从socket读数据时，socket缓存里的数据，可能超过用户缓存的长度，如何处理？ 例如，socket缓存有8kB的数据，而你的缓存只有2kB空间。</p><p>3， 向socket发送数据时， 可能只发送了用户缓存里的一半，如何处理？例如，需要向socket发送8kB数据，返回值只有2kB发送成功。</p><p>4， C++的虚函数是怎么实现的？</p><p>5， C++的虚函数有什么作用？</p><p>6， 非阻塞connect（）如何实现？</p><p>7，sizeof()问题</p><p>class A<br>{<br>  char c;<br>  int   val;<br>  short sh;<br>}</p><p>class B<br>{<br>    char c;<br>    int   val;<br>    short sh;<br>    void func1(void);<br>    virtual func2(void);<br>}</p><p>sizeof(A), sizeof(B) 分别是多少？</p><p>8， 实现字符串比较函数  strcmp</p><p>9， 实现内存拷贝函数  strcpy(void<em>dst, char </em> src, size_t len)</p><p>10，条件变量的如何使用? 你使用的线程函数是什么？</p><p>11， deamon进程如何实现？</p><p>12， HTTP和CGI是什么?</p><p>13， TCP的三次握手， TIME_WAIT和CLOSE_WAIT状态是什么？</p><p>因为第7题之后的属于客观题，不打算在此写答案。 朋友们如有好的答案也欢迎跟贴。</p><p>本人在此写出自己对前6个问题的回答：</p><p>1， 使用linux epoll模型，水平触发模式（Level-Triggered）；当socket可写时，会不停的触发socket可写的事件，如何处理？</p><p>第一种最普通的方式：<br>    当需要向socket写数据时，将该socket加入到epoll模型（epoll_ctl）；等待可写事件。<br>    接收到socket可写事件后，调用write()或send()发送数据。。。<br>    当数据全部写完后， 将socket描述符移出epoll模型。</p><pre><code>这种方式的缺点是：  即使发送很少的数据，也要将socket加入、移出epoll模型。有一定的操作代价。</code></pre><p>第二种方式，（是本人的改进方案， 叫做directly-write）</p><p>向socket写数据时，不将socket加入到epoll模型；而是直接调用send()发送；<br>    只有当或send()返回错误码EAGAIN（系统缓存满），才将socket加入到epoll模型，等待可写事件后，再发送数据。<br>    全部数据发送完毕，再移出epoll模型。</p><pre><code> 这种方案的优点：   当用户数据比较少时，不需要epool的事件处理。 在高压力的情况下，性能怎么样呢？     对一次性直接写成功、失败的次数进行统计。如果成功次数远大于失败的次数， 说明性能良好。（如果失败次数远大于成功的次数，则关闭这种直接写的操作，改用第一种方案。同时在日志里记录警告） 在我自己的应用系统中，实验结果数据证明该方案的性能良好。事实上，网络数据可分为两种到达/发送情况： 一是分散的数据包， 例如每间隔40ms左右，发送/接收3-5个 MTU（或更小，这样就没超过默认的8K系统缓存）。 二是连续的数据包， 例如每间隔1s左右，连续发送/接收 20个 MTU（或更多）。</code></pre><p>回来查了资料，发现以下两种方式：</p><pre><code>第三种方式：  使用Edge-Triggered（边沿触发），这样socket有可写事件，只会触发一次。         可以在应用层做好标记。以避免频繁的调用 epoll_ctl( EPOLL_CTL_ADD, EPOLL_CTL_MOD)。  这种方式是epoll 的 man 手册里推荐的方式， 性能最高。但如果处理不当容易出错，事件驱动停止。</code></pre><p>第四种方式：  在epoll_ctl()使用EPOLLONESHOT标志，当事件触发以后，socket会被禁止再次触发。<br>             需要再次调用epoll_ctl（EPOLL_CTL_MOD），才会接收下一次事件。   这种方式可以禁止socket可写事件，应该也会同时禁止可读事件。会带来不便，同时并没有性能优势，因为epoll_ctl（）有一定的操作代价。</p><p>2， 从socket读数据时，socket缓存里的数据，可能超过用户缓存的长度，如果处理？<br>       可以调用realloc()，扩大原有的缓存块尺寸。<br>       但是临时申请内存的有一定性能损失。</p><pre><code>  这种情况要看接收缓存的方式。</code></pre><p>第一种方式：  使用100k的大接收缓存为例。<br>               如果要等待数据，并进行解析。可能发生缓存不够的情况。此时只能扩充缓存，或先处理100k的数据，再接收新的数据。<br>第二种方式： 使用缓存队列，分成8K大小的队列。<br>               不存在接收缓存不够的情况。 除非用户解析已出错，使用数据接收、使用脱勾。 这种方式的代价是，可能需要将缓存队列再次拷贝、拼接成一块大的缓存，再进行解析。 而在本人的系统中，只需要将socket接收的数据再次原样分发给客户， 所以这种方案是最佳方案。</p><p>3， 向socket发送数据时， 可能只发送了用户缓存里的一半，然后失败，如何处理？</p><pre><code>  记录缓存的偏移量。 下一次socket写事件时， 再从偏移的位置接着发送。</code></pre><p>4， C++的虚函数是怎么实现的？<br>       使用虚函数表。<br>       回来查下资料：  C++对象使用虚表， 如果是基类的实例，对应位置存放的是基类的函数指针；如果是继承类，对应位置存放的是继承类的函数指针（如果在继承类有实现）。所以，当使用基类指针调用对象方法时，也会根据具体的实例，调用到继承类的方法。</p><p>5， C++的虚函数有什么作用？</p><pre><code>    虚函数作用是实现多态，   更重要的，虚函数其实是实现封装，使得使用者不需要关心实现的细节。在很多设计模式中都是这样用法，例如Factory、Bridge、Strategy模式。 前两天在书上刚好看到这个问题，但在面试的时候却没想起来。    个人觉得这个问题可以很好的区分C++的理解水平。</code></pre><p>6， 非阻塞connect（）如何实现？<br>       将socket设置成non-blocking，操作方法同非阻塞read()、write();<br>       面试官是在听到我介绍之后，才问我这个问题。可惜还是问我两遍。</p><p>select epoll</p><p>聚集索引和非聚集索引</p><p>网络编程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-网络编程</title>
      <link href="/2020/03/15/%E9%9D%A2%E7%BB%8F-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/03/15/%E9%9D%A2%E7%BB%8F-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TCP 建立连接和断开连接的过程？如果 server 没有 accept，连接会怎样？<br>UDP bind 和 connect 有什么用？<br>write 和 sendto 有什么区别？<br>对端异常掉线，本端调用 write 函数向 socket 写入数据，会出现什么情况？<br>nagle<br>shutdown() 和 close() 有什么区别？如何优雅关闭 socket ？</p><p>C++多重继承的对象模型？菱形继承的对象模型？</p><p>网络编程<br><a href="https://blog.csdn.net/f2935552941/article/details/88807548" target="_blank" rel="noopener">https://blog.csdn.net/f2935552941/article/details/88807548</a></p><p>poll机制与select机制类似，通过管理文件描述符来进行轮询，效率更高，并且处理的连接个数不受内核的限制。</p><p>如何解决高并发</p><p>1.尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。<br>2.html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现，比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。</p><p>3.使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器.</p><p>4.使用Ngnix负载均衡</p><p>5.优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。<br>优化数据库结构，多做索引，提高查询效率，数据库集群和库表散列<br>6.不要频繁得使用new对象，能使用单例模式就使用， 对于utility类型的类通过静态方法来访问。<br>7.使用线程安全的集合对象vector（已经过时可以使用CopyOnWriteArrayList）  hashtable<br>8.使用线程池。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-操作系统</title>
      <link href="/2020/03/15/%E9%9D%A2%E7%BB%8F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/03/15/%E9%9D%A2%E7%BB%8F-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>进程线程区别<br>  进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；<br>  线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；</p><p>  每个线程独自的寄存器组，指令计数器和处理器状态</p><p>进程间通信方式<br>  管道<br>  通信队列<br>  信号量<br>  信号<br>  共享内存<br>  socket</p><p>  进程间通讯的方式：</p><p>  管道中还有命名管道和非命名管道之分，非命名管道只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是先进先出的通讯方式。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO，因此也成为命名管。<br>  消息队列：是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！！！<br>  信号量， 不能传递复杂消息，只能用来同步<br>  共享内存，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写；</p><p>  几种方式的比较：<br>  管道：速度慢，容量有限<br>  消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。<br>  信号量：不能传递复杂消息，只能用来同步<br>  共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。</p><p>线程间通信方式<br>  临界区<br>  互斥量<br>  信号量<br>  信号</p><p>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。 2m</p><p>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</p><p>大小端<br><a href="https://blog.csdn.net/oqqhutu12345678/article/details/82823890" target="_blank" rel="noopener">https://blog.csdn.net/oqqhutu12345678/article/details/82823890</a></p><p>协程：<br>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。<br>  协程仅仅是一个特殊的函数<br>  一个进程可以包含多个线程，一个线程可以包含多个协程。<br>  一个线程内的多个协程虽然可以切换，但是多个协程是串行执行的，只能在一个线程内运行，没法利用CPU多核能力。<br>  协程与进程一样，切换是存在上下文切换问题的。</p><p>系统调用<br>  IO文件指令<br>  特权指令<br>  硬件资源请求</p><p>静态链接：<br>  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p><p>动态链接：<br>  动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；</p><p>  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p><p>请问怎么实现线程池<br>1.设置一个生产者消费者队列，作为临界资源<br>2.初始化n个线程，并让其运行起来，加锁去队列取任务运行<br>3.当任务队列为空的时候，所有线程阻塞<br>4.当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</p><p>  write 系统调用<br>  read 系统调用<br>  open 系统调用<br>  close 系统调用</p><p>请你说一下多进程和多线程的使用场景<br>  多进程模型的优势是CPU<br>  多线程模型主要优势为线程间切换代价较小，因此适用于I/O密集型的工作场景，<br>  因此I/O密集型的工作场景经常会由于I/O阻塞导致频繁的切换线程。同时，多线<br>  程模型也适用于单机多核分布式场景。<br>  多进程模型，适用于CPU密集型。同时，多进程模型也适用于多机分布式场景<br>  中，易于多机扩展。</p><p>  需要频繁创建销毁的优先用线程<br>    这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的<br>  需要进行大量计算的优先使用线程<br>    大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。<br>    这种原则最常见的是图像处理、算法处理。<br>  强相关的处理用线程，弱相关的处理用进程</p><p>  可能要扩展到多机分布的用进程，多核分布的用线程<br><a href="https://blog.csdn.net/weixin_39731083/article/details/82015830" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39731083/article/details/82015830</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-linux命令</title>
      <link href="/2020/03/15/%E9%9D%A2%E7%BB%8F-linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/03/15/%E9%9D%A2%E7%BB%8F-linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>磁盘<br>  df</p><p>CPU<br>  top</p><p>系统进程<br>  ps</p><p>内存<br>  free</p><p>网络查看命令<br>  netstat</p><p>io性能<br>  iostat<br>  iotop</p><p>查看端口<br>  lsof</p><p>Linux内存管理方法，页面置换算法，逻辑地址和物理地址的转换</p><p>hash表解决冲突的方法</p><p>redis中的数据结构</p><p>判断大小端，int的大端转小端<br>去掉字符串开头和末尾的空格<br>大数相加<br>最长公共子序列LCS<br>最小编辑距离<br>二叉树中两个节点的最近公共父节点<br>数据流的中位数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经-mysql</title>
      <link href="/2020/03/15/%E9%9D%A2%E7%BB%8F-mysql/"/>
      <url>/2020/03/15/%E9%9D%A2%E7%BB%8F-mysql/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库基础知识<br>1、为什么要使用数据库<br>2、什么是SQL？<br>3、什么是MySQL?<br>4、数据库三大范式是什么<br>5、mysql有关权限的表都有哪几个<br>  MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：<br>  user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。<br>  db权限表：记录各个帐号在各个数据库上的操作权限。<br>  table_priv权限表：记录数据表级的操作权限。<br>  columns_priv权限表：记录数据列级的操作权限。<br>  host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。<br>6、MySQL的binlog有有几种录入格式？分别有什么区别？<br>  Statement：每一条会修改数据的sql<br>  ROW不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><p>Mysql为什么用B树存储结构<br>  mysql的数据是放到外部存储的,因此我们必须减低磁盘的IO次数,因此我们需要尽量降低树的高度,树的分叉越多越好,因此B树正好符合我们的要求</p><p>数据类型<br>1、mysql有哪些数据类型</p><p>引擎<br>1、MySQL存储引擎MyISAM与InnoDB区别<br>  事务， 锁 外键</p><p>2、MyISAM索引与InnoDB索引的区别？<br>  InnoDB是聚集索引，表记录的排列顺序和与索引的排列顺序是否一致。聚集索引一个表只有一个，非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续<br>  在经常搜索一定范围的值时，通过索引找到第一条数据，根据物理地址连续存储的特点，然后检索相邻的数据，直到到达条件截至项。</p><p>  非聚集索引 非聚集索引就像根据偏旁部首查字典一样，字典前面的目录在逻辑上也是连续的，但是查两个偏旁在目录上挨着的字时，字典中的字却很不可能是挨着的。<br>  <a href="https://www.cnblogs.com/duzhentong/p/8639223.html" target="_blank" rel="noopener">https://www.cnblogs.com/duzhentong/p/8639223.html</a></p><p>  主键索引：以主键索引到整条记录<br>  辅助索引：以另一字段索引到主键<br>MyISAM是非聚集索引，索引和数据文件是分离的<br>  主键索引：以关键字索引到记录的<br>  辅助索引：以某字段索引到记录地址</p><p>  聚集索引优点：<br>  1、以最快的速度缩小查询范围。<br>  2、以最快的速度进行字段排序。<br>  聚集索引使用场合：<br>  1、此列包含有限数目的不同值。<br>  2、查询的结果返回一个区间的值。<br>  3、查询的结果返回某值相同的大量结果集。<br>  非聚集索引优点：<br>  1、非聚集索引比聚集索引层次多。<br>  3、添加记录不会引起数据顺序的重组。<br>  非聚集索引使用场合：<br>  1、此列包含了大量数目不同的值。<br>  2、查询的结束返回的是少量的结果集</p><p>3、InnoDB引擎的4大特性<br>一：插入缓冲 提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效<br>二：二次写 Doublewrite缓存是位于系统表空间的存储区域，用来缓存InnoDB的数据页从innodb buffer pool中flush之后并写入到数据文件之前，所以当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复<br>三：自适应哈希<br>b存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升<br>四：预读<br>4、存储引擎选择<br>线性预读（linear read-ahead）和随机预读（randomread-ahead）<br>为了区分这两种预读的方式，</p><p>索引<br>1、什么是索引？<br>2、索引有哪些优缺点？<br>3、索引使用场景（重点）<br>4、索引有哪几种类型？<br>普通索引、唯一索引、全文索引、单列索引、多列索引、空间索引</p><p>5、索引的数据结构（b树，hash）<br>6、索引的基本原理<br>7、索引算法有哪些？<br>8、索引设计的原则？<br>9、创建索引的原则（重中之重）<br>  对于查询频率高的字段创建索引<br>  对排序、分组、联合查询频率高的字段创建索引<br>  索引的数目不宜太多<br>  若在实际中，需要将多个列设置索引时，可以采用多列索引<br>  选择唯一性索引<br>  尽量使用数据量少的索引<br>  尽量使用前缀来索引<br>  删除不再使用或者很少使用的索引<br>10、创建索引的三种方式，删除索引<br>11、创建索引时需要注意什么？<br>12、使用索引查询一定能提高查询的性能吗？为什么<br>13、百万级别或以上的数据如何删除<br>  使用inner join 的方式删除起来，效率成倍的提升！<br>  然后根据使用的删除条件建立一个临时的索引,以此建立提高删除效率的索引,打造围绕一个字段的聚集型索引,以此为基地大大提升删除效率<br>  可以把要保留的数据备份出来。在drop表。重新创建，先不要急着创建索引、主键，把数据导回去，然后在建索引、约束之类的。<br>14、前缀索引<br>15、什么是最左前缀原则？什么是最左匹配原则<br>16、B树和B+树的区别<br>17、使用B树的好处<br>18、使用B+树的好处</p><pre><code>1. B+树很好的利用了局部性原理，预读2. B+树单次磁盘 IO 的信息量大于B树，从这点来看B+树相对B树磁盘 IO 次数少。3. B+Tree中因为数据都在叶子节点，所以每次查询的时间复杂度是固定的，因为稳定性保证了4. 而且叶子节点之间都是链表的结构，所以B+ Tree也是可以支持范围查询的，而B树每个节点 key 和 data 在一起，则无法区间查找。</code></pre><p>19、Hash索引和B+树所有有什么区别或者说优劣呢?<br>20、数据库为什么使用B+树而不是B树<br>21、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据<br>22、什么是聚簇索引？何时使用聚簇索引与非聚簇索引<br>23、非聚簇索引一定会回表查询吗？<br>24、联合索引是什么？为什么需要注意联合索引中的顺序？</p><p>事务<br>1、什么是数据库事务？<br>2、事物的四大特性(ACID)介绍一下?<br>3、什么是脏读？幻读？不可重复读？<br>4、什么是事务的隔离级别？MySQL的默认隔离级别是什么？</p><p>锁<br>1、对MySQL的锁了解吗<br>2、隔离级别与锁的关系<br>3、按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法<br>4、从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了<br>5、MySQL中InnoDB引擎的行锁是怎么实现的？<br>6、InnoDB存储引擎的锁的算法有三种<br>7、什么是死锁？怎么解决？<br>8、数据库的乐观锁和悲观锁是什么？怎么实现的？</p><p>视图<br>1、为什么要使用视图？什么是视图？<br>2、视图有哪些特点？<br>3、视图的使用场景有哪些？<br>4、视图的优点<br>5、视图的缺点<br>6、什么是游标？</p><p>存储过程与函数<br>1、什么是存储过程？有哪些优缺点？<br>存储过程是一个预编译的代码块，执行效率比较高<br>存储过程在服务器端运行，减少客户端的压力<br>允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用<br>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率<br>可以一定程度上确保数据安全</p><p>调试麻烦（没有像开发程序那样容易）<br>可移植性不灵活（因为存储过程依赖于具体的数据库）</p><p>触发器<br>1、什么是触发器？触发器的使用场景有哪些？<br>2、MySQL中都有哪些触发器？</p><p>常用SQL语句<br>1、SQL语句主要分为哪几类<br>2、超键、候选键、主键、外键分别是什么？<br>3、SQL 约束有哪几种？<br>4、六种关联查询<br>5、什么是子查询<br>6、子查询的三种情况<br>7、mysql中 in 和 exists 区别<br>8、varchar与char的区别<br>9、varchar(50)中50的涵义<br>10、int(20)中20的涵义<br>11、mysql为什么这么设计<br>12、mysql中int(10)和char(10)以及varchar(10)的区别<br>13、FLOAT和DOUBLE的区别是什么？<br>14、drop、delete与truncate的区别<br>15、UNION与UNION ALL的区别？</p><p>SQL优化<br>1、如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？<br>  通过执行计划可以了解查询方式、索引使用情况、需要扫描的数据量以及是否需要临时表或排序操作等信息。<br>  select_type子查询的查询类型 table type访问类型<br>2、SQL的生命周期？<br>3、大表数据查询，怎么优化<br>4、超大分页怎么处理？<br>5、mysql 分页<br>6、慢查询日志<br>7、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？<br>8、为什么要尽量设定一个主键？<br>9、主键使用自增ID还是UUID？<br>10、字段为什么要求定义为not null？<br>11、如果要存储用户的密码散列，应该使用什么字段进行存储？<br>12、优化查询过程中的数据访问<br>13、优化长难的查询语句<br>14、优化特定类型的查询语句<br>15、优化关联查询<br>16、优化子查询<br>17、优化LIMIT分页<br>18、优化UNION查询<br>19、优化WHERE子句</p><p>数据库优化<br>1、为什么要优化<br>2、数据库结构优化<br>3、MySQL数据库cpu飙升到500%的话他怎么处理？<br>4、大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？<br>垂直分表<br>适用场景<br>缺点<br>水平分表：<br>适用场景<br>水平切分的缺点<br>5、MySQL的复制原理以及流程<br>6、读写分离有哪些解决方案？<br><a href="https://www.cnblogs.com/mkl34367803/p/10703913.html" target="_blank" rel="noopener">https://www.cnblogs.com/mkl34367803/p/10703913.html</a><br>方案1：应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。<br>特点：<1>数据库和应用程序强耦合，数据库如果有变化还好影响主库。<2>应用程序复杂化。</p><p>方案2：利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。<br>特点：<1> 数据库和应用程序弱耦合。<2> 代理存在性能瓶颈和可靠性风险增加，相对可控。</p><p>7、备份计划，mysqldump以及xtranbackup的实现原理<br>8、数据表损坏的修复方式有哪些？</p><p>HTTPS工作原理</p><p>vector 参数</p><p>c++ 内存泄漏及其处理<br>  申请的空间未释放<br>  浅拷贝多次释放<br>  一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；<br>  二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存<br>  在释放对象数组时在delete中没有使用方括号<br>  指向对象的指针数组不等同于对象数组</p><p>  对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</p><p>  指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。</p><p>  缺少重载赋值运算符</p><p>  没有将基类的析构函数定义为虚函数</p><p>  造成野指针的原因：</p><p>  指针变量没有被初始化（如果值不定，可以初始化为NULL）<br>  指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.<br>  指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</p><p>4.使用C/C++语言开发的软件在运行时，出现内存泄漏。可以使用以下两种方式，进行检查排除:<br>  ⑴ 使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。<br>  ⑵ 调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</p><p>  解决内存泄漏最有效的办法就是使用智能指针（Smart Pointer）。使用智能指针就不用担心这个问题了，因为智能指针可以自动删除分配的内存。智能指针和普通指针类似，只是不需要手动释放指针，而是通过智能指针自己管理内存的释放，这样就不用担心内存泄漏的问题了。</p><p>  shared_ptr共享的智能指针：</p><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。在最后一个shared_ptr析构的时候，内存才会被释放。</p><p>注意事项：<br>1.不要用一个原始指针初始化多个shared_ptr。<br>2.不要再函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。<br>3.不要将this指针作为shared_ptr返回出来。<br>4.要避免循环引用。</p><p>unique_ptr独占的智能指针：</p><p><1>Unique_ptr是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个 unique_ptr。</p><p>unique_ptr不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再 拥有原来指针的所有权了。</p><p>一条SQL语句执行得很慢，要分两种情况：<br>大多数情况是正常，偶尔很慢<br>  数据库在处理数据忙时候，更新或新增数据都会暂时记录到redo log日志，等空闲时把数据同步到磁盘。假设数据库一直很忙，更新又频繁，redo log被写满，就不得不暂停其它操作把数据同步到磁盘，就有可能导致我们的SQL语句执行的很慢<br>  执行时遇到表锁行锁，别人操作数据库用到表或者行数据加锁了，只能慢慢等待别人释放锁</p><p>  这条SQL语句一直很慢<br>  <a href="https://www.cnblogs.com/myseries/p/10719074.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10719074.html</a><br>  1、大多数情况下很正常，偶尔很慢，则有如下原因<br>  (1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。<br>  (2)、执行的时候，遇到锁，如表锁、行锁。<br>  2、这条 SQL 语句一直执行的很慢，则有如下原因。<br>  (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。<br>  (2)、数据库选错了索引。</p><p>接口安全性设计<br>  Token授权机制<br>  时间戳超时机制<br>  签名机制<br>  拒绝重复调用</p><p>  完全开放的接口<br>  接口参数加密<br>  接口参数加密+接口时效性验证<br>  接口参数加密+时效性验证+私钥<br>  接口参数加密+时效性验证+私钥+Https</p><p>网络编程与TCP<br><a href="https://blog.csdn.net/qq_28584889/article/details/88751304" target="_blank" rel="noopener">https://blog.csdn.net/qq_28584889/article/details/88751304</a></p><p>select for update 是为了在查询时,对这条数据进行加锁,避免其他用户以该表进行插入,修改或删除等操作,造成表的不一致性.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试-计算机网络</title>
      <link href="/2020/03/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/03/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/weiyuefei/article/details/50413543" target="_blank" rel="noopener">https://blog.csdn.net/weiyuefei/article/details/50413543</a></p><ol><li>计算机网络体系结构<br><img src="计算机网络体系结构.png" alt="计算机网络体系结构"></li></ol><p>OSI七层模型及其包含的协议如下:<br>  物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45<br>  数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP<br>  网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP<br>  传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP<br>  会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS<br>  表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII<br>  应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS</p><p>TCP/IP 4层模型包括：<br>  网络接口层：MAC VLAN<br>  网络层:IP ARP ICMP<br>  传输层:TCP UDP<br>  应用层:HTTP DNS SMTP</p><ol><li><p>TCP和UDP的区别</p><ul><li>TCP是面向连接的 UDP是面向无连接的</li><li>TCP使用的是全双工可靠的信道 UDP是不可靠信道</li><li>TCP只能进行一对一的单播 UDP可以进行组播和广播</li><li>TCP提供可靠的交付 UDP尽最大可能进行交付</li><li>TCP面向字节流的传输 UDP面向报文传输</li></ul></li><li><p>TCP如何保证可靠传输</p><ul><li>连接管理  保证可靠的连接</li><li>校验和 确保传输无误</li><li>序列号 将接收到的序号进行排序</li><li>确认应答  告诉对方已经收到</li><li>超时重传  保证不丢包</li><li>流量控制  对网络进行适配</li><li>拥塞控制  对网络进行适配</li></ul></li><li><p>TCP连接的三次握手，四次挥手</p></li><li><p>为什么要四次挥手<br>因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p></li><li><p>为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？<br>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。<br>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</p></li><li><p>DNS工作流程</p></li><li><p>请你说一说HTTP和HTTPS的不同</p><ul><li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</li><li>HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥</li><li>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</li><li>HTTP协议端口是80，HTTPS协议端口是443</li></ul></li><li><p>浏览器中输入URL<br>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p></li></ol><p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p><ol><li><p>请你说一说TCP拥塞控制<br>1、慢开始<br>2、拥塞避免<br>3、快重传<br>4、快恢复</p></li><li><p>HTTP工作过程</p><ol><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放连接TCP连接</li><li>客户端浏览器解析HTML内容</li></ol></li><li><p>请你来说一下socket编程中服务器端和客户端主要用到哪些函数<br>基于TCP的socket：<br>基于UDP的socket：</p></li></ol><p>accept()函数与三次握手的关系</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2020/03/12/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2020/03/12/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>C++五大储存区</li></ol><p>程序代码区： 存放函数体的二进制代码</p><ol><li>extern关键字的作用<br>extern关键字可以用来声明变量和函数作为外部变量或者函数供其它文件使用。<br>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。</li></ol><p><a href="https://www.cnblogs.com/banmei-brandy/p/11338314.html" target="_blank" rel="noopener">https://www.cnblogs.com/banmei-brandy/p/11338314.html</a></p><p>extern 函数声明 定义</p><ol><li>static关键字作用<br>（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br>（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；(在其他模块用需要使用using namespace)；<br>（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br>（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</li><li><p>volatile的作用<br>volatile关键字是防止在共享的空间发生读取的错误。只保证其可见性，不保证原子性；使用volatile指每次从内存中读取数据，而不是从编译器优化后的缓存中读取数据，简单来讲就是防止编译器优化。</p></li><li><p>const 作用</p></li></ol><p>只读不可写</p><ol><li><p>new和malloc的区别</p></li><li><p>sizeof的运算结果，</p></li></ol><p>sizeof运算符的结果部分地依赖于其作用的类型：</p><ul><li>对char或者类型为char的表达式执行sizeof运算，结果得1</li><li>对引用类型执行sizeof运算符得到被引用对象所占空间的大小</li><li>对指针执行sizeof运算得到指针本身所占空间的大小</li><li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效</li><li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算符并将所得结果求和。注意：sizeof运算不会吧数组转换为指针来处理</li><li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。<br>　 因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的带下得到数组中元素的个数。<br>因为sizeof的返回值是一个常量表达式，所以可以用sizeof的结果声明数组的维度。</li></ul><ol><li>C++多态性与虚函数表<ol><li>虚函数表是针对类还是针对对象的？<br>虚函数表是针对类的，一个类的所有对象的虚函数表都一样</li><li>虚指针(vptr)：每个含有虚方法（虚函数）对象里有虚表指针，指向虚表。<br>虚函数表：虚函数表是顺序存放虚函数地址的，虚表是顺序表，表里存放了虚函数的地址。</li><li>虚函数和纯虚函数<br>用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。<br>纯虚函数是虚函数再加上 = 0；</li><li>抽象类是指包括至少一个纯虚函数的类。</li><li>虚析构函数:只有当一个类被定义为基类的时候，才会把析构函数写成虚析构函数。<br>为什么一个类为基类，析构函数就需要写成虚析构？<br>假设现在有一个基类指针，指向派生类。此时释放基类指针，如果基类没有虚析构函数，此时只会看指针的数据类型，而不会看指针指向的数据类型，所以此时会发生内存泄露。</li><li>构造函数不能声明为虚函数的原因 :<ol><li>构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。</li><li>虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初 始化，将无法进行。</li></ol></li><li>不要在构造函数中调用虚函数的原因：<ol><li>在概念上，构造函数的工作是为对象进行初始化。在构造函数完成之前，被构造的对象被认为“未完全生成”。当创建某个派生类的对象时，如果在它的基类的构造函数中调用虚函数，那么此时派生类的构造函数并未执行，所调用的函数可能操作还没有被初始化的成员，<br>先调用父类构造，父类都没创建完，子类没有</li><li>包含虚函数的类对象的虚指针被安排在对象的起始地址处，并且虚函数表（vtable）的地址是由构造函数写入虚指针的。所以，一个类的构造函数在执行时，并不能保证该函数所能访问到的虚指针就是当前被构造对象最后所拥有的虚指针，因为后面派生类的构造函数会对当前被构造对象的虚指针进行重写，因此无法完成动态联编。<br>不要在析构函数中调用虚函数的原因：<br>在析构函数中调用虚函数，函数的入口地址也是在编译时静态决定的。<br>就是说先调用子类的析构函数，子类已经没了，再调用父类的析构函数，子类都没了，虚函数还有什么用，也已经没了</li></ol></li><li>析构函数不能抛出异常<br>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。<br>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。<br>不要在析构函数中抛出异常！</li><li>构造函数不能抛出异常<br>构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放<br>构造函数中尽量不要抛出异常，能避免的就避免，如果必须，要考虑不要内存泄露！</li></ol></li><li><p>指针和引用的区别<br>相同点：</p><ol><li>指针和引用都可以优化传参效率</li><li>都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。<br>引用和指针的不相同点<br>不同点：</li><li>指针占内存空间，引用不占内存空间</li><li>指针可以为空，但是引用不能为空</li><li>指针可以不初始化，但是引用必须初始化</li><li>指针可以有多级，但是引用只能是一级<code>（int **p合法但是int &amp;&amp;a是不合法的）</code></li><li>指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了，从一而终。</li><li>指针是一种变量，而引用只是引用。</li></ol></li><li><p>内联函数的优缺点<br>优点：</p><ol><li>内联函数发生在程序的编译期间，程序执行又比较简短的，大大增大代码执行效率。<br>缺点：</li><li>如果函数的代码较长，使用内联将消耗过多内存</li><li>内联函数以复制为代价，活动产函数开销</li><li>如果函数体内有循环，那么执行函数代码时间比调用开销大</li></ol></li><li><p>STL set、map实现为什么要以红黑树为底层实现机制？</p><p>为什么set、map的实现要采用红黑树？</p></li><li><p>STL标准库，基础中的要点</p><p>• map和set是基于什么实现的？红黑树的特点。<br>红黑树是一种特殊的平衡二叉搜索树，<br>1.每个节点只能是红色或者黑色。<br>2.根节点必须是黑色。<br>3.红色的节点，它的叶节点只能是黑色。<br>4.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>• vector和list在储存上的区别。多维数组在储存上是连续的吗？<br>是<br> 底层数据结构为数组 ，支持快速随机访问<br> 底层数据结构为双向链表，支持快速增删<br>• queue和stack的实现，是数组还是链表？<br> deque是一个双端队列<br> 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制</p><p>•  map 和 set<br>set 底层数据结构为红黑树，有序，不重复<br>map 底层数据结构为红黑树，有序，不重复<br>• map中的元素是自定义结构体，这个结构体有什么要求？（需要重载operator&lt;）</p></li><li><p>必须在构造函数初始化式里进行初始化的数据成员<br>常量成员，const修饰的成员变量，因为常量只能初始化不能赋值，所以也要写在初始化列表里面；<br>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；<br>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化</p></li><li><p>C++ STL 中 remove 和 erase 的区别<br>erase一般是要释放资源，真正删除元素的，<br>而remove主要用在vector中，用于将不符合要求的元素移到容器尾部，而并不删除不符合要求的元素</p></li><li><p>c++ 智能指针 <a href="https://www.cnblogs.com/water-bear/p/12095252.html" target="_blank" rel="noopener">https://www.cnblogs.com/water-bear/p/12095252.html</a></p></li></ol><p>右值引用的目的主要是为了是减少内存拷贝，优化性能。</p><ol><li>数据库的三大范式<br>第一范式就是属性不可分割，每个字段都应该是不可再拆分的。比如一个字段是姓名（NAME），在国内的话通常理解都是姓名是一个不可再拆分的单位，这时候就符合第一范式；但是在国外的话还要分为FIRST NAME和LAST NAME，这时候姓名这个字段就是还可以拆分为更小的单位的字段，就不符合第一范式了。</li></ol><p>第二范式就是要求表中要有主键，表中其他其他字段都依赖于主键，因此第二范式只要记住主键约束就好了。比如说有一个表是学生表，学生表中有一个值唯一的字段学号，那么学生表中的其他所有字段都可以根据这个学号字段去获取，依赖主键的意思也就是相关的意思，因为学号的值是唯一的，因此就不会造成存储的信息对不上的问题，即学生001的姓名不会存到学生002那里去。</p><p>第三范式就是要求表中不能有其他表中存在的、存储相同信息的字段，通常实现是在通过外键去建立关联，因此第三范式只要记住外键约束就好了。比如说有一个表是学生表，学生表中有学号，姓名等字段，那如果要把他的系编号，系主任，系主任也存到这个学生表中，那就会造成数据大量的冗余，一是这些信息在系信息表中已存在，二是系中有1000个学生的话这些信息就要存1000遍。因此第三范式的做法是在学生表中增加一个系编号的字段（外键），与系信息表做关联。</p><ol><li>程序运行过程</li></ol><p>进程为程序的执行提供了一个虚拟执行环境，叫做进程空间。应用程序仿佛运行在一个独立的虚拟机器上，独占CPU和内存空间，通过标准接口（系统调用）来访问系统资源。<br>进程概念体现了容器的核心思想，即为应用程序的执行提供独立的空间<br>让它不仅支持CPU和内存的隔离，还要支持其它资源的隔离<br>通过Hypervisor层 ——— 一种运行在基础物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享硬件。<br>这就是Linux内核的命名空间功能进行计算资源的隔离</p><p>内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。<br>当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。</p><p>&lt;&gt;表示从系统目录下开始搜索，然后再搜索PATH环境变量所列出的目录，不搜索当前目录<br>“”表示先从当前目录搜索，然后是系统目录和PATH环境变量所列出的目录下搜索</p><p>什么是迭代器失效（vector扩容）。<br>  迭代器失效就是因为扩容，删除元素等缘故，导致原先容器的空间变化，进而导致迭代器（begin()和end()）发生了变化，从而失效</p><p>  当插入（push_back）一个元素后，end操作返回的迭代器肯定失效，因为vector只允许从尾插。</p><p>  List/set/map迭代器的失效情况：<br>  删除时，指向该删除节点的迭代器失效,<br>  其它任何增加、删除元素的操作都不会使迭代器失效。</p><p>c++ 编译过程<br>  预编译  宏展开<br>  编译  单独编译每个源文件<br>  链接 可执行文件</p><p>对象内存布局详解<br><a href="https://blog.csdn.net/ljianhui/article/details/46408645" target="_blank" rel="noopener">https://blog.csdn.net/ljianhui/article/details/46408645</a></p><p>c++ 对象大小计算<br>  sizeof计算类的大小时，只计算（非static的）数据成员变量即可，不用考虑那些成员函数</p><p>  看出空类的内存所占大小为1字节而非0，这是因为c++中，规定任何不同的对象不能拥有相同的内存地址。 </p><pre><code>   也就是说，如果空类不占大小的话，那么同一类定义出多个对象后就会无法分辨出地址，且在C++中规定了任何不同的对象不能拥有相同的内存地址，所以编译器给了空类一个字节来唯一标识这个类。</code></pre><p>内存对齐的原因</p><p>1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。<br>2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p><p>三五法则</p><ol><li>需要析构函数的类也需要拷贝构造函数和拷贝赋值函数。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然。</li><li>析构函数不能是删除的</li><li>如果一个类有删除的或不可访问的析构函数，那么其默认和拷贝构造函数会被定义为删除的。</li><li>如果一个类有const或引用成员，则不能使用合成的拷贝赋值操作。</li></ol><p>explicit (避免隐式转换)<br><a href="https://www.cnblogs.com/rednodel/p/9299251.html" target="_blank" rel="noopener">https://www.cnblogs.com/rednodel/p/9299251.html</a></p><p>类型萃取<br><a href="https://www.cnblogs.com/qq329914874/p/6729481.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq329914874/p/6729481.html</a></p><p>类可以实现在实现写在头文件<br>1.如果定义在类的内部，语法上是正确的；但是如果你要修改类的实现；由于实现在头文件里，导致项目中所有包含了该头文件的cpp文件都需要重新编译；如果实现在单独的cpp文件里，修改实现，只会重新编译一个cpp文件。<br>2.如果定义在头文件里，在类的外部；在多个文件包含该头文件时会在链接时产生重定义。</p><p>为什么宏喜欢用do while<br>使用do{…}while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</p><p>c++ 模版是怎么实现的<br><a href="https://blog.csdn.net/lianhunqianr1/article/details/79966911" target="_blank" rel="noopener">https://blog.csdn.net/lianhunqianr1/article/details/79966911</a></p><ol><li>函数模板的签名包括模板参数，返回值，函数名，函数参数,  cv-qualifier；</li><li>函数模板编译顺序大致：名称查找(可能涉及参数依赖查找)-&gt;实参推导-&gt;模板实参替换(实例化,可能涉及 SFINAE)-&gt;函数重载决议-&gt;编译；</li><li>函数模板可以在实例化时候进行参数推导，必须知道每个模板的实参，但不必指定每个模板的实参。编译器会从函数实参推导缺失的模板实参。这发生在尝试调用函数、取函数模板地址时，和某些其他语境中；</li><li>函数模板在进行实例化后(template argument deduction/substitution)会进行函数重载解析（overloading resolution, 此时的函数签名不包括返回值；</li><li>函数模板实例化过程中，参数推导不匹配所有的模板或者同时存在多个模板实例满足，或者函数重载决议有歧义等，实例化失败；</li><li><p>为了编译函数模板调用，编译器必须在非模板重载、模板重载和模板重载的特化间决定一个无歧义最佳的模板；</p><p>SFINAE -Substitution failure is not an error ；<br>要理解这句话的关键点是failure和error在模板实例化中意义，模板实例化时候，编译器会用模板实参或者通过模板实参推导出参数类型带入可能的模板集（模板备选集合）中一个一个匹配，找到最优匹配的模板定义，<br>模板特化<br>模板实参推导</p></li></ol><p>C++ 11 了解多少<br>  nullptr 关键字，专门用来区分空指针、0。<br>  auto 和 decltype 这两个关键字实现了类型推导<br>  序列for循环 变长參数的模板 更加优雅的初始化方法</p><p>移动语义和完美转发介绍一下？<br>移动语义(std::move)和完美转发(std::forward)</p><p>完美转发怎么实现的？什么原理？</p><p>线程有哪些独立的资源？<br>  栈 寄存器</p><p>线程的状态都有哪些？<br>  新建 就绪 运行 终止 阻塞<br>是否了解协程？讲一讲协程的原理<br>  进程 拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。<br>  线程 拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度。<br>  协程 和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。<br>  <a href="https://www.jianshu.com/p/8dacf1e8cb7c" target="_blank" rel="noopener">https://www.jianshu.com/p/8dacf1e8cb7c</a></p><p> 无锁编程接触过吗？介绍一下cas</p><p> linux 的虚拟内存是什么？</p><p> 分段和分页有什么区别？</p><p> 如何检测内存泄露？不使用 valgrind 类似的工具</p><p> 如何避免内存泄漏？</p><p>C++ 11 智能指针用过吗？需要注意哪些？</p><p>为什么要 2 倍扩容？</p><p>假如让你写一个测试程序用来测试vector，你会从哪些角度去考虑？</p><p>C++ stl 的内存管理是怎么做的？</p><p> 有没有写过线程池？如何实现一个高性能的线程池？你能想到哪些方面？</p><p> 继承和组合的区别<br>  继承是代码复用的一种方式<br>  组合体现的是整体和部分，强调的是has-a的关系。<br>  继承与组合的优缺点</p><p>  继承的优缺点</p><p>  优点：</p><p>  支持扩展，通过继承父类实现，但会使系统结构较复杂<br>  易于修改被复用的代码<br>  缺点：</p><p>  代码白盒复用，父类的实现细节暴露给子类，破坏了封装性<br>  当父类的实现代码修改时，可能使得子类也不得不修改，增加维护难度。<br>  子类缺乏独立性，依赖于父类，耦合度较高<br>  不支持动态拓展，在编译期就决定了父类<br>  组合的优缺点</p><p>  优点：</p><p>  代码黑盒复用，被包括的对象内部实现细节对外不可见，封装性好。<br>  整体类与局部类之间松耦合，相互独立。<br>  支持扩展<br>  每个类只专注于一项任务<br>  支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</p><p>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中<br>short x；<br>char x0;<br>x=0x1122;<br>x0=((char*)&amp;x)[0]; //低地址单元<br>if(x0==0x11)printf(“大端\n”);<br>else printf(“小端\n”);</p><p>memcpy和memmove的区别</p><p>怎么在海量数据中找出重复次数最多的一个<br><a href="https://blog.csdn.net/u010601183/article/details/56481868/" target="_blank" rel="noopener">https://blog.csdn.net/u010601183/article/details/56481868/</a></p><p>堆栈溢出的原因</p><p>1.函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。<br>2.动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。<br>3.数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。<br>4.指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。</p><p>左值和右值<br>lvalue（locator value）代表一个在内存中占有确定位置的对象（换句话说就是有一个地址）。<br>rvalue通过排他性来定义，每个表达式不是lvalue就是rvalue。因此从上面的lvalue的定义，rvalue是在不在内存中占有确定位置的表达式。<br><a href="https://www.cnblogs.com/likaiming/p/9045642.html" target="_blank" rel="noopener">https://www.cnblogs.com/likaiming/p/9045642.html</a></p><p>模版<br><a href="https://www.cnblogs.com/xuelisheng/p/9329903.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuelisheng/p/9329903.html</a></p><p>引用计数增加主要有以下场景：</p><ol><li>对象被创建时：a = “ABC”；</li><li>另外的别人被创建时：b = a；</li><li>被作为参数传递给函数时：foo(a)；</li><li>作为容器对象（list，元组，字典等）的一个元素时：x = [1,a,’33’]。<br>引用计数减少主要有以下场景：</li><li>一个本地引用离开了它的作用域时，比如上面的foo(a)函数结束时，a指向的对象引用减1；</li><li>对象的引用被显式的销毁时：del a 或者 del b；</li><li>对象的引用被赋值给其他对象时：a = 789；</li><li>对象从一个容器对象（例如list）中移除时：L.remove(a)；</li><li>容器对象本身被销毁：del L，或者容器对象本身离开了作用域。</li></ol><p>select epoll</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP-内存管理</title>
      <link href="/2020/03/11/CPP-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/11/CPP-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。</p><a id="more"></a><h4 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h4><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p><ul><li>栈，在执行函数时，函数内局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li></ul><p>　* 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>　* 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p><p>　* 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，</p><p>　* 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456\0在常量区，p3在栈上。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>； <span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">//分配得来得10和20字节的区域就在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块。</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h4><ol><li>管理方式不同<br>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</li><li>空间大小不同<br>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，</li><li>能否产生碎片不同<br>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出</li><li>生长方向不同<br>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</li><li>分配方式不同<br>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</li><li>分配效率不同<br>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-https工作流程</title>
      <link href="/2020/03/11/CS-https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/11/CS-https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输安全协议）<br>HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。<br><a id="more"></a></p><h4 id="HTTPS加密过程："><a href="#HTTPS加密过程：" class="headerlink" title="HTTPS加密过程："></a>HTTPS加密过程：</h4><p>  客户端请求服务器获取证书公钥<br>  客户端(SSL/TLS)解析证书（无效会弹出警告）<br>  生成随机值<br>  用公钥加密随机值生成密钥<br>  客户端将秘钥发送给服务器<br>  服务端用私钥解密秘钥得到随机值<br>  将信息和随机值混合在一起进行对称加密<br>  将加密的内容发送给客户端<br>  客户端用秘钥解密信息<br><img src="https.png" alt="https"></p><h4 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h4><p>  信息加密传输：第三方无法窃听；<br>  校验机制：一旦被篡改，通信双方会立刻发现；<br>  身份证书：防止身份被冒充。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB-Mysql系统学习</title>
      <link href="/2020/03/10/DB-Mysql%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/10/DB-Mysql%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://juejin.im/post/5e319a805188254dbc25ee2e" target="_blank" rel="noopener">https://juejin.im/post/5e319a805188254dbc25ee2e</a></p><p><a href="https://blog.csdn.net/qq_26584263/article/details/86497878" target="_blank" rel="noopener">https://blog.csdn.net/qq_26584263/article/details/86497878</a></p><p><a href="https://blog.csdn.net/ichglauben/article/details/81204375" target="_blank" rel="noopener">https://blog.csdn.net/ichglauben/article/details/81204375</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI-卷积神经网络</title>
      <link href="/2020/03/09/AI-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/03/09/AI-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>模型结构<br>  (卷积层 + (可选)池化层) <em> N + 全连接层 </em> M 用于分类任务</p><p>  全卷积神经网络 (卷积层 + (可选)池化层) <em> N) + 反卷积层 </em> K 用于物体分割</p><p>神经网络遇到的问题：</p><ul><li>参数过多</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI-常见问题及解决</title>
      <link href="/2020/03/06/AI-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/03/06/AI-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>过拟合</li><li>Batchsize</li><li>梯度弥散</li></ul><a id="more"></a><h5 id="什么是过拟合Overfit）"><a href="#什么是过拟合Overfit）" class="headerlink" title="什么是过拟合Overfit）"></a>什么是过拟合Overfit）</h5><p>　　一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好的拟合数据。此时我们就叫这个假设出现了overfit的现象。<br>　　 <img src="过拟合.jpg" alt="过拟合"></p><p>　　如上图所示：过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</p><p>　</p><h5 id="造成过拟合的原因"><a href="#造成过拟合的原因" class="headerlink" title="造成过拟合的原因"></a>造成过拟合的原因</h5><pre><code>* 模型的vc维过高，使用了过强的模型复杂度(model complexity)的能力。（参数多并且过训练）* 数据中的噪声，造成了如果完全拟合的话，也许与真实情景的偏差更大。* 数据量有限，这使得模型无法真正了解整个数据的真实分布。* 权值学习迭代次数足够多(Overtraining),拟合了训练数据中的噪声和训练样例中没有代表性的特征。</code></pre><h5 id="过拟合解决方法"><a href="#过拟合解决方法" class="headerlink" title="过拟合解决方法"></a>过拟合解决方法</h5><ol><li>权值衰减<br>　　在每次迭代过程中以某个小因子降低每个权值,这等效于修改E的定义,加入一个与网络权值的总量相应的惩罚项,此方法的动机是保持权值较小,避免weight decay,从而使学习过程向着复杂决策面的反方向偏。（L2正则化）</li><li>适当的stopping criterion（验证集）</li><li>Cross-validation with some patterns<br>　　交叉验证方法在可获得额外的数据提供验证集合时工作得很好,但是小训练集合的过度拟合问题更为严重<br>　　k-fold交叉方法:把训练样例分成k份,然后进行k次交叉验证过程,每次使用不同的一份作为验证集合,其余k-1份合并作为训练集合.每个样例会在一次实验中被用作验证样例,在k-1次实验中被用作训练样例;每次实验中,使用上面讨论的交叉验证过程来决定在验证集合上取得最佳性能的迭代次数n*,然后计算这些迭代次数的均值,作为最终需要的迭代次数。<br>４. 正则化<br>　　这里有点疑问，正则化是为了防止过拟合还是为了解决过拟合。对部分无用的feature，定义其parameter(p3,p4)非常大，这样会导致训练结果w3,w4非常小，几乎为0，降低模型复杂度。</li></ol><h5 id="Batchsize的影响"><a href="#Batchsize的影响" class="headerlink" title="Batchsize的影响"></a>Batchsize的影响</h5><p>　　Batch_Size（批尺寸）是机器学习中一个重要参数。<br>　　1. 如果数据集比较小，完全可以采用全数据集 （ Full Batch Learning ）的形式，这样做至少有 2 个好处：其一，由全数据集确定的方向能够更好地代表样本总体，从而更准确地朝向极值所在的方向。其二，由于不同权重的梯度值差别巨大，因此选取一个全局的学习率很困难。<br>　　2. Batch_Size = 1。这就是在线学习（Online Learning）。使用在线学习，每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。<br>　　3. 如果网络中采用minibatch SGD算法来优化，所以是一个batch一个batch地将数据输入CNN模型中，然后计算这个batch的所有样本的平均损失，即代价函数是所有样本的平均。而batch_size就是一个batch的所包含的样本数，显然batch_size将影响到模型的优化程度和速度。mini batch只是为了充分利用GPU memory而做出的妥协　</p><h5 id="改变Batch-Size的影响"><a href="#改变Batch-Size的影响" class="headerlink" title="改变Batch_Size的影响"></a>改变Batch_Size的影响</h5><p>　　1. 在合理范围内，增大 Batch_Size 的好处：内存利用率提高了，大矩阵乘法的并行化效率提高。跑完一次 epoch（全数据集）所需的迭代次数减少，对于相同数据量的处理速度进一步加快。在一定范围内，一般来说 Batch_Size 越大，其确定的下降方向越准，引起训练震荡越小。</p><h5 id="梯度弥散"><a href="#梯度弥散" class="headerlink" title="梯度弥散"></a>梯度弥散</h5><p>　　梯度弥散的问题很大程度上是来源于激活函数的“饱和”。因为在后向传播的过程中仍然需要计算激活函数的导数，所以一旦卷积核的输出落入函数的饱和区，它的梯度将变得非常小。梯度弥散。使用反向传播算法传播梯度的时候，随着传播深度的增加，梯度的幅度会急剧减小，会导致浅层神经元的权重更新非常缓慢，不能有效学习。这样一来，深层模型也就变成了前几层相对固定，只能改变最后几层的浅层模型。　</p><h5 id="如何解决梯度弥散"><a href="#如何解决梯度弥散" class="headerlink" title="如何解决梯度弥散"></a>如何解决梯度弥散</h5><ol><li>Relu代替sigmoid</li><li>梯度裁剪</li><li>RNN-LSTM</li><li>批归一化</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI-CV学习之路</title>
      <link href="/2020/03/06/AI-CV%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/03/06/AI-CV%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>防止过拟合 DropOut Image Augmentation</p><p>计算机视觉比赛<br>ImageNet<br>Kaggle</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy-常用接口简述</title>
      <link href="/2020/03/04/numpy-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/04/numpy-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>numpy 常用接口描述<br><a id="more"></a><br>用来存取多维对象数据</p><h4 id="numpy数组创建"><a href="#numpy数组创建" class="headerlink" title="numpy数组创建"></a>numpy数组创建</h4><p>arr = np.array([1,2,3])</p><h5 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h5><p>获取数据的维度</p><h4 id="dype"><a href="#dype" class="headerlink" title="dype"></a>dype</h4><p>获取数组的类型</p><h4 id="ndim"><a href="#ndim" class="headerlink" title="ndim"></a>ndim</h4><p>最外层维度</p><h4 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros()"></a>np.zeros()</h4><pre><code> np.ones() np.empty() np.arrage()</code></pre><h4 id="astype"><a href="#astype" class="headerlink" title="astype()"></a>astype()</h4><p>  数据类型转换</p><h4 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h4><p>数组在不用写循环的情况下就能进行批量运算</p><h4 id="numpy数组的索引和切片"><a href="#numpy数组的索引和切片" class="headerlink" title="numpy数组的索引和切片"></a>numpy数组的索引和切片</h4><h4 id="二维数组的访问方式"><a href="#二维数组的访问方式" class="headerlink" title="二维数组的访问方式"></a>二维数组的访问方式</h4><h4 id="花式索引Fancy-indexing"><a href="#花式索引Fancy-indexing" class="headerlink" title="花式索引Fancy indexing"></a>花式索引Fancy indexing</h4><p>利用整数数组进行索引</p><h4 id="T-transpose"><a href="#T-transpose" class="headerlink" title="T, transpose"></a>T, transpose</h4><p>数组转置，轴兑换</p><h4 id="条件逻辑转数组"><a href="#条件逻辑转数组" class="headerlink" title="条件逻辑转数组"></a>条件逻辑转数组</h4><p>np.where</p><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>sum mean std min max argmin argmax</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>sort</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>np.save np.load<br>numpy读取磁盘上的文本数据或者二进制数据<br>默认情况下会以未压缩的原始二进制格式保存在拓展名为.npy的文件中</p><h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p>dot 矩阵乘法<br>trace 计算对角线元素的和<br>det 计算矩阵的行列式<br>eig 计算矩阵特征值和特征向量<br>inv 计算矩阵的逆</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-高阶函数</title>
      <link href="/2020/03/04/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/04/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><p>func = lambda x: x + x</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><h4 id="python三大推导公式"><a href="#python三大推导公式" class="headerlink" title="python三大推导公式"></a>python三大推导公式</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-不用库函数计算立方根</title>
      <link href="/2020/03/03/%E7%AE%97%E6%B3%95-%E4%B8%8D%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E7%AB%8B%E6%96%B9%E6%A0%B9/"/>
      <url>/2020/03/03/%E7%AE%97%E6%B3%95-%E4%B8%8D%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E7%AB%8B%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算浮点型数字的立方根<br><a id="more"></a></p><p>最近遇到一道题，题目描述这样<br>不使用库函数，计算一个数字的立方根<br>麻烦的点是输入是double类型<br>假若规定输入的是整形，那很好做了，遍历计算就好，但是浮点型有点懵，遍历是不行了,因为每一步的跨度是不知道的。<br>有想过先算原来浮点型的精度位数，然后以精度为遍历，貌似可行。但是感觉有点硬，不够优雅.<br>最后上网查看一下比较正常的做法，恍然大雾，忘了泰勒级数了</p><p>求解 $ f(x) = x^3 = 0 $<br>令<br>$ f(x)  =  x^3 - a  = 0 $<br>利用泰勒展开，即f(x)在$x_0$处的函数值为<br>$ f(x) = f(x_0) + f \prime(x_0)(x - x_0) = x_0^3 - a + 3x_0^2(x - x_0) $<br>$ x = \frac{2x_0^2 - a}{3x_0^2} $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(x*x*x - n) &gt; <span class="number">1e-9</span>)</span><br><span class="line">        x = x - ((x*x*x - n) / (<span class="number">3</span>*x*x));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种方法是用二分法求解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TF2-线性模型实战</title>
      <link href="/2020/03/03/TF2-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2020/03/03/TF2-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 实战单输入神经元线性模型<br> <a id="more"></a><br> 线性模型</p><script type="math/tex; mode=display">y = 1.477 * x + 0.089</script><ol><li>采样数据<br>添加误差自变量 $ \epsilon $<script type="math/tex; mode=display">y = 1.477 * x + 0.089 + \epsilon , \epsilon ~ N(0, 0.0.01)</script></li></ol><p>通过循环进行100次，每次从区间[-10,10]的均匀分布U(0,1)中随机采样x<br>同时从N(0, 0.1^2)随机采样噪声 $ \epsilon $<br>得到y<br>保存到Numpy数组中，得到$ D^{train} $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    x = np.random.uniform(<span class="number">-10.</span>, <span class="number">10.</span>)</span><br><span class="line">    eps = np.random.normal(<span class="number">0.</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = <span class="number">1.477</span> * x + <span class="number">0.089</span> + eps</span><br><span class="line">    data.append([x, y])</span><br><span class="line">data = np.array(data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DL-深度学习简述</title>
      <link href="/2020/03/03/DL-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/03/DL-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习应用"><a href="#深度学习应用" class="headerlink" title="深度学习应用"></a>深度学习应用</h2><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><h4 id="图片识别-Image-Classification"><a href="#图片识别-Image-Classification" class="headerlink" title="图片识别 Image Classification"></a>图片识别 Image Classification</h4><p>  神经网络输入为图片数据,输出值为当前样本属于每个类别的概率<br>  VGG系列, Inception系列, ResNet系列</p><h4 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测 Object Detection"></a>目标检测 Object Detection</h4><p>  通过算法自动检测出图片汇中物体的大致位置,并分类出物体信息<br>  RCNN， Fast RCNN， Mask RCNN，SSD，YOLO系列</p><h4 id="语义分割-Semantic-Segmentation"><a href="#语义分割-Semantic-Segmentation" class="headerlink" title="语义分割 Semantic Segmentation"></a>语义分割 Semantic Segmentation</h4><p>  通过算法自动分割并识别图片中的内容，可以将语义分割理解成每个像素点的分类问题，分析每个像素点属于物体的类别<br>  FCN， U-net， SegNet， DeepLab</p><h4 id="视频理解-Video-Understanding"><a href="#视频理解-Video-Understanding" class="headerlink" title="视频理解 Video Understanding"></a>视频理解 Video Understanding</h4><p>  视频分类，行为检测，视频主体抽取<br>  C3D，TSN， DOVF， TS_LSTM</p><h4 id="图片生成-Image-Generation"><a href="#图片生成-Image-Generation" class="headerlink" title="图片生成 Image Generation"></a>图片生成 Image Generation</h4><p>  通过学习真实图片的分布，获得高逼真的生成图片<br>  VAE系列，GAN系列</p><h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><h4 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h4><p>  Seq2Seq，BERT，GPT， GPT-2</p><h4 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h4><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h4 id="虚拟游戏"><a href="#虚拟游戏" class="headerlink" title="虚拟游戏"></a>虚拟游戏</h4><h4 id="机器人-Roboitcs"><a href="#机器人-Roboitcs" class="headerlink" title="机器人 Roboitcs"></a>机器人 Roboitcs</h4><h4 id="自动驾驶-Autonomous-Driving"><a href="#自动驾驶-Autonomous-Driving" class="headerlink" title="自动驾驶 Autonomous Driving"></a>自动驾驶 Autonomous Driving</h4><h3 id="深度学习主流框架"><a href="#深度学习主流框架" class="headerlink" title="深度学习主流框架"></a>深度学习主流框架</h3><ul><li>TensorFlow<br>Google 推出 TensorFlow 2 正式版本，将以动态图优先模式运行，从而能够避免</li></ul><ul><li><p>PyTorch<br>是 Facebook 基于原有的 Torch 框架推出的采用 Python 作为主要开发语言的深度学习框架。采用命令式编程，使得搭建网络和 调试网络非常方便。</p></li><li><p>Keras<br>是一个基于 Theano 和 TensorFlow 等框架提供的底层运算而实现的高层框架， 提供了大量方便快速训练，测试的高层接口，对于常见应用来说，使用 Keras 开发效 率非常高。但是由于没有底层实现，需要对底层框架进行抽象，运行效率不高，灵活 性一般。</p></li><li><p>Torch<br>是一个非常优秀的科学计算库，基于较冷门的编程语言 Lua 开发。Torch 灵活性 较高，容易实现自定义网络层，这也是 PyTorch 继承获得的优良基因。但是由于 Lua 语言使用人群较小，Torch 一直未能获得主流应用。</p></li><li><p>Caffe<br>主要面向使用卷积神经网络的应用场合，并 不适合其他类型的神经网络的应用。Caffe 的主要开发语言是 C++，也提供 Python 语 言等接口，支持 GPU 和 CPU。<br>Caffe2 目前已经融入到 PyTorch 库中。</p></li><li><p>Scikit-learn<br>是一个完整的面向机器学习算法的计算库，内建了常见的传统机器学习算 法支持，文档和案例也较为丰富，但是 Scikit-learn 并不是专门面向神经网络而设计 的，不支持 GPU 加速，对神经网络相关层实现也较欠缺。</p></li><li><p>MXNET<br>由华人博士陈天奇和李沐等人开发，已经是亚马逊公司的官方深度学习框 架。采用了命令式编程和符号式编程混合方式，灵活性高，运行速度快，文档和案例 也较为丰富。</p></li><li><p>Theano<br>是最早的深度学习框架之一，由 Yoshua Bengio 和 Ian Goodfellow 等人开发， 是一个基于 Python 语言、定位底层运算的计算库，Theano 同时支持 GPU 和 CPU 运 算。由于 Theano 开发效率较低，模型编译时间较长，同时开发人员转投 TensorFlow 等原因，Theano 目前已经停止维护。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NLP-自然语言处理简述</title>
      <link href="/2020/03/03/NLP-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/03/NLP-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h4><h4 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h4>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CV-计算机视觉简述</title>
      <link href="/2020/03/03/CV-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/03/CV-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="图片识别-Image-Classification"><a href="#图片识别-Image-Classification" class="headerlink" title="图片识别 Image Classification"></a>图片识别 Image Classification</h4><p>  神经网络输入为图片数据,输出值为当前样本属于每个类别的概率<br>  VGG系列, Inception系列, ResNet系列</p><h4 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测 Object Detection"></a>目标检测 Object Detection</h4><p>  通过算法自动检测出图片汇中物体的大致位置,并分类出物体信息<br>  RCNN， Fast RCNN， Mask RCNN，SSD，YOLO系列</p><h4 id="语义分割-Semantic-Segmentation"><a href="#语义分割-Semantic-Segmentation" class="headerlink" title="语义分割 Semantic Segmentation"></a>语义分割 Semantic Segmentation</h4><p>  通过算法自动分割并识别图片中的内容，可以将语义分割理解成每个像素点的分类问题，分析每个像素点属于物体的类别<br>  FCN， U-net， SegNet， DeepLab</p><h4 id="视频理解-Video-Understanding"><a href="#视频理解-Video-Understanding" class="headerlink" title="视频理解 Video Understanding"></a>视频理解 Video Understanding</h4><p>  视频分类，行为检测，视频主体抽取<br>  C3D，TSN， DOVF， TS_LSTM</p><h4 id="图片生成-Image-Generation"><a href="#图片生成-Image-Generation" class="headerlink" title="图片生成 Image Generation"></a>图片生成 Image Generation</h4><p>  通过学习真实图片的分布，获得高逼真的生成图片<br>  VAE系列，GAN系列</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>self-个人技术栈</title>
      <link href="/2020/03/03/self-%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2020/03/03/self-%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语言类:<br> C++, Python, Java, Matlab, Js, C#, Delphi, VB, Swif</p><p>框架类:<br>  前端:<br>    React, Redux<br>  后端:<br>    Django, Spring MVC</p><p>服务器:<br>  Tomcat, Nginx, uWSGI</p><p>机器学习框架:<br>  TF2, pytorch, paddle paddle</p><p>数据库：<br>  Mysql, Sql server, Postsql, DBF</p><p>应用开发：<br>  微信小程序，智能卡片内系统开发, Windows服务</p><p>文档类：<br>  Latex, MarkDown</p><p>工具:<br>  Ubuntu, Docker</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ML-机器学习简述</title>
      <link href="/2020/03/03/ML-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/"/>
      <url>/2020/03/03/ML-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过历史数据学习到一个模型，通过模型预测未来<br>f: x-&gt;y</p><h4 id="机器学习分类："><a href="#机器学习分类：" class="headerlink" title="机器学习分类："></a>机器学习分类：</h4><ul><li><p>有监督学习:<br>有监督学习的数据集包含了样本x与样本的标签y，算法学习需要学习到映射 $ f_{\theta}: x \rightarrow y$,其中 $ f_{\theta} $代表模型函数 $ \theta $为模型参数。在训练时, 通过计算模型的预测值$ f_{\theta}(x) $ 与真实标签 $ y $之间的误差来优化网络参数$ \theta $, 使得网络的下一次预测更精准。如线性回归, 逻辑回归, 支持向量机, 随机森林</p></li><li><p>无监督学习:<br>只有样本$x$的数据集, 算法本身需要自行发现数据的模态。如自编码器，生成对抗网络</p></li><li><p>强化学习: 通过与环境进行交互来学习解决问题的策略。强化学习并没有明确的”正确的”动作监督信号,算法需要与环境进行交互,获取环境反馈的滞后的奖励。如DQN, PPO</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程线程详解</title>
      <link href="/2020/03/03/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/03/03/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。<br>11.操作系统的设计，因此可以归结为三点：</p><p>以多进程形式，允许多个任务同时运行；</p><p>以多线程形式，允许单个任务分成不同的部分运行；</p><p>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p><p>这个类比可以很形象的说明进程与线程的区别。<br>当然面试的时候你不可能说上这一堆，面试官估计要跟你急，时间宝贵，我们需要用最精简的语言说出两者的概念以及区别。<br>你可以这样分点回答（面试时需要逻辑条理清晰、语言简洁、直中要害）：<br>（1）进程<br>进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。<br>（2）线程<br>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>（3）联系<br>线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（4）区别：理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）<br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位<br>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）<br>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。<br>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>扩展阅读<br>为什么需要设计线程？<br>在传统进程模型中，进程的内涵可分为下面两个方面：<br>调度、执行的基本单位：每个进程都有自己的运行状态、优先级、寄存器等，是OS调度的基本单位。<br>资源所有权：包括程序、数据、文件等资源。一个进程拥有对这些资源的所有权，OS则提供保护功能，避免不同进程之间的资源冲突。<br>既然是两个独立的功能，可不可以把它们分离呢？这就出现了线程（thread）的概念：<br>执行与调度的基本单位：thread<br>资源所有权：process<br>那么执行与调度的基本单位是线程，这样设置有什么好处？<br>计算机操作系统里面有两个重要概念：并发和隔离。<br>并发是为了尽量让硬件利用率高，线程是为了在系统层面做到并发。线程上下文切换效率比进程上下文切换会高很多，这样可以提高并发效率。<br>隔离也是并发之后要解决的重要问题，计算机的资源一般是共享的，隔离要能保障崩溃了这些资源能够被回收，不影响其他代码的使用。所以说一个操作系统只有线程没有进程也是可以的，只是这样的系统会经常崩溃而已，操作系统刚开始发展的时候和这种情形很像。<br>所以：线程和并发有关系，进程和隔离有关系。线程基本是为了代码并发执行引入的概念，因为要分配cpu时间片，暂停后再恢复要能够继续和没暂停一样继续执行；进程相当于一堆线程加上线程执行过程中申请的资源，一旦挂了，这些资源都要能回收，不影响其他程序。</p><p>作者：风平浪静如码<br>链接：<a href="https://juejin.im/post/5e5cb893f265da570d736388" target="_blank" rel="noopener">https://juejin.im/post/5e5cb893f265da570d736388</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ML-误差函数</title>
      <link href="/2020/03/02/ML-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/02/ML-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数（loss function）是用来估量模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。</p><h4 id="损失函数分类"><a href="#损失函数分类" class="headerlink" title="损失函数分类"></a>损失函数分类</h4><p>损失函数一般分为分类和回归两类<br>回归会预测给出一个数值结果而分类则会给出一个标签。<br><img src="%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="损失函数分类"></p><h4 id="常用回归损失函数"><a href="#常用回归损失函数" class="headerlink" title="常用回归损失函数"></a>常用回归损失函数</h4><ol><li><p>均方误差MSE, 平方损失 – L2损失<br>是回归损失函数中最常用的误差，它是预测值与目标值之间差值的平方和<br>公式: $ MSE = \frac{\sum_{i=1}^{n}(y_i-y_i^p)^2}{n} $<br>特点: 平方损失函数是光滑的，可以用梯度下降法求解，但是，当预测值和真实值差异较大时，它的惩罚力度较大，因此对异常点较为敏感。</p></li><li><p>平均绝对误差 – L1损失<br>常用的回归损失函数，它是目标值与预测值之差绝对值的和，表示了预测值的平均误差幅度，而不需要考虑误差的方向<br>公式: $ MAE = \frac{|y_i - y_i^p|}{n} $<br>特点: 绝对损失函数对异常点不那么敏感，其鲁棒性比平方损失更强一些，但是它在f = y 处不可导.</p></li><li><p>Huber损失 – 平滑平均绝对误差<br>相比于平方损失来说对于异常值不敏感，但它同样保持了可微的特性。它基于绝对误差但在误差很小的时候变成了平方误差。<br>公式: <img src="Huber.png" alt="Huber"><br>特点: Huber损失函数在 ∣f−y∣较小时为平方损失，在较大时为线性损失，且处处可导，对异常点鲁棒性较好</p></li><li><p>log-cosh损失函数<br>公式: $ L(f,y) = \log(cosh(f-y)) $ $ cosh(x) = (e^x + e^{-x})/2 $<br>特点: log-cosh损失函数比均方损失函数更加光滑，具有huber损失函数的所有优点，且二阶可导。因此可以使用牛顿法来优化计算，但是在误差很大情况下，一阶梯度和Hessian会变成定值，导致牛顿法失效。</p></li><li><p>分位数损失函数<br>公式: $ L(f,y) = \sum_{y_i&lt;f_i}(1-\gamma)|y_i - f_i| + \sum_{y_i \beq f_i} \gamma|y_i - f_i| $<br>特点: 预测的是目标的取值范围而不是值, $ \gamma $是所需的分位数,其值介于0-1之间</p></li></ol><h4 id="常用分类损失函数"><a href="#常用分类损失函数" class="headerlink" title="常用分类损失函数"></a>常用分类损失函数</h4><ol><li><p>0-1损失函数<br>预测值和目标值不相等为1，否则为0<br>公式: <img src="01%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="0-1损失函数"><br>特点: 0-1损失函数可以直观的刻画分类的错误率，但是因为其非凸，非光滑的特点，使得算法很难对其进行直接优化</p></li><li><p>Hinge损失函数(SVM)<br>公式: $ L(f,y) = max(0, 1 - fy) $<br>特点: Hinge损失函数是0-1损失函数的一个代理损失函数，也是其紧上界，当 fy≥0,fy≥0 时，不对模型做惩罚。因为在fy = 1处不可导, 因此不能用梯度下降算法对其优化,只能用次梯度下降法</p></li><li><p>对数损失函数（logarithmic loss）LR<br>样本预测值和实际值的误差符合高斯分布，使用极大似然估计的方法，取对数得到损失函数<br>经典的对数损失函数包括entropy和softmax，一般在做分类问题的时候使用<br>公式: $ L(Y, P(Y|X)) = -\logP(Y|X) $<br>特点:Logistic损失函数是0-1损失函数的另一个代理损失函数，它也是0-1损失函数的凸上界，且该函数处处光滑。但是该损失函数对所有样本点都惩罚，因此对异常值更加敏感</p></li><li><p>交叉商损失函数Cross-Entropy<br>公式: $ L(f,y) = -log_2(\frac{1+fy}{2}) $<br>特点: 交叉熵损失函数也是0-1损失函数的光滑凸上界</p></li><li><p>指数损失函数(AdaBoost)<br>公式: $ L(f,y) = e^{-fy}$<br>特点: 指数损失函数是AdaBoost里使用的损失函数，同样地，它对异常点较为敏感，鲁棒性不够</p></li></ol><h4 id="损失函数的选择"><a href="#损失函数的选择" class="headerlink" title="损失函数的选择"></a>损失函数的选择</h4><p>损失函数的选取依赖于参数的数量、异常值、机器学习算法、梯度下降的效率、导数求取的难易和预测的置信度等若干方面。</p><p>tf.keras.losses.BinaryCrossentropy(from_logits = True)<br>其中，当模型最后一层没有经过激活函数时from_logits设置为True，否则为False。<br>因为logits表示网络的直接输出 。如果网络输出的结果经过了sigmoid或者softmax的概率化，那么from_logits=False就表示把已经概率化了的输出，重新映射回原值。如果网络输出的结果没经过概率化，则from_logits=True，表示不进行任何操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ML-激活函数</title>
      <link href="/2020/03/02/ML-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2020/03/02/ML-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="激活函数的概念"><a href="#激活函数的概念" class="headerlink" title="激活函数的概念"></a>激活函数的概念</h4><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。</p><h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><p>不使用激活函数的话，神经网络的每层都只是做线性变换，多层输入叠加后也还是线性变换。因为线性模型的表达能力通常不够，所以这时候就体现了激活函数的作用了，激活函数可以引入非线性因素。</p><h4 id="激活函数分类"><a href="#激活函数分类" class="headerlink" title="激活函数分类"></a>激活函数分类</h4><p>  饱和激活函数和非饱和激活函数<br>  <img src="%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB.png" alt="激活函数分类"></p><h4 id="饱和定义"><a href="#饱和定义" class="headerlink" title="饱和定义"></a>饱和定义</h4><p>假设 $ h(x) $ 是一个激活函数</p><ol><li>若 $ \lim_{n\rightarrow+\infty} h^{\prime}(x) =  0 $ 称为右饱和</li><li>若 $ \lim_{n\rightarrow-\infty} h^{\prime}(x) =  0 $ 称为左饱和</li><li>当一个函数既满足左饱和又满足右饱称之为饱和函数</li></ol><h4 id="饱和激活函数-Saturated"><a href="#饱和激活函数-Saturated" class="headerlink" title="饱和激活函数(Saturated)"></a>饱和激活函数(Saturated)</h4><p>  Sigmoid和tanh是饱和激活函数</p><h4 id="非饱和激活函数-Non-Saturated"><a href="#非饱和激活函数-Non-Saturated" class="headerlink" title="非饱和激活函数(Non-Saturated)"></a>非饱和激活函数(Non-Saturated)</h4><p>  ReLU(修正线性单元)及其变体则是“非饱和激活函数</p><h4 id="非饱和激活函数优势"><a href="#非饱和激活函数优势" class="headerlink" title="非饱和激活函数优势"></a>非饱和激活函数优势</h4><ol><li>能解决所谓的“梯度消失”问题。</li><li>它能加快收敛速度。</li></ol><h4 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h4><ol><li><p>Sigmoid<br>公式为: $ f(x) = \frac{1}{1 + e^{-x}} $<br>函数图像: <img src="Sigmoid%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Sigmoid"><br>导函数图像: <img src="Sigmoid%E5%AF%BC%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Sigmoid导函数"><br>特点:</p><ol><li>sigmoid函数饱和使梯度消失。我们从导函数图像中可以看出sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋近于0。这样，几乎就没有梯度信号通过神经元传递到前面层的梯度更新中，因此这时前面层的权值几乎没有更新，这就叫梯度消失。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</li><li>sigmoid函数输出不是“零为中心”(zero-centered)。一个多层的sigmoid神经网络，如果你的输入x都是正数，那么在反向传播中w的梯度传播到网络的某一处时，权值的变化是要么全正要么全负。</li><li>指数函数的计算是比较消耗计算资源的.</li></ol></li><li><p>tanh<br>tanh函数跟sigmoid还是很像的，实际上，tanh是sigmoid的变形,</p><p>公式为: $ tanh(x) = \frac{1-e^{-2x}}{1+e^{-2x}} = 2sigmoid(2x)-1$<br>函数图像: <img src="tanh%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="tanh函数图像"><br>优点:</p><ol><li>tanh解决了sigmoid的输出非“零为中心”的问题<br>缺点：</li><li>依然有sigmoid函数过饱和的问题</li><li>指数函数的计算是比较消耗计算资源的.</li></ol></li><li><p>ReLU修正线性单元<br>公式为: $ f(x) = max(0, x) $<br>函数图像: <img src="ReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Relu"><br>优点:</p><ol><li>ReLU解决了梯度消失的问题，至少x在正区间内，神经元不会饱和</li><li>由于ReLU线性、非饱和的形式，在SGD中能够快速收敛</li><li>算速度要快很多。ReLU函数只有线性关系，不需要指数计算，不管在前向传播还是反向传播，计算速度都比sigmoid和tanh快<br>缺点：</li><li>ReLU的输出不是“零为中心”</li><li>随着训练的进行，可能会出现神经元死亡，权重无法更新的情况。这种神经元的死亡是不可逆转的死亡</li></ol></li><li><p>Leaky ReLU<br>Leaky ReLU是给所有负值赋予一个非零的斜率。<br>公式为: <img src="LeakyReLU.png" alt="Leaky ReLU"><br>函数图像: <img src="LeakyReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Leaky ReLU"></p><p>优点:</p><ol><li>神经元不会出现死亡</li><li>神经元不会饱和</li><li>在SGD收敛很快</li><li>计算速度快<br>缺点:</li><li>参数 $ \alpha $ 需要先验知识,人工赋值</li></ol></li><li><p>RReLU 随机修正线性单元</p><p>公式为: <img src="RReLU.png" alt="RReLU"><br>函数图像: <img src="RReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="RReLU函数图像"><br>特点:</p><ol><li>在训练过程中，α是从一个高斯分布中随机出来的值，然后再在测试过程中进行修正。在测试阶段，把训练过程中所有的取个平均值。</li><li>数学形式与PReLU类似，但RReLU是一种非确定性激活函数，其参数是随机的</li></ol></li><li><p>ELU 指数线性单元<br>它试图将激活函数的输出平均值接近零，从而加快学习速度。同时，它还能通过正值的标识来避免梯度消失的问题。<br>公式为: <img src="ELU.png" alt="ELU"><br>函数图像为: <img src="ELU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="ELU函数图像"></p><p>优点：</p><ol><li>ELU包含了ReLU的所有优点。</li><li>神经元不会出现死亡的情况。</li><li>ELU激活函数的输出均值是接近于零的。<br>缺点:</li><li>指数计算效率低</li></ol></li></ol><h4 id="如何选择激活函数"><a href="#如何选择激活函数" class="headerlink" title="如何选择激活函数"></a>如何选择激活函数</h4><p>  在实践过程中更多还是需要结合实际情况，考虑不同激活函数的优缺点综合使用。</p><ol><li>通常来说，不能把各种激活函数串起来在一个网络中使用。</li><li>如果使用ReLU，那么一定要小心设置学习率(learning rate),并且要注意不要让网络中出现很多死亡神经元。如果死亡神经元过多的问题不好解决，可以试试Leaky ReLU、PReLU、或者Maxout。</li><li>尽量不要使用sigmoid激活函数，可以试试tanh，不过感觉tanh的效果会比不上ReLU和Maxout。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tf-BatchNormalization</title>
      <link href="/2020/03/02/tf2-BatchNormalization/"/>
      <url>/2020/03/02/tf2-BatchNormalization/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>keras.layers.normalization.BatchNormalization()</p><p>该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1</p><p>BN层的作用<br> (1)加速收敛<br>（2）控制过拟合，可以少用或不用Dropout和正则<br>（3）降低网络对初始化权重不敏感<br>（4）允许使用较大的学习率</p><p>机器学习领域有个很重要的假设：IID独立同分布假设，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</p><p>BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓白化，就是对输入数据分布变换到0均值，单位方差的正态分布——那么神经网络会较快收敛，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tf2-tensorflow2学习之路</title>
      <link href="/2020/03/02/tf2-tensorflow2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/03/02/tf2-tensorflow2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TF2三大功能</p><ol><li>加速计算</li><li>自动梯度</li><li>常用神经网络接口</li></ol><p>[tf.keras 内置数据集] (<a href="https://keras.io/zh/datasets/" target="_blank" rel="noopener">https://keras.io/zh/datasets/</a>)</p><h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><ol><li>keras和tf.keras</li></ol><h4 id="常用API说明"><a href="#常用API说明" class="headerlink" title="常用API说明"></a>常用API说明</h4><ol><li>tf.data.Dataset.from_tensor_slices</li><li>keras.layers.normalization.BatchNormalization</li><li>tf.ones_like 和 tf.zeros_like</li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul><li>线性模型实战</li></ul><ol><li>fashion-mnist分类实战</li><li>GAN手写数字生成实战</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NLP学习之路</title>
      <link href="/2020/03/02/AI-NLP%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/03/02/AI-NLP%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NLP = NLU + NLG</p><ul><li>NLU: 语音/文本 -&gt; 意思</li><li>NLG: 意思-&gt; 文本</li></ul><p>机器翻译系统实现</p><p>Decoding Algarithm<br> Viterb</p><p>NLP 应用案例</p><ul><li>Question Answering问答系统（IBM）</li><li>Sentiment Analysis情感分析</li><li>Machine Translation 机器翻译</li><li>Text Summarization 自动摘要</li><li>Chatbot 聊天机器人</li><li>Information Extraction 信息抽取</li></ul><p>自然语言处理技术的四个维度</p><ul><li>Semantic 语义</li><li>Syntax 句子结构</li><li>Morphology 单词 NER 命名实体识别</li><li>Phonetics 声音</li></ul><p>NLP关键技术</p><ul><li>Word Segmentation （分词）</li><li>Part-of-Speech 词性</li><li>Named Entity Recognition 命名实体识别</li><li>Dependency Parsing 依存分析</li><li>Relation Extraction 关系抽取</li></ul><p>文本处理过程</p><p>原始文本 -&gt; 分词(Segmentation) -&gt; 清洗(Cleaning)(无用的标签， 特殊符号，停用词，大小写转换) -&gt; 标准化(Normalization) -&gt; 特征提取 -&gt; 建模 -&gt; 评估</p><ol><li>Word Segmentation</li><li>Spell Correction</li><li>Filtering Words Stop Words Removal</li><li>Stemming</li></ol><p>Word Segmentation Tools</p><ul><li>Jieba分词</li><li>SnowNLP</li><li>LTP</li><li>HanNLP</li></ul><p>分词工具实现：</p><ul><li>基于匹配规则的方法<br>最大匹配(Max Matching) 前向最大匹配(forward-max matching) 后向最大匹配(backward-max matching)</li><li>基于概率统计的方法<br>Incorporate Semantic(考虑语义)<br>language model 维特比算法<br>LM，HMM，CRF</li></ul><p>Spell Correction(拼写错误纠正)<br>  计算编辑距离 insert delete replace</p><p>Flitering Words<br>  把停用词和出现频率低的词过滤</p><p>Stemming/lemmatization 相同含义单词合并<br>    Porter Stemmer 算法</p><p>文本表示 Word Representation<br>  词表示   one-hot representation<br>  句子表示 Boolean representation<br>          Count-based representation<br>          tfidf(w) = tf(d, w) * idf(w)<br>              tf(d,w)表示文档d中w的词频<br>              idf(w)考虑单词的重要性 logN/N(w) N语料库中的文档总数 N(w)词语w出现在多少个文档<br>句子相似度 Sentence Similarity<br>  欧式距离: d = |s1 - s2|<br>  余弦相似度: d = (s1 * s2)/(|s1| * |s2|)</p><p>one-hot representation 缺点<br>  没办法表示单词间语义的相似度<br>  Sparsity 稀疏性</p><p>分布式表示法 Distributed Representation<br>  词向量(word vectors)</p><p>词向量表达句子向量</p><ol><li>平均法则</li><li>LSTM/RNN</li></ol><p>训练词向量的常用模型<br>  Skip-Gram<br>  G-lone<br>  CBow<br>  RNN/LSTM<br>  MF</p><p>Noisy Channel Model<br>  p(text|source) 等比 p(source|text)p(text)<br>  应用场景<br>    语音识别  P(文本｜语音信号) 等比 P(语音信号｜文本) * P(文本)<br>    机器翻译 P（中文｜英文） 等比 P(英文｜中文) * P(中文)<br>    拼写纠错  P(正确写法｜错误写法) 等比 P（错误写法｜正确写法） * P(正确写法)<br>    OCR<br>    密码破译  P(明文｜暗文) 等比 P(暗文｜明文) * P(明文)</p><p>语言模型 Language Model<br>  作用：是否一句话从语法上是通顺的</p><p>  Chain Rule<br>    p(w1,w2, w3,w4,w5,…wn) = p(w1) * p(w2|w1) * p(w3|w1w2)….p(wn|w1w2…wn_1)</p><p>  Markov Assumption 马尔可夫假设 解决稀疏问题<br>    1st order ｜ 2st order ｜ 3rd order</p><p>语言模型分类：<br>  Unigram： 每个单词是独立个体，相互独立 P(w1, w2, w3, w4 … wn) = p(w1) * p(w2) * p(w3) … p(wn)<br>  Bigran: 1st order Markov Assumption P(w1, w2, w3, w4 … wn) = p(w1) * p(w2|w1) * p(w3|w2) … p(wn|wn_1)<br>  N-gram:</p><p>  使用Estimating Probability 计算每个单词的概率，但是会出现概率0项，可做平滑</p><p>如何评估语言模型<br>  $ Perplexity = 2^{-(x)} $</p><p>处理未出现在字典中的词</p><ol><li>Add-one Smoothing (Laplace Smoothing)<br> $ P_{ADD-1}(w_i|w_{i-1}) = \frac{c(w_{i-1}, w_i) + 1}{c(w_i) + V} $</li><li>Add-k Smoothing<br> $ P_{ADD-1}(w_i|w_{i-1}) = \frac{c(w_{i-1}, w_i) + k}{c(w_i) + kV} $<br> 如何选择k<ol><li>k = 1，2，3尝试</li><li>优化 f(k) 使用Preplexity优化</li></ol></li><li>Interpolation<br>   $p(w_n|w_{n-1}, w_{n-1}) = \lambda_1 p(w_n| w_{n-1}, w_{n-2}) + \lambda_2 p(w_n| w_{n-1} + \lambda_3 p(w_n)$<br>   $ \lambda_1 + \lambda_2 + \lambda_3  = 1$</li><li>Good-Turning Smoothing<br>   缺点：</li></ol><p>语言模型</p><p>pandas</p><p>贪心算法 每次选择当前最好的 局部最优<br>DP 全局最优</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tf2-学习记录</title>
      <link href="/2020/03/01/tf2-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/03/01/tf2-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[tf.keras 内置数据集] (<a href="https://keras.io/zh/datasets/" target="_blank" rel="noopener">https://keras.io/zh/datasets/</a>)</p><p>tf.data.Dataset.from_tensor_slices (<a href="https://blog.csdn.net/Dr_jiabin/article/details/93366661" target="_blank" rel="noopener">https://blog.csdn.net/Dr_jiabin/article/details/93366661</a>)</p><p>keras.layers.BatchNormalization()</p><p>keras.layers.LeakyReLU()</p><p>from_logits</p><p>tf.keras.losses.BinaryCrossentropy(from_logits = True)</p><p>tf.one_like</p><p>tf.zeros_like</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tf2-from_tensor-slices说明</title>
      <link href="/2020/03/01/tf2-from-tensor-slices%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/03/01/tf2-from-tensor-slices%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="tf-data-Dataset-from-tensor-slices"><a href="#tf-data-Dataset-from-tensor-slices" class="headerlink" title="tf.data.Dataset.from_tensor_slices"></a>tf.data.Dataset.from_tensor_slices</h4><h4 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h4><p>  一个元组、列表和张量</p><h4 id="出参"><a href="#出参" class="headerlink" title="出参"></a>出参</h4><p>  得到数据集,类型为TensorSliceDataset</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>是把给定的元组、列表和张量等数据进行特征切片。切片的范围是从最外层维度开始的。如果有多个特征进行组合，那么一次切片是把每个组合的最外维度的数据切开，分成一组一组的。</p><p>假设我们现在有两组数据，分别是特征和标签，我们假设每两个特征对应一个标签。之后把特征和标签组合成一个tuple，那么我们的想法是让每个标签都恰好对应2个特征，而且像直接切片，比如：[f11, f12] [t1]。f11表示第一个数据的第一个特征，f12表示第1个数据的第二个特征，t1表示第一个数据标签。那么tf.data.Dataset.from_tensor_slices就是做了这件事情：</p><figure class="highlight python"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">features, labels = (np.random.sample((<span class="number">6</span>, <span class="number">3</span>)),  <span class="comment"># 模拟6组数据，每组数据3个特征</span></span><br><span class="line">                    np.random.sample((<span class="number">6</span>, <span class="number">1</span>)))  <span class="comment"># 模拟6组数据，每组数据对应一个标签，注意两者的维数必须匹配</span></span><br><span class="line"></span><br><span class="line">print((features, labels))  <span class="comment">#  输出下组合的数据</span></span><br><span class="line">data = tf.data.Dataset.from_tensor_slices((features, labels))</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tf2-GAN</title>
      <link href="/2020/03/01/tf2-GAN%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E7%94%9F%E6%88%90%E5%AE%9E%E6%88%98/"/>
      <url>/2020/03/01/tf2-GAN%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E7%94%9F%E6%88%90%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="实战使用keras的mnist数据集-使用GAN生成手写数据图片"><a href="#实战使用keras的mnist数据集-使用GAN生成手写数据图片" class="headerlink" title="实战使用keras的mnist数据集,使用GAN生成手写数据图片"></a>实战使用keras的mnist数据集,使用GAN生成手写数据图片</h4><p>使用生成器模型生成手写图片<br>使用判别器模型对真图片进行真判断对生成的图片进行假判断</p><h4 id="定义生成器模型"><a href="#定义生成器模型" class="headerlink" title="定义生成器模型"></a>定义生成器模型</h4><p>生成器用来将随机数生成手写数据图片<br>生成器使用三层结构<br>输入层和中间层使用BatchNormalization进行标准化,使用LeakyReLU进行激活<br>输出层使用tanh激活<br>最后将输出数据改为28 * 28 * 1 的形状</p><figure class="highlight plain"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def generator_model():</span><br><span class="line">    model &#x3D; tf.keras.Sequential()</span><br><span class="line">    model.add(keras.layers.Dense(256, input_shape &#x3D; (100,), use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(512, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(28 * 28 * 1, use_bias &#x3D; False, activation &#x3D; &#39;tanh&#39;))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Reshape((28, 28, 1)))</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure><h4 id="定义判别器模型"><a href="#定义判别器模型" class="headerlink" title="定义判别器模型"></a>定义判别器模型</h4><p>判别器用来对输入图片进行判别<br>判别器使用三层网络结构<br>第一层将图片数据延展并输入到一个全连接层，使用BatchNormalization标准化，使用LeakyReLU激活<br>第二层是个全连接层，同样使用使用BatchNormalization标准化，使用LeakyReLU激活<br>第三层输出判别的结果</p><figure class="highlight plain"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def discriminator_model():</span><br><span class="line">    model &#x3D; keras.Sequential()</span><br><span class="line">    model.add(keras.layers.Flatten())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(512, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(256, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(1))</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure><h3 id="GAN-生成对抗网络"><a href="#GAN-生成对抗网络" class="headerlink" title="GAN 生成对抗网络"></a>GAN 生成对抗网络</h3><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><pre><code>* 图像生成* 图像增强* 风格化* 艺术的图像创作</code></pre><h3 id="GAN定义"><a href="#GAN定义" class="headerlink" title="GAN定义"></a>GAN定义</h3><p>GAN 包含两部分生成器generator与判别器discriminator,<br>    * 生成器主要用来学习真实图像分布从而让自身生成的图像更加真实，以骗过判别器<br>    * 判别器对接收的图片进行真假判断</p><h3 id="GAN-设计"><a href="#GAN-设计" class="headerlink" title="GAN 设计"></a>GAN 设计</h3><ul><li><p>生成器网络</p></li><li><p>判别器网络（例如 5层CNN)</p></li></ul><p>自编码器<br>基本去燥自编ma<br>卷积去燥自编码器</p><p>GAN自定义</p>]]></content>
      
      
      <categories>
          
          <category> TF2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>音-Supermarket-Flowers</title>
      <link href="/2020/02/27/%E9%9F%B3-Supermarket-Flowers/"/>
      <url>/2020/02/27/%E9%9F%B3-Supermarket-Flowers/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I hope that I can see the world as you did cause I know<br>A life with love is a life that’s been lived<br><a id="more"></a></p><p>第一次听这首歌是某在中午扇贝新闻推荐的视频,第一次听没感觉什么，演唱者也不好看，然而听完第一次莫名想回味。然后就一发不可收拾。<br>当时也恰逢世界杯，坐地铁去LB那看球赛，很欢乐的一段时间，然而现在都过去了，再听这首歌有种伤感。然后在网易云音乐买了它</p><p>I took the supermarket flowers from the windowsill<br>I threw the day old tea from the cup<br>Packed up the photo album Matthew had made<br>Memories of a life that’s been loved</p><p>Took the get well soon cards ans stuffed animals<br>Poured the old ginger beer down the sink<br>Dad always told me,”Don’t you cry when you’re down”<br>But mum, there’s a tear every time that I blink</p><p>Oh I’m in pieces, it’s tearing me up, but I know<br>A heart that’s broke is a heart that’s been loved<br>So I’ll sing Hallelujah<br>You were an angle in the shape of my mun<br>When I fell down you’d be here holding me up<br>Spread your wings as you go</p><p>And when God takes you back<br>We’ll say Hallelujah<br>You’re home</p><p>I fluffed the pillows,made the beds, stacked the chairs up<br>Folded your nightgowns neatly in a case<br>John says he’d drive then put his hand on my cheek<br>And wiped a tear from the side of my face</p><p>I hope that I can see the world as you did cause I know<br>A life with love is a life that’s been lived</p>]]></content>
      
      
      <categories>
          
          <category> 音 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB-Mysql数据库写提速</title>
      <link href="/2020/02/27/DB-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99%E6%8F%90%E9%80%9F/"/>
      <url>/2020/02/27/DB-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99%E6%8F%90%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>将数据页从磁盘读入内存中涉及随机IO访问，这也是数据库里面成本最高的操作之一，而利用写缓存(Change Buffer)可以减少IO操作,从而提升数据库性能。<br><a id="more"></a></p><h3 id="总结-写缓存就是将所要修改的数据暂存在一个缓存区，在恰当的时候再写入磁盘，减少IO操作"><a href="#总结-写缓存就是将所要修改的数据暂存在一个缓存区，在恰当的时候再写入磁盘，减少IO操作" class="headerlink" title="总结: 写缓存就是将所要修改的数据暂存在一个缓存区，在恰当的时候再写入磁盘，减少IO操作"></a>总结: 写缓存就是将所要修改的数据暂存在一个缓存区，在恰当的时候再写入磁盘，减少IO操作</h3><h4 id="写缓存简介"><a href="#写缓存简介" class="headerlink" title="写缓存简介"></a>写缓存简介</h4><p>写缓存(Change Buffer)是一种特殊的数据结构，用于在对数据变更时，如果数据所在的数据页没有在Buffer pool中的话，在不影响数据一致性的前提下，InnoDB引擎会将对数据的操作缓存在Change Buffer中,这样就省去了从磁盘中读入这个数据页。</p><h4 id="InnoDB架构图"><a href="#InnoDB架构图" class="headerlink" title="InnoDB架构图"></a>InnoDB架构图</h4><p>关于MySQL写缓存（Change Buffer),先来看看 InnoDB 的技术架构图：<br><img src="InnoDB架构图.jpg" alt="InnoDB架构图"></p><h4 id="写缓存出发"><a href="#写缓存出发" class="headerlink" title="写缓存出发"></a>写缓存出发</h4><p>Change Buffer是Buffer Pool中的一部分，虽然Change Buffer名字叫 Buffer，但是它也是可以持久化的，在右边的System Tablespace中可以看到持久化Change Buffer的空间。触发写缓存（Change Buffer）持久化操作有以下几种情况:</p><ol><li>数据库空闲时，后台有线程定时持久化</li><li>数据库缓冲池不够用时</li><li>数据库正常关闭时</li><li>redo log 写满时</li></ol><h4 id="Change-Buffer-的架构图"><a href="#Change-Buffer-的架构图" class="headerlink" title="Change Buffer 的架构图"></a>Change Buffer 的架构图</h4><p><img src="BufferPool架构图.jpg" alt="BufferPool架构图"><br>从图中看出修改的二级页面不在缓冲池的话，会将更新缓存到Change buffer</p><h4 id="merge数据"><a href="#merge数据" class="headerlink" title="merge数据"></a>merge数据</h4><p>图中详细的描述了 Change Buffer 的功能，Change Buffer中的数据最终还是会刷回到数据所在的原始数据页中，Change Buffer数据应用到原始数据页，得到新的数据页的过程称之为merge。merge过程中只会将Change Buffer中与原始数据页有关的数据应用到原始数据页，以下三种情况会发生merge 操作：</p><ol><li>原始数据页加载到Buffer Pool时。</li><li>系统后台定时触发 merge 操作。</li><li>MySQL 数据库正常关闭时。</li></ol><h4 id="Change-Buffer的相关设置"><a href="#Change-Buffer的相关设置" class="headerlink" title="Change Buffer的相关设置"></a>Change Buffer的相关设置</h4><p>上面就是写缓存（Change Buffer）的相关知识，写缓存（Change Buffer）我们也是可以使用命令参数来控制，MySQL 数据库提供了两个对写缓存（Change Buffer）的参数。</p><ol><li>innodb_change_buffer_max_size<br>innodb_change_buffer_max_size 表示 Change Buffer 最大大小占 Buffer Pool 的百分比，默认为 25%。最大可以设置为 50%。</li><li>innodb_change_buffering<br>innodb_change_buffering 参数用来控制对哪些操作启用 Change Buffer 功能，默认是：all。</li></ol><h4 id="写缓存应用实例"><a href="#写缓存应用实例" class="headerlink" title="写缓存应用实例"></a>写缓存应用实例</h4><p>我们就用一个案例来说明一下 Change Buffer ，首先我们向数据库中插入两条数据：<br>‘’’ MySQL<br>mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);<br>‘’’</p><p>结合下面这张图来分析这两条插入语句<br><img src="insert_value.png" alt="插入数据过程"></p><p>假设当前是 K索引树的状态，K1 所在的数据页 page1 在 Buffer Pool 中，k2 所在的数据页不在 Buffer Pool 中，来看看这两条语句的执行流程：</p><ol><li>对于 k1 这条数据，Page 1 在内存中，所以直接更新内存，不会使用到 Change Buffer；</li><li>k2 对应的数据页 Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息，这个地方及其关键，并没有从磁盘中将 page2 加载到内存。</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li><li>后台线程会定时将 page1 和 Change Buffer 中的数据持久化</li></ol><p>主要地方在于步骤二，这就是写缓存（Change Buffer）提高性能的地方，虽然 page2 并没有在内存中，但是并没有妨碍我们往数据库 page2 中插入数据，这就是写缓存（Change Buffer）的巧妙之处，也是写缓存（Change Buffer）提高 MySQL的地方。</p><h4 id="Change-Buffer-适用场景"><a href="#Change-Buffer-适用场景" class="headerlink" title="Change Buffer 适用场景"></a>Change Buffer 适用场景</h4><p>Change Buffer 并不是适用于所有场景，以下两种情况不适合开启 Change Buffer ：</p><ol><li><p>数据库都是唯一索引<br>如果数据库都是唯一索引，那么在每次操作的时候都需要判断索引是否有冲突，势必要将数据加载到缓存中对比，因此也用不到 Change Buffer。</p></li><li><p>写入一个数据后，会立刻读取它<br>写入一个数据后，会立刻读取它，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p></li></ol><p>以下几种情况开启 Change Buffer，会使得 MySQL 数据库明显提升：</p><ol><li>数据库大部分是非唯一索引</li><li>业务是写多读少</li><li>写入数据之后并不会立即读取它</li></ol><p>作者：平头哥的技术博文<br>链接：<a href="https://juejin.im/post/5e538d7ff265da5715630e8d" target="_blank" rel="noopener">https://juejin.im/post/5e538d7ff265da5715630e8d</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><a href="https://juejin.im/post/5e538d7ff265da5715630e8d?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5e538d7ff265da5715630e8d?utm_source=gold_browser_extension</a></p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DB-数据库索引</title>
      <link href="/2020/02/27/DB-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/02/27/DB-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://juejin.im/post/5e575cb56fb9a07c951cdb39?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5e575cb56fb9a07c951cdb39?utm_source=gold_browser_extension</a></p><p>自从两年前了解到的索引以来的，就一直想写一篇有关索引的文章。然而我是个拖延癌症患者，一拖就是两年，不愧是我。该篇文章算是自己的笔记，欢迎批评。<br>概述<br>索引是什么？很多书和文章都会使用图书的目录来类比。目录的目的就是用方便我们查找具体内容的位置，具体的章节的范围。与此类似，MySQL中索引的用途是帮助我们加速查询以及排序。<br>在InnoDB中的索引类型有哈希索引、B+树索引、全文索引。哈希索引在InnoDB中设计为自适应的，不展开讨论。在InnoDB1.12之后有了全文索引，也是应用倒排，还没踩过坑(据说不支持中文)，有时间可以研究一下。<br>本篇主要讨论B+树索引。<br>B+树<br>学习MySQL的索引，必须得先了解其原理，否则很多问题将一头雾水。下文将讲述索引数据结构的原理，而不涉及其复杂的具体实现。<br>在谈B+树之前，不妨先思考，为什么索引能加快查询？为什么要用B+树作为索引而不用B树？哈希索引查询复杂度为O(1)为什么又不用哈希索引？<br>BST和AVL<br>在了解B树和B+树之前，先了解一下二叉搜索树(BST)和平衡二叉树(AVL)。<br>在顺序存储结构中(如数组)，最快的情况是第一个就是目标值，最坏的情况是最后一个是目标值，假设有n个元素，用大O标记法平均的时间复杂度为O(n)。<br>使用二叉搜索树可以有效的优化搜索时间。利用二叉搜索树的特性左子节点比父节点小、右子节点比父节点大，可以很方便的进行二分查找，有效优化的搜索时间。</p><p>正常情况下，我们使用二叉搜索树可以了，但如果出现以下的情况，二叉搜索树反而起不到效果，搜索的平均时间复杂度依旧为O(n)。</p><p>引入平衡二叉树，深度差不超过1，从而保证不倾斜，或者说更矮，保证其搜索效率。<br>B树和B+树<br>既然平衡二叉树已经可以加快查询了，但实际上InnoDB并不会使用。在思考B树和B+树的相关问题的时候，离不开一个问题——磁盘IO。索引文件存储在磁盘，假设有平衡二叉树树高30，那么你可能要扫描30次磁盘才能完成搜索。<br>对于需要磁盘IO的情况，使用平衡二叉树依旧比较糟糕，所以需要引入多路树，即B树和B+树，使得树更“矮”。</p><p>如果上述B树改成二叉树，那么树的高度就大了很多，换而言之就需要更多次的磁盘IO。<br>B+树是B树的变种。B+树的非叶子结点不存储数据，并且所有的叶子节点以双向链表的形式相连。</p><p>现在的索引模型基本都是B+树。<br>相对于B树来说，B+树的搜索更加稳定，因为B树有的数据是分布在非叶子节点上的。<br>B树的叶子节点以链表的形式相连且按照规则排了序，通过B+索引，可以更加方便的获取范围数据。<br>这也是不使用哈希索引的原因。虽然哈希索引搜索的时间复杂度为O(1)，但大部分时候我们并不会只查询一条记录，这种时候使用哈希索引就比较乏力了。<br>聚集索引<br>聚集索引，亦可称为主键索引。一张表只存在一个聚集索引。<br>聚集索引是根据其主键作为排序规则的B+树，搜索时根据其主键进行搜索。<br>其中叶子节点上存储着整条记录的数据。<br>InnoDB的B+树在磁盘中的存储是以数据页的形式，在树中间进行插入和删除操作涉及列“页分裂”和“页合并”的复杂过程(关于这点我个人也讲不明白，但可以类比AVL树的旋转去理解)，十分耗性能，而直接插入尾部是比较快捷的方式，所以在很多的规范中写道，当使用InnoDB引擎的时候，强烈建议用一个与业务无关的自增id作为主键。<br>此外，删除也是一样的，很多时候会要求做伪删除，不仅仅只是为了数据分析，更是为了索引的性能。<br>非聚集索引<br>非聚集索引又称辅助索引，以非主键列来建立。非聚集索引可以有多个。非聚集索引和聚集索引的区别在于，非聚集索引的叶子节点并不存储整条记录的数据，而是存储指向的主键的指针。所以，当利用非主键索引进行搜索时，还需要通过主键索引获取整条数据。<br>单值索引<br>单值索引就是在数据表单个列上建立单个值。<br>CREATE INDEX index_name ON table_name(column);<br>复制代码与主键索引类似，单值索引按照所指定列排序建立二叉树。当利用单值搜索到目标后，再通过主键索引去读取整条数据。<br>唯一索引<br>唯一索引与单值索引区别不大，只是唯一索引的值不会重复。<br>唯一索引除了能提高一些效率以外，有时也用来保证列的唯一性，如用户的手机号身份证等。这里不做过多赘述。<br>联合索引<br>创建联合索引时指定多列即可。<br>CREATE INDEX index_name ON table_name(column1, columm2, column3 [,…])<br>复制代码联合索引会按照建立索引时的顺序，对每个字段进行排序。即第一个字段排完序，接着排第二个字段，第三…</p><p>覆盖索引<br>在前面提到，非聚集索引搜索记录时还需要通过的主键索引，但如果查找的列刚刚好是联合索引的字段，那就没有必要去再去搜索主键索引，直接取叶子节点值即可，这就是覆盖索引。<br>为什么不用select *，原因就在此，不仅仅是为了减少读取更多列带来的开销，也是为了能够使用上覆盖索引。使用覆盖索引可以减少磁盘IO，有效提高性能。<br>下文将讲述有关联合索引的更多细节。<br>最左前缀原则<br>上文了解了联合索引，知道了联合索引的节点数据是按照建索引的顺序依次排序，由此我们引出了最左前缀原则，联合索引中，如果要用上索引字段，前面的字段不能跳过。如果上图的例子，假设是找column2=“ccc”的记录，大概的sql如下<br>SELECT some_column FROM table_name WHERE column2=”ccc”<br>复制代码这种情况下索引是用不上的，因为索引是先排序的column1，再排序column2，直接通过column2搜索，B+树并不知道怎么搜索。<br>索引失效<br>除了上述的最左前缀原则下索引的失效，还有其他索引失效情况。</p><p>使用MySQL内置函数运算的列索引会失效。</p><p>使用!=，is null，is not null 索引会失效。<br>比如你查找id != 500的记录，相当把扫描id<500，以及id >500的记录，本质上全表扫描没啥区别。</p><p>范围查询后的列无法使用。<br>还是用上图的例子，假设查询 column1 &lt;= 4的情况<br>SELECT some_column FROM table_name WHERE column1 &lt;= 4<br>复制代码因为column1是排了序的，索引联合索引column1还是可以使用上的，但column1是范围数据，在这范围内column2并不有序。</p><p>以通配符开头的模糊查询(LIKE “%string”)。<br>值得一提的是，LIKE “string%”是能用上索引的，类似于范围查询，查询从string开头的最小字符串到stirng开头的最大字符串。知道了LIKE “string%”是能用上索引的就能理解为什么LIKE “%string”为什么用不上索引了。</p><p>还有其他情况的情况，可用MySQL的查询分析器进行分析。<br>InooDB使用的锁是行锁，但如果在更新时索引失效了，行锁会变成表锁，在开发中应该避免。<br>索引使用tip</p><p>常用来分组和排序的字段可建立索引。<br>索引的作用是查询和排序，order by和group by是可以用上索引的，如果排序的有多字段，也是按照最左前缀原则。</p><p>经常用来查询的字段可建索引。</p><p>更新频繁的字段不要建立索引。<br>频繁更新的字段如果建立来索引，更新时不仅更新数据，而且索引的B+树也会发生变化，开销比较大，得不偿失。</p><p>选择性小的列不要建立索引。<br>比如说性别字段，只有男或女或未知，百万数据里只有这三个值，建立索引毫无意义。</p><p>索引尽量使用等值匹配。</p><p>尽量使用覆盖索引。</p><p>小结<br>通过建立索引，可以有效的加速数据库的查询和排序。当谈及的数据库优化时，索引优化肯定跑不了。索引的使用有各业界大佬总结的技巧，但很多东西不是绝对的，不能以偏概全，在大数据以及复杂业务下，索引的维护算是玄学，需要不断寻找最佳的索引方案。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-位运算</title>
      <link href="/2020/02/27/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2020/02/27/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="奇偶判断"><a href="#奇偶判断" class="headerlink" title="奇偶判断"></a>奇偶判断</h4><p>if( n &amp; 2 == 1){<br>    dosomething();<br>}</p><h4 id="利用n-amp-n-1-消去n最后的一位1"><a href="#利用n-amp-n-1-消去n最后的一位1" class="headerlink" title="利用n &amp; (n - 1)消去n最后的一位1"></a>利用n &amp; (n - 1)消去n最后的一位1</h4><p>(1)、判断一个正整数n是否为2的幂次方<br>如果一个数是 2 的幂次方，意味着 n 的二进制表示中，只有一个位 是1，其他都是0。我举个例子，例如<br>2^0 = 0…..0001<br>2^1 = 0…..0010<br>2^2 = 0….0100<br>那么我们完全可以对n执行n = n &amp; (n - 1)，执行之后结果如果不为 0，则代表 n 不是 2 的幂次方，代码如下</p><p>(2）判断正整数n的二进制表示中有多少个 1<br>我们可以用不断着执行 n &amp; (n - 1)，每执行一次就可以消去一个 1，当 n 为 0 时，计算总共执行了多少次即可</p><h4 id="异或-运算的妙用"><a href="#异或-运算的妙用" class="headerlink" title="异或(^)运算的妙用"></a>异或(^)运算的妙用</h4><p>特性一：两个相同的数相互异或，运算结果为 0，例如 n ^ n = 0<br>特性二：任何数和 0 异或，运算结果不变，例如 n ^ 0 = n<br>特性三：支持交换律和结合律，例如 x ^ ( y ^ x) = (x ^ y) ^ x</p><p>  案例1：只出现一次是数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DB-MySQl一些概念</title>
      <link href="/2020/02/27/DB-MySQl%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/02/27/DB-MySQl%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库ACID, 数据库锁，数据库索引，数据库安全性, 数据库完整性</p><a id="more"></a><h3 id="数据库事务的ACID"><a href="#数据库事务的ACID" class="headerlink" title="数据库事务的ACID"></a>数据库事务的ACID</h3><ul><li><p>原子性(Atomicity): 指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><ol><li>案例: A转账给B 100 元<br><img src="ACID_A.png" alt="原子性"></li><li>分析: 在事务中的A扣款和B加款要么都执行成功,要么都不执行。</li><li>解决方案: 在数据库管理系统（DBMS）中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。mysql使用 undo log，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</li></ol></li><li><p>一致性(Consistency): 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><ol><li>案例: 数据库存在约束A和B的总金额为200</li><li>分析: 在执行转账任务结束后,也应遵守此约束。</li><li>解决方案:<br>保障事务的一致性，可以从以下两个层面入手<br>(1) 数据库机制层面<br>在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置。mysql使用 redo log和Buffer Pool，Buffer Pool存储待写入数据库的数据，redo log记录事务的操作<br>(2) 业务层面<br>使用业务逻辑保证数据一致</li></ol></li><li><p>隔离性(Isolation): 指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><ol><li>解决方案：利用加锁和阻塞来保证事务之间不同等级的隔离性。</li></ol></li><li><p>持久性(Durability): 指事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。<br>解决方案: SQL SERVER通过对事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQLSERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性。</p></li></ul><h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><ul><li>共享锁：又叫S锁或者读锁，加了共享锁的数据对象可以被其他事务读取，但不能修改， 通常是该数据对象被读取完毕，锁立即被释放</li><li>排他锁：又叫X锁或者写锁，当数据对象被加上排它锁时，一个事务必须得到锁才能对该数据对象进行访问，一直到事务结束锁才被释放。 在此之间其他的事务不能对它读取和修改</li><li>行锁: 行级别的锁</li><li>表锁: 表级别的锁</li></ul><h4 id="数据库的索引的数据结构"><a href="#数据库的索引的数据结构" class="headerlink" title="数据库的索引的数据结构"></a>数据库的索引的数据结构</h4><p>B+树</p><h4 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h4><p>权限控制和数据备份</p><h4 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h4><p>通过一些约定和规范来限制数据库的存储内容，比如主键、唯一键、非空等要求来限制字段的取值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DB-MySQL存储引擎</title>
      <link href="/2020/02/27/DB-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2020/02/27/DB-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>MySQL存储引擎也称作表类型是指，MySQL使用的不同的存储技术将数据存储在文件（或者内存）中。<br>这些技术指不同的存储机制、索引技巧、锁定水平等。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>需要根据不同的应用场景选择不同的数据引擎<br>例如：研究大量的临时数据需要选择内存存储引擎<br>     需要处理事务型的业务需要选择支持事务性的数据库</p><h4 id="常用引擎及其特性"><a href="#常用引擎及其特性" class="headerlink" title="常用引擎及其特性"></a>常用引擎及其特性</h4><p>MyISAM： 拥有较高的插入，查询速度，但不支持事务<br>InnoDB：事务型数据库的首选引擎，支持ACID事务，支持行级锁定<br>CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ML-softmax 理解</title>
      <link href="/2020/02/25/ML-softmax/"/>
      <url>/2020/02/25/ML-softmax/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="softmax-含义"><a href="#softmax-含义" class="headerlink" title="softmax 含义"></a>softmax 含义</h4><p>softmax把一些输入映射为0-1之间的实数，并且归一化保证和为1，因此多分类的概率之和也刚好为1。</p><p>首先简单理解softmax的含义。顾名思义，softmax由两个单词组成，其中一个是max。对于max我们都很熟悉，比如有两个变量a,b。如果a&gt;b，则max为a，反之为b。<br>另外一个单词为soft。max存在的一个问题是什么呢？如果将max看成一个分类问题，就是非黑即白，最后的输出是一个确定的变量。更多的时候，我们希望输出的是取到某个分类的概率，或者说，我们希望分值大的那一项被经常取到，而分值较小的那一项也有一定的概率偶尔被取到，所以我们就应用到了soft的概念，即最后的输出是每个分类被取到的概率。</p><h4 id="softmax-计算"><a href="#softmax-计算" class="headerlink" title="softmax 计算"></a>softmax 计算</h4><p>计算过程如下图<br><img src="softmax.jpg" alt="softmx"></p><p>假设有一个数组V，$ V_i $表示V中的第i个元素，那么这个元素的softmax值为:<br>$$ s_i = \frac{e^i}{\sum_{j = 1} ^{i}e^j} $$<br>该元素的softmax值，就是该元素的指数与所有元素指数和的比值。</p><p>这个定义可以说很简单，也很直观。那为什么要定义成这个形式呢？原因主要如下。</p><p>1.softmax设计的初衷，是希望特征对概率的影响是乘性的。<br>2.多类分类问题的目标函数常常选为cross-entropy。即 $ L = - \sum_{k} t_k \cdot \ln P(y = k)$，其中目标类的 $ t_k $为1，其余类的$ t_k $为0。</p><h4 id="softmax求导"><a href="#softmax求导" class="headerlink" title="softmax求导"></a>softmax求导</h4><p>在多分类问题中，我们经常使用交叉熵作为损失函数<br>$$ Loss = - \sum{t_i} \ln{y_i} $$<br>其中，$ t_i $表示真实值，$ y_i $表示求出的softmax值。<br>当预测第i个时，可以认为$ t_i = 1 $。此时损失函数变成了:<br>$$ Loss_i = −\ln {y_i} $$</p><p>接下来对$ Loss $求导。根据定义：<br>$$ y_i = \frac{e^i} {\sum_j e_j} $$</p><p>我们已经将数值映射到了0-1之间，并且和为1，则有：<br>$$ \frac{e^i} {\sum_j e^j} = 1 - \frac{ \sum_{j \neq i} e^j} { \sum_j e^j} $$</p><p>求导</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TF2-fashion_mnist_分类模型</title>
      <link href="/2020/02/25/tf2-fashion-mnist-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/02/25/tf2-fashion-mnist-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用三层全联接层对图片进行分类</p><figure class="highlight python"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(x_train_all, y_train_all), (x_test, y_test) = fashion_mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分为测试集和训练集</span></span><br><span class="line">x_valid, x_train = x_train_all[:<span class="number">5000</span>], x_train_all[<span class="number">5000</span>:]</span><br><span class="line">y_valid, y_train = y_train_all[:<span class="number">5000</span>], y_train_all[<span class="number">5000</span>:]</span><br><span class="line"></span><br><span class="line">print(x_valid.shape, y_valid.shape)</span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 归一化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">x_train_scaled = scaler.fit_transform(</span><br><span class="line">    x_train.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">x_valid_scaled = scaler.transform(</span><br><span class="line">    x_valid.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">x_test_scaled = scaler.transform(</span><br><span class="line">    x_test.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">print(np.max(x_train_scaled), np.min(x_train_scaled))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_single_image</span><span class="params">(img_arr)</span>:</span></span><br><span class="line">    plt.imshow(img_arr, cmap=<span class="string">"binary"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">show_single_image(x_train[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_imgs</span><span class="params">(n_rows, n_cols, x_data, y_data, class_names)</span>:</span></span><br><span class="line">    plt.figure(figsize = (n_cols * <span class="number">1.4</span>, n_rows * <span class="number">1.6</span>))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n_rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n_cols):</span><br><span class="line">            index = n_cols * row + col</span><br><span class="line">            plt.subplot(n_rows, n_cols, index + <span class="number">1</span>)</span><br><span class="line">            plt.imshow(x_data[index], cmap = <span class="string">"binary"</span>, interpolation = <span class="string">"nearest"</span>)</span><br><span class="line">            plt.axis(<span class="string">'off'</span>)</span><br><span class="line">            plt.title(class_names[y_data[index]])</span><br><span class="line">    plt.show()</span><br><span class="line">class_names = [<span class="string">'T-shirt'</span>, <span class="string">'Trouser'</span>, <span class="string">'Pullover'</span>, <span class="string">'Dress'</span>, <span class="string">'Coat'</span>, <span class="string">'Sandal'</span>, <span class="string">'Shirt'</span>, <span class="string">'Sneaker'</span>, <span class="string">'Bag'</span>, <span class="string">'Ankle boot'</span>]</span><br><span class="line"></span><br><span class="line">show_imgs(<span class="number">3</span>, <span class="number">5</span>, x_train, y_train, class_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape = [<span class="number">28</span>, <span class="number">28</span>]),</span><br><span class="line">    keras.layers.Dense(<span class="number">300</span>, activation = <span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">100</span>, activation = <span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation = <span class="string">'softmax'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">model.compile(loss = <span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              optimizer = <span class="string">"sgd"</span>,</span><br><span class="line">              metrics=[<span class="string">"accuracy"</span>])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">history = model.fit(x_train, y_train, epochs = <span class="number">10</span>, validation_data = (x_valid, y_valid))</span><br><span class="line"></span><br><span class="line">history.history</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curves</span><span class="params">(history)</span>:</span></span><br><span class="line">    pd.DataFrame(history.history).plot(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_ylim(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_learning_curves(history)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TF2 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/2020/02/25/%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/25/%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1014 Waiting in Line</title>
      <link href="/2020/02/24/PAT-1014-Waiting-in-Line/"/>
      <url>/2020/02/24/PAT-1014-Waiting-in-Line/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936" target="_blank" rel="noopener">1014 Waiting in Line</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一队列人到银行办理业务, 每个人办理业务时长不同, 银行有几个服务窗口，每个服务窗口允许固定的人数排队，排满之后，后面的人只能等着在办理的人结束，才能去排队。<br>哪个队列走就可以去排那个队列，银行的营业时间是8:00-17:000<br><a id="more"></a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这道题就是一个排队入队出队问题，问题的难点怎样确定去排哪个队。<br>类似于多核CPU任务调度的问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个结构体来记录每个窗口的信息<br>ST_WINDOW{<br>    int iTopFinishTime;<br>    int iTotalTime;<br>    queue<int> quePeopleId;<br>};<br>iTopFinishTime 表示队列中最顶端的人何时服务结束<br>iTotalTime 表示这个队列总共服务的时长<br>quePeopleId 表示当前队列中的人<br>这样每次只需要找到当前所有窗口最小的iTopFinishTime，就是下次可排队的窗口</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST_WINDOW</span>&#123;</span>  <span class="comment">//模拟服务窗口</span></span><br><span class="line">    <span class="keyword">int</span> iTopFinishTime;</span><br><span class="line">    <span class="keyword">int</span> iTotalTime;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; quePeopleId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iM, iK, iQ;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; iN &gt;&gt; iM &gt;&gt; iK &gt;&gt; iQ;</span><br><span class="line">    ST_WINDOW stWindow[iN]; <span class="comment">//服务窗口</span></span><br><span class="line">    <span class="keyword">int</span> szProcessTime[iK]; <span class="comment">//每个客户处理的时间</span></span><br><span class="line">    <span class="keyword">int</span> szFinishTime[iK]; <span class="comment">//每个客户结束处理时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iK; iIndex ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; szProcessTime[iIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iProcessingNum = <span class="built_in">min</span>(iN * iM, iK); <span class="comment">//可进入服务窗口排队的人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span> ; iIndex &lt; iProcessingNum; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        stWindow[iIndex % iN].quePeopleId.push(iIndex);</span><br><span class="line">        <span class="keyword">if</span>(iIndex &lt; iN)</span><br><span class="line">        &#123;</span><br><span class="line">            stWindow[iIndex % iN].iTopFinishTime = szProcessTime[iIndex];</span><br><span class="line">            stWindow[iIndex % iN].iTotalTime = szProcessTime[iIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stWindow[iIndex % iN].iTotalTime = stWindow[iIndex % iN].iTotalTime + szProcessTime[iIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        szFinishTime[iIndex] = stWindow[iIndex % iN].iTotalTime ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = iProcessingNum; iIndex &lt; iK; iIndex++) <span class="comment">//需要等待进入排队的人</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iMinTopFinishTimeWindow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找最小的顶端服务时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jIndex = <span class="number">1</span>; jIndex &lt; iN; jIndex ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stWindow[iMinTopFinishTimeWindow].iTopFinishTime &gt; stWindow[jIndex].iTopFinishTime)</span><br><span class="line">            &#123;</span><br><span class="line">                iMinTopFinishTimeWindow = jIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].quePeopleId.pop();</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].quePeopleId.push(iIndex);</span><br><span class="line">        <span class="keyword">int</span> iToProcePeopleId = stWindow[iMinTopFinishTimeWindow].quePeopleId.front();</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].iTopFinishTime += szProcessTime[iToProcePeopleId];</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].iTotalTime += szProcessTime[iIndex];</span><br><span class="line">        szFinishTime[iIndex] = stWindow[iMinTopFinishTimeWindow].iTotalTime ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> iQueryId;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iQ; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; iQueryId;</span><br><span class="line">        <span class="keyword">if</span>(szFinishTime[iQueryId - <span class="number">1</span>] - szProcessTime[iQueryId - <span class="number">1</span>]&gt;= <span class="number">540</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Sorry"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d"</span>, <span class="number">8</span> + (szFinishTime[iQueryId - <span class="number">1</span>]) / <span class="number">60</span> , (szFinishTime[iQueryId - <span class="number">1</span>] ) % <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iIndex&lt;iQ<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1010 Radix</title>
      <link href="/2020/02/24/PAT-1010-Radix/"/>
      <url>/2020/02/24/PAT-1010-Radix/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">1010 Radix</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定两个数，并告诉其中一个数的进制数，然后判断是否存在一个进制使得两个数相等</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题题目很好理解,就是做起来真难受,各种部分正确<br>总体思路就是使用二分法找进制,按照进制转换成数字.<br>其中二分的下限是所有进制数中最大数加1，上限是此数本身。<br>要考虑数位益处的问题，溢出后其数符号位为负</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串按进制转换为长整型</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">str2RadixNum</span><span class="params">(<span class="built_in">string</span> strNum, <span class="keyword">long</span> <span class="keyword">long</span> llRadix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pT = strNum.<span class="built_in">begin</span>(); pT != strNum.<span class="built_in">end</span>(); pT++)</span><br><span class="line">    &#123;</span><br><span class="line">        llNum = llNum * llRadix + (<span class="built_in">isdigit</span>(*pT) ? (*pT - <span class="string">'0'</span>) : (*pT - <span class="string">'a'</span> + <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> llNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分法寻找进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">findNumRadix</span><span class="params">(<span class="built_in">string</span> strNum, <span class="keyword">long</span> <span class="keyword">long</span> llTagNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> strMaxChar = *max_element(strNum.<span class="built_in">begin</span>(), strNum.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llLow = (<span class="built_in">isdigit</span>(strMaxChar) ? strMaxChar - <span class="string">'0'</span> : strMaxChar - <span class="string">'a'</span> + <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llHigh = <span class="built_in">max</span>(llLow,llTagNum);</span><br><span class="line">    <span class="keyword">while</span>(llLow &lt;= llHigh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llMedium = (llLow + llHigh) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llMediumRadixNum = str2RadixNum(strNum, llMedium);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(llMediumRadixNum &lt; <span class="number">0</span> || llMediumRadixNum &gt; llTagNum) <span class="comment">//防止溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            llHigh = llMedium - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(llMediumRadixNum &lt; llTagNum)</span><br><span class="line">        &#123;</span><br><span class="line">            llLow = llMedium + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> llMedium;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strN1;</span><br><span class="line">    <span class="built_in">string</span> strN2;</span><br><span class="line">    <span class="keyword">int</span> iTag;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llRadix;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt; strN1 &gt;&gt; strN2 &gt;&gt; iTag &gt;&gt; llRadix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llTagNum = iTag == <span class="number">1</span> ? str2RadixNum(strN1, llRadix) : str2RadixNum(strN2, llRadix);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llResult = iTag == <span class="number">1</span> ? findNumRadix(strN2, llTagNum) : findNumRadix(strN1, llTagNum);</span><br><span class="line">        llResult == <span class="number">-1</span> ? <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt;<span class="built_in">endl</span> : <span class="built_in">cout</span>&lt;&lt; llResult &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1015 Reversible Primes</title>
      <link href="/2020/02/22/PAT-1015-Reversible-Primes/"/>
      <url>/2020/02/22/PAT-1015-Reversible-Primes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805495863296000" target="_blank" rel="noopener">1015 Reversible Primes</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数以及它的进制数，判断数本身以及它的数位的逆是不是都是质数<br><a id="more"></a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题目来判断原数是不是质数，数位逆转后再判断是不是质数</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> iNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iNum &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iNum == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iHalf = iNum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> iDivisorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= iHalf; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iNum % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数位反转</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> iNum, <span class="keyword">int</span> iD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iReverse = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iNum != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iReverse = iReverse * iD + iNum % iD;</span><br><span class="line">        iNum = iNum / iD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iReverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iD;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt; iN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iN &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; iD;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(iN) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(reverse(iN, iD)) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-数据迁移问题</title>
      <link href="/2020/02/21/Django-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2020/02/21/Django-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> Django在迁移数据库数据时一些方法步骤，以及在导出安全删除数据时的处理方法<br> <a id="more"></a></p><ol><li><p>清空数据表<br>python manage.py flush</p></li><li><p>使用Django框架的倒入导出<br>python manage.py dumpdata [APP_NAME] &gt; [EXPOER_FILE_NAME]<br>python manage.py loaddata [EXPOER_FILE_NAME]<br>不指定应用名称则会导出所有数据表，包括一些系统数据表<br>所以在导出时尽量只指定有关业务应用的名称<br>例如:<br>有personnels和customers两个应用要导出数据时<br>python manage.py dumpdata personnels customers &gt; data.json</p><p>导入数据<br>python manage.py loaddata data.json</p></li><li><p>当使用安全删除策略时可能面临的导出问题<br>若业务删除操作写的很标准，关联数据都可以逻辑删除的话，执行上述导出导入就可以实现数据的迁移<br>但时可能由于业务复杂，表关联复杂，导致一些数据逻辑删除后，其关联表数据还在。这样在执行原来导出时，那些逻辑删除的数据会导不出来，在执行导入时就会导致某些PK找不到数据</p><p>如下解决方法是修改框架对于数据查询的代码，将所有数据，包括逻辑删除的数据一并导出</p><p>修改框架manager.py的get_queryset函数中的将safedelete_visibility修改为DELETE_VISIBLE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryset._safedelete_visibility = DELETED_VISIBLE</span><br></pre></td></tr></table></figure><p>然后执行导出命令</p><p>说明：<br>在寻找解决方法的过程实际上是想到python manage.py dumpdata命令也是要查询数据的，万变不离其宗，他一定会去查数据表中的数据，也一定是通过sql语句查询的，未修改框架代码时，他默认是过滤掉了逻辑删除的数据，所以这里只要找到调用数据库查询的接口，把逻辑删除查询命令改掉就可以，经过查找就是这个了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1013 Battle Over Cities</title>
      <link href="/2020/02/21/PAT-1013-Battle-Over-Cities/"/>
      <url>/2020/02/21/PAT-1013-Battle-Over-Cities/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">1013 Battle Over Cities</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一些列城市的道路关系，然后去掉一个城市，求解最少需要多少条路才能连通</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题就是求连通域的个数<br>使用深搜，搜索几次就是几个连通域<br>注意：最后一个样例可能会超时,用C的输入输出</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iN, iM, iK;</span><br><span class="line"><span class="keyword">bool</span> szVisited[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">bool</span> szRoute [<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> iCity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    szVisited[iCity] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iN; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(szRoute[iCity][iIndex] == <span class="literal">true</span> &amp;&amp; szVisited[iIndex] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(iIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;iN, &amp;iM, &amp;iK);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iM; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iCity1;</span><br><span class="line">        <span class="keyword">int</span> iCity2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iCity1 &gt;&gt; iCity2;</span><br><span class="line">        szRoute[iCity1 - <span class="number">1</span>][iCity2 - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        szRoute[iCity2 - <span class="number">1</span>][iCity1 - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iK; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iCity;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iCity);</span><br><span class="line">        <span class="built_in">fill</span>(szVisited, szVisited + iN, <span class="literal">false</span>);</span><br><span class="line">        szVisited[iCity - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jIndex = <span class="number">0</span>; jIndex &lt; iN; jIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(szVisited[jIndex] == <span class="literal">true</span>) <span class="comment">//访问过的城市不再访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(jIndex);</span><br><span class="line">            iResult ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, iResult - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1012 The Best Rank</title>
      <link href="/2020/02/21/PAT-1012-The-Best-Rank/"/>
      <url>/2020/02/21/PAT-1012-The-Best-Rank/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">1012 The Best Rank</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一些列学生在给定科目的得分情况，计算每个学生排名最好的科目，或者平均分排名最好</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目要求给出每个学生A,C,M,E的分数,计算每个学生名次最好的科目,且4个科目的重要程度为A&gt;C&gt;M&gt;E<br>求解过程是将每科的分数单独排序,计算出每个科目分数所在的名次,并用map存下该分数的名次,然后可以直接通过学生的分数得到所在名次</p><p>对于A平均分排序,因为浮点数不适合做key值,所以我采用总分排名</p><p>注意：相同分数的名次相同,其后的名次则为累计名次</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_GRADE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> C;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> szTest[<span class="number">4</span>] = &#123;<span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>, <span class="string">'A'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iM;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;iN &gt;&gt;iM;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecGrade[<span class="number">4</span>]; <span class="comment">//记录每种科目的所有分数,并排序</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapGradeIndex[<span class="number">4</span>]; <span class="comment">//记录分数在该科目中的位次</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, STUDENT_GRADE&gt; mapStudentGrade; <span class="comment">//记录学生的分数</span></span><br><span class="line">    <span class="built_in">string</span> strStudentId;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iN; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iC, iM, iE;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId &gt;&gt; iC &gt;&gt; iM &gt;&gt; iE;</span><br><span class="line">        STUDENT_GRADE stTudentGrade;</span><br><span class="line">        stTudentGrade.C = iC;</span><br><span class="line">        stTudentGrade.M = iM;</span><br><span class="line">        stTudentGrade.E = iE;</span><br><span class="line">        stTudentGrade.A = iC + iM + iE;</span><br><span class="line">        mapStudentGrade[strStudentId] = stTudentGrade;</span><br><span class="line">        vecGrade[<span class="number">0</span>].push_back(iC);</span><br><span class="line">        vecGrade[<span class="number">1</span>].push_back(iM);</span><br><span class="line">        vecGrade[<span class="number">2</span>].push_back(iE);</span><br><span class="line">        vecGrade[<span class="number">3</span>].push_back(stTudentGrade.A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个科目的分数进行排序,并计算出位次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(vecGrade[i].<span class="built_in">begin</span>(), vecGrade[i].<span class="built_in">end</span>(), cmp1); <span class="comment">//从大到小倒叙排列</span></span><br><span class="line">        <span class="keyword">int</span> iNextRank = <span class="number">1</span>; <span class="comment">//下一个名次的位次</span></span><br><span class="line">        <span class="keyword">int</span> iLastNum = <span class="number">301</span>; <span class="comment">//总分最大为300,所以这里取301</span></span><br><span class="line">        <span class="comment">//计算位次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vecGrade[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(iLastNum &gt; vecGrade[i][j]) <span class="comment">//上一名的分数大于本轮次分数,名次顺延续</span></span><br><span class="line">            &#123;</span><br><span class="line">                mapGradeIndex[i][vecGrade[i][j]] = iNextRank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mapGradeIndex[i][vecGrade[i][j]] = mapGradeIndex[i][vecGrade[i][j]]; <span class="comment">//和上一名分数相同,则名次也相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            iLastNum = vecGrade[i][j]; <span class="comment">//保留本轮分数</span></span><br><span class="line">            iNextRank ++; <span class="comment">// 记录分数位次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iM; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId;</span><br><span class="line">        <span class="keyword">if</span>(mapStudentGrade.<span class="built_in">find</span>(strStudentId) == mapStudentGrade.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"N/A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iTest = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> iRank = mapGradeIndex[<span class="number">3</span>][mapStudentGrade[strStudentId].A];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">0</span>][mapStudentGrade[strStudentId].C])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">0</span>][mapStudentGrade[strStudentId].C];</span><br><span class="line">            iTest = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">1</span>][mapStudentGrade[strStudentId].M])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">1</span>][mapStudentGrade[strStudentId].M];</span><br><span class="line">            iTest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">2</span>][mapStudentGrade[strStudentId].E])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">2</span>][mapStudentGrade[strStudentId].E];</span><br><span class="line">            iTest = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; iRank &lt;&lt; <span class="string">" "</span>&lt;&lt; szTest[iTest] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS-多线程综述</title>
      <link href="/2020/02/21/CS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%BC%E8%BF%B0/"/>
      <url>/2020/02/21/CS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SLAM-学习笔记</title>
      <link href="/2020/02/20/SLAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/20/SLAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第三讲 三维空间刚体运动<br>3.1 点，向量和坐标系，旋转矩阵</p><ul><li>表示</li><li>运算(加减, 内积, 外积)</li></ul><p>第三讲 三维空间的刚体运动</p><ul><li><p>两个不同的坐标系变化  T = 旋转 + 平移</p><p>旋转<br>设某坐标系D1(e1, e2, e3)发生一次旋转，变成了D2(e1’, e2’, e3’)</p><p>旋转矩阵： 1. R是一个正交矩阵 2. R的行列式为+1</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音-一荤一素</title>
      <link href="/2020/02/20/%E9%9F%B3-%E4%B8%80%E8%8D%A4%E4%B8%80%E7%B4%A0/"/>
      <url>/2020/02/20/%E9%9F%B3-%E4%B8%80%E8%8D%A4%E4%B8%80%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日出又日落 深处再深处<br>一张小方桌 有一荤一素<br><img src="一荤一素.jpeg" alt="一荤一素"><br><a id="more"></a></p><p>日出又日落 深处再深处<br>一张小方桌 有一荤一素<br>一个身影从容地忙忙碌碌<br>一双手让这时光有了温度<br>太年轻地人 他总是不满足<br>固执地不愿停下 远行的脚步<br>望着高高的天走了长长的路<br>忘了回头看 她有没有哭<br>月儿明 风儿轻<br>可是你在敲打我的窗棂<br>听到这你就别担心<br>其实我过的还可以<br>月儿明 风儿轻<br>你又可曾来过我的梦里<br>一定是你来时太小心<br>知道我睡得很轻</p><p>音评：<br>第一次听这首歌是在歌手上听到的，一直喜欢听毛不易的歌曲，很安静。这首歌更是听的深入我心，听的过程很有画面<br>，很多回忆涌来，不知道怎么的我就长大了，现在还能想到童年的几个片段。<br>那应该是中午刚过，我躲在鸡房那个老房子门口，那时应该是个冬天，挺冷的，没有去上学。我在门口躲风等着妈妈去集市回来。现在还能体会到当时的感觉。<br>还有一个片段是跟着妈妈去集市卖鸡蛋，忘了那时是几年级了，反正当时觉得自己挺大的。<br>现在想到这些莫名的酸楚</p><h2 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h2><p>你传的照片，是我离家时的床铺<br>你说好久了，屋子都没人住<br>我总有办法打断你的叮嘱<br>多数是不耐烦，少数是想哭</p><p>我总说自己要减轻你的辛苦<br>要自己去闯自己的路<br>以为自己足够光彩夺目<br>却被你一眼看穿艰辛苦楚</p><p>传说上帝无法亲力亲为所有的守护<br>派仙女下凡，做人间的公主<br>从此，<br>一切美好，在茶米油盐中驻足</p><hr><p>一荤配一素，一汤配一饭<br>平常日子里，不仅也不慢<br>你给我港湾，我给你期盼<br>走时抬头望天，忍住泪珠涟涟<br>忘了回头看，他人形只影单<br>远行，是孤寂的身影<br>送别，是难耐的情绪<br>他乡，是未知的故里<br>忘了有多久没回到这个港湾<br>忘了她的期盼<br>回去吧，停下远行的脚步<br>月儿正明，风儿正轻，吃一顿热腾腾的饭</p>]]></content>
      
      
      <categories>
          
          <category> 音 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>影-海上钢琴师</title>
      <link href="/2020/02/19/%E5%BD%B1-%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88/"/>
      <url>/2020/02/19/%E5%BD%B1-%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88.jpeg" alt="海上钢琴师"><br>首先表态，这影片一看就是经典影片的样子</p><p>看的过程有点松散，分了几段看完的，看完后在我印象中的几个片段，</p><ol><li>胖子卖小号，</li><li>船员爸爸捡到了1900</li><li>船员爸爸被铁链砸中去世</li><li>1900莫名开始弹钢琴还很厉害</li><li>大陆上的著名钢琴师前来挑战，被血虐。</li><li>1900遇到个女孩，还有什么关系</li><li>胖子来找1900</li><li>船炸了</li></ol><hr><p>关于钢琴，关于镜头，关于彼岸，关于1900</p><p>众人叫他天才，众人为之疯狂。1900，从拥有这个不平凡的名字起，就注定是个不平凡的人。目光，掌声和荣耀，平凡人可能终其一生都得不到的东西，对于天才的1900就像空气一样稀松平常。</p><p>但目光，掌声和荣耀并不能令人幸福，也不长久。电影里有一个镜头：人们围绕在1900身边为音乐起舞的时候，有人看见了自由女神，一下子所有的人呼啦啦作鸟兽散，只剩下1900孤寂的身影。再多的荣耀也挽救不了孤独，此刻他非天才，是个可怜的被遗弃者。</p><p>天才其实是世界上最不幸的人。所有的天才都是异类。而再体面的异类都不会被人真正地爱。那些为1900的琴声瞠目结舌的人，在琴声终结的时候，他们也就砸吧着嘴散去。1900这样天才更像个宠物。人们喜欢它，呵护它，痴迷它，但它跑到马路中间迎面驰来飞车，谁也不会扑过去用自己的身体挡住。</p>]]></content>
      
      
      <categories>
          
          <category> 影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Django-查询优化方法</title>
      <link href="/2020/02/19/Django-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/19/Django-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近负责的项目后台访问接口贼慢，有时候慢到没有反应的地步，经过多方排查最终把问题源头确定到数据库性性能上。<br>因为通过尝试，同样的数据同样的代码使用本地数据库和使用云数据库查询速度相差将近百倍。然而提升云数据库性能需要资金，资金不充裕只能从后台代码下手，这个不需要资金支持。</p><p>首先因为访问数据库很慢，所以尽量减少对数据库的操作。参看django框架和自己的思考主要优化方面如下:</p><h4 id="代码层面"><a href="#代码层面" class="headerlink" title="代码层面"></a>代码层面</h4><ol><li><p>在不使用到关联表字段的情况下，尽量使用此表字段名,否则会产生多余的查询</p><p>例如有表关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = models.TextField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  title = models.TextField()</span><br><span class="line">  author = models.ForeignKey(Author, on_delete=models.PROTECT, related_name=<span class="string">'books'</span>, null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>当检查某个某本书的某个作者是否存在时,尽量通Book里面的字段来判断<br>即:<br> 使用if(book.author_id)<br> 不使用if(book.author)</p></li><li><p>正确使用count(),exists()和len(),if判断queryset<br> 如果不使用查询的数据，则使用count(),exists()方法</p><p> 例：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">books = Books.objects.filter()</span><br><span class="line"><span class="keyword">if</span>(len(books) &gt; <span class="number">5</span>):</span><br><span class="line">  do_something_with_books(books)</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">books = Book.objects.filter()</span><br><span class="line"><span class="keyword">if</span> books.count() &gt; <span class="number">5</span>:</span><br><span class="line">  do_something_without_books()</span><br></pre></td></tr></table></figure></li><li><p>使用values()或values_list()只获取需要的数据<br>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book.objects.values(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure></li><li><p>处理很多记录时,使用iterator()<br>当获得一个queryset的时候，Django会缓存这些数据。<br>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> Books.objects.all():</span><br><span class="line">  do_something_with_book()</span><br></pre></td></tr></table></figure><p>此项查询会将所有Books的对象存入内存<br>当我们想要保持这个数据库connection时每可以使用iterator()关键字<br>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> Books.objects.all().iterator():</span><br><span class="line">  do_something_with_book()</span><br></pre></td></tr></table></figure></li><li><p>关联查询select_related, prefetch_related<br>这样可以减少查询次数<br>(select_related, prefetch_related使用)[<a href="https://www.cnblogs.com/linkenpark/p/8866089.html" target="_blank" rel="noopener">https://www.cnblogs.com/linkenpark/p/8866089.html</a>]</p><p>以上可参考<a href="https://www.cnblogs.com/linkenpark/p/8866089.html" target="_blank" rel="noopener">Django ORM</a></p></li></ol><h4 id="数据表设计方面"><a href="#数据表设计方面" class="headerlink" title="数据表设计方面"></a>数据表设计方面</h4><ol><li>为查询到的字段添加索引</li></ol><h4 id="项目结构方面"><a href="#项目结构方面" class="headerlink" title="项目结构方面"></a>项目结构方面</h4><p>使用redis将常用的数据存储下来<br>  因为有一些表采用的是父子表的关系，要查询到所有的数据并保持数据结构，从代码层面是无从下手了，但是这样的数据又必须取到，<br>  所以只能使用终极大招，缓存<br>  对于需要频繁使用且数据量很大的表，在查询时去redis缓存中找，若没有找到则此时建立一个。<br>  需要注意的是，使用缓存要保证缓存数据和数据表数据一致，这里采用的策略是在执行更新操作时更新相应的缓存数据</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1054 The Dominant Color</title>
      <link href="/2020/02/19/PAT-1054-The-Dominant-Color/"/>
      <url>/2020/02/19/PAT-1054-The-Dominant-Color/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768" target="_blank" rel="noopener">1054 The Dominant Color</a></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个值记录当前色号的数量，当收到不同于当前色号的值时则数量减1，当收到相同的色号，数量加1，当数量减为0时，则切换色号</p><a id="more"></a><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> iDominantColor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iDominantColorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iColor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; iColor;</span><br><span class="line">            <span class="keyword">if</span>(iDominantColorCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iDominantColor = iColor;</span><br><span class="line">                iDominantColorCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(iDominantColor == iColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    iDominantColorCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    iDominantColorCount--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iDominantColor&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1011 World Cup Betting</title>
      <link href="/2020/02/18/PAT-1011-World-Cup-Betting/"/>
      <url>/2020/02/18/PAT-1011-World-Cup-Betting/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805504927186944" target="_blank" rel="noopener">1011 World Cup Betting</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>根据分数计算规则计算得分</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> szGameResult[<span class="number">3</span>] = &#123;<span class="string">'W'</span>, <span class="string">'T'</span>, <span class="string">'L'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> fRadio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> maxGameRadio = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> fGameRadio;</span><br><span class="line">        <span class="keyword">int</span> iGameRadioIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; fGameRadio;</span><br><span class="line">            <span class="keyword">if</span>(fGameRadio &gt; maxGameRadio)</span><br><span class="line">            &#123;</span><br><span class="line">                maxGameRadio = fGameRadio;</span><br><span class="line">                iGameRadioIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; szGameResult[iGameRadioIndex] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        fRadio *= maxGameRadio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> fBet = (fRadio * <span class="number">0.65</span> - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, fBet);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-实战部署django服务器</title>
      <link href="/2020/02/18/docker-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2django%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/02/18/docker-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2django%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="django-基本环境安装"><a href="#django-基本环境安装" class="headerlink" title="django 基本环境安装"></a>django 基本环境安装</h2><ol><li><p>docker pull ubuntu:18.04<br>拉一个ubuntu 18.04版本的镜像，开始使用14.04版本在django包时疯狂报错，慎用</p></li><li><p>docker run -it -p 8000:8000 ubuntu:18.04<br>使用ubuntu:18.04启动一个容器<br>其中-p 8000:8000最好在启动容器的时候指定，否则容器启动后很难修改</p></li><li><p>apt-get update<br>更新apt-get</p></li><li><p>apt-get vim<br>安装vim</p></li><li><p>apt-get install python3.6<br>安装python3.6</p></li><li><p>apt-get install python3-pip<br>安装pip3</p></li><li><p>修改pip3的源，速度会很快<br>vim ~/.pip/pip.conf  //修改pip源<br>输入以下pip源：<br>[global]<br>index-url = <a href="http://pypi.douban.com/simple" target="_blank" rel="noopener">http://pypi.douban.com/simple</a><br>trusted-host = pypi.douban.com<br>disable-pip-version-check = true<br>timeout = 120</p></li><li><p>ln -s /usr/bin/python3.6 python<br>给python3创建python的软连接，直接使用python命令</p></li><li><p>pip3 install django==2.2.5<br>安装2.2.5版本的django</p></li></ol><p>此时django环境已经初步完成可测试一下环境是否可用</p><h2 id="django-测试基本环境"><a href="#django-测试基本环境" class="headerlink" title="django 测试基本环境"></a>django 测试基本环境</h2><ol><li><p>django-admin startproject DockerDjangoTest<br>创建一个django项目</p></li><li><p>python manager.py runserver 0.0.0.0:8000<br>启动django服务</p></li></ol><p>此时可以使用浏览器访问””，访问到django欢迎界面就好<br>也可以使用容器的ip访问</p><h2 id="部署生产"><a href="#部署生产" class="headerlink" title="部署生产"></a>部署生产</h2><ol><li><p>pip3 install uwsgi<br>安装uwsgi</p></li><li><p>配置uwsgi文件</p></li></ol><p>‘’’<br>[uwsgi]<br>chdir = /home/ubuntu/qlassroom-ai/backend #后台代码路径<br>module = backend.wsgi #后台.wsgi文件 即/backend/wsgi.py<br>master = True<br>processes = 4<br>max-requests = 5000<br>harakiri = 60<br>socket = 0.0.0.0:8888  #内网ip + 端口号<br>uid = root<br>gid = root<br>pidfile = /home/ubuntu/qlassroom-ai-uwsgi/master.pid<br>daemonize = /home/ubuntu/qlassroom-ai-uwsgi/mysite.log<br>vacuum = True<br>‘’’</p><ol start="3"><li><p>apt-get install nginx<br>安装nginx</p></li><li><p>配置nginx</p></li></ol><p>service nginx restart;<br>killall -9 uwsgi<br>uwsgi –ini /home/ubuntu/DockerDjangoTest/docker-django-test-uwsgi.ini;<br>tail -100f /var/log/nginx/access.log;</p><p>aws 172.31.18.194:8888</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英-文_Growing_Neural_Cellular_Automata</title>
      <link href="/2020/02/18/%E8%8B%B1-%E6%96%87-Growing-Neural-Cellular-Automata/"/>
      <url>/2020/02/18/%E8%8B%B1-%E6%96%87-Growing-Neural-Cellular-Automata/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://distill.pub/2020/growing-ca/" target="_blank" rel="noopener">Growing Neural Cellular Automata</a><br>神经细胞自动生长机</p><p>Differentiable Model of Morphogenesis<br>形态变化的微分模型</p><p>Most multicellular organisms begin their life as a single egg cell - a single cell whose progeny reliably self-assemble into highly complex anatomies with many organs and tissues in precisely the same arrangement each time.<br>大多数多细胞有机体生命起源于一个单细胞-单细胞的后代每次都可靠的自组装成高度复杂的解剖结构,其中许多器官和机构每次都使用完全同样的组织方式。</p><p>The ability to build their own bodies is probably the most fundamental skill every living creature possesses.<br>构建自己的躯体或许是每个物种具有的最基本的技能</p><p>Morphogenesis (the process of an organism’s shape development) is one of the most striking examples of a phenomenon called self-organisation<br>形态进化(一个有机体形体发展的过程)是称为自组织现象最明显的例子</p><p>Cells, the tiny building blocks of bodies, communicate with their neighbors to decide the shape of organs and body plans, where to grow each organ, how to interconnect them, and when to eventually stop.<br>细胞，人体的最小组成部分，通过和相邻细胞间的交流来决定机体的形状和人体的计划，每个器官生长的位置，他们之间如何交流，什么时候停止生长。</p><p>Understanding the interplay of the emergence of complex outcomes from simple rules and homeostatic feedback loops is an active area of research<br>从简单的规则和稳态的反馈回路中理解复杂结果出现的交互作用是一个活跃的研究领域</p><p>What is clear is that evolution has learned to exploit the laws of physics and computation to implement the highly robust morphogenetic software that runs on genome-encoded cellular hardware.<br>显而易见的是进化已经学习到利用物理规律和计算力来完成运行在记忆编码细胞的硬件上高度健壮的软件</p><p>This process is extremely robust to perturbations.</p><p>Even when the organism is fully developed, some species still have the capability to repair damage - a process known as regeneration.<br>即使当有机体完全发育，某些物种仍然具有自我修复损害的能力，这个叫做复生的过程</p><p>Some creatures, such as salamanders, can fully regenerate vital organs, limbs, eyes, or even parts of the brain! Morphogenesis is a surprisingly adaptive process.<br>某些生物，比如salamanders，可以完全再生重要的组织，腿，眼睛，甚至是部分大脑！形态变化是一个很惊奇的适应的过程。</p><p>Sometimes even a very atypical development process can result in a viable organism - for example, when an early mammalian embryo is cut in two, each half will form a complete individual - monozygotic twins!<br>有时，即使一个非常不同寻常的发育过程也能产生一个活得机体。例如，当一个早期的哺乳动物被切分成两个时，每个部分都将形成一个完整的个体，单卵双胞胎</p>]]></content>
      
      
      <categories>
          
          <category> 英-文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>超级数学建模-分形图形</title>
      <link href="/2020/02/17/%E8%B6%85%E7%BA%A7%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%87%A0%E4%B8%AA%E5%88%86%E5%BD%A2%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/17/%E8%B6%85%E7%BA%A7%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%87%A0%E4%B8%AA%E5%88%86%E5%BD%A2%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这也就是著名的“海岸线悖论”：一个有限的区域大不列颠岛，却有一个无限长的周长。</p></blockquote><a id="more"></a><p>两千多年来，几何学的研究主要集中在欧几里得几何上。<br>正因为如此，欧氏几何中由直线或曲线、平面或曲面、平直体或曲体所构成的各种几何形状，一直是人类认识自然物体形状的有力工具，还是各种学科的理论基础<br>以致于物理大佬伽利略断言：“大自然的语言是数学，它的标志是三角形、圆和其他几何图形”。<br>但，真的是这样吗？</p><p>其实不然，数学课堂上学到的几何如三角形、四边形等都是理想的状态。</p><p>在现实中，云不是球体，山不是圆锥体，海岸线不是圆，树皮不是光滑的，闪电传播的路径也不是直线。</p><p><img src="自然几何.jpg" alt="自然几何"></p><p>显然，面对这些不规则不光滑不连续的几何形体，“万能”的欧式几何并不管用的。</p><p>这些无法解释的现象，机智的数学家们早就发现了。但没办法，问题实在太怪异了，致使数学家们不得不花上一个世纪的时间来解决。</p><h4 id="数学怪物"><a href="#数学怪物" class="headerlink" title="数学怪物"></a>数学怪物</h4><ol><li>Weierstrass 函数<br>1872年7月18日，卡尔·维尔斯特拉斯（Karl Weierstrass）创造了第一个函数怪物： Weierstrass函数，狠狠打脸当时的数学家。</li></ol><p><img src="Weierstrass.jpg" alt="Weierstrass"><br>要知道，当时大部分数学家认为除了少数特殊的点以外，连续的函数曲线在每一点上总会有斜率。但Weierstrass函数却偏偏不走寻常路，在曲线上呈现“处处连续，处处不可微”。<br><img src="无限迭代的Weierstrass.jpg" alt="无限迭代的Weierstrass函数"></p><ol><li><p>皮亚诺曲线<br>1890年，意大利数学家皮亚诺（Piano）构造了一条违反数学直觉的曲线，该曲线自身并不相交，但是它却能通过一个正方形内部所有的点。<br><img src="皮亚诺曲线.jpg" alt="皮亚诺曲线"><br>换句话说，这条曲线就是正方形本身，拥有和正方形一样的面积。<br>![填满正方形的皮亚诺曲线](填满正方形的皮亚诺曲线.jpg<br>这只突如其来的曲线，正式打响了分形几何研究的第一炮。</p></li><li><p>Koch雪花<br>1904年，科赫在论文提出了一种周长比地球的直径要长的Koch雪花。<br>![Koch雪花](Koch雪花.jpg</p></li></ol><p>一般而言，我们在测量非分形曲线时，都是将其放大到足够大，再用直线拟合一小段曲线，在一小段范围内取一阶泰勒展开，近似为直线，最后求总长度。</p><p>但这样的方法，对分形曲线根本行不通。因为你会发现，分形图案是无限迭代的，无论缩放到多小，细节总会不断地出现。</p><p>因此理论上来说，Koch雪花的周长是无限大，但有趣的是，他的面积是有限的，用一个稍大的圆就能把它完全盖住。</p><p><img src="周长无限大的Koch雪花.jpg" alt="周长无限大的Koch雪花"></p><ol><li><p>Sierpinski三角形<br><img src="Sierpinski三角形.jpg" alt="Sierpinski三角形"></p></li><li><p>Sierpinski地毯<br><img src="Sierpinski地毯.jpg" alt="Sierpinski地毯"></p></li><li><p>LévyC曲线<br><img src="LévyC曲线.jpg" alt="LévyC曲线"></p></li></ol><h5 id="分形理论是如何诞生的"><a href="#分形理论是如何诞生的" class="headerlink" title="分形理论是如何诞生的"></a>分形理论是如何诞生的</h5><p>无法被解决的怪物问题持续了一个多世纪，直至Benoit Mandelbrot的出现。1967年，刚刚萌生分形思想的他发表了题为《英国的海岸线有多长》的划时代论文.<br><img src="海岸线.jpg" alt="海岸线"></p><p>此文一出，学界众说纷纭，其中就有不少反驳的声音，“憨憨，长度问题测量不就完事了吗？”</p><p>的确，长度问题就是要测量。但是Mandelbrot并不是要测出长度，而是想反映一个问题：任何人对于海岸线长度的答案，会因他们使用最小测量单位的不同从而得到不同的答案。</p><p>试想一下，当我们100公里为单位测量英国的海岸线长度，我们会使用到28个单位，也就是2800公里的答案；但如果把最小单位缩小至50公里，则会使用到68个单位，从而得到3400公里的答案，比前一个答案整整多出了600公里。</p><p>换言之，若用更小的测量单位，比如是原子，你将会得到一个无穷大的答案。</p><p><img src="测量海岸线.jpg" alt="测量海岸线"></p><blockquote><p>这也就是著名的“海岸线悖论”：一个有限的区域大不列颠岛，却有一个无限长的周长。</p></blockquote><h4 id="分型的实际意义"><a href="#分型的实际意义" class="headerlink" title="分型的实际意义"></a>分型的实际意义</h4><p>无论是生物学、天体物理，还是材料学、计算机学等等，几乎所有领域都有分形理论的身影。</p><p>先说前面提到的Sierpinski三角形，早些年就被应用在收集和wifi系统中。</p><p>原因很简单，分形天线的自相似结构使它们能够在一定频率范围内进行接收和发送。<br><img src="wifi.jpg" alt="wifi"></p><p>还有，在计算机图像处理方面，分形的进展极大地丰富了计算机图形学的内容。</p><p>这其中，就包括对地理地形进行迭代建模，构建自然结构。</p><p><img src="计算机建模.jpg" alt="计算机建模"></p><p>另外，分形甚至可以帮助计算机更好散热。</p><p>利用人体血管的分形图案，俄勒冈州立大学的工程师开发出可以被刻蚀到硅芯片中的分形图案，以使冷却液（例如液氮）均匀地流过芯片表面并保持其冷却。</p><p><img src="散热.jpg" alt="散热"></p><p>又比如说，在医学上的分形应用。</p><p>很多时候，借助CT扫描和MRI机器等现代成像设备生成的大量的数据，即使是训练有素的专家，也没有办法又快速又准确弄清所有数据。</p><p>但有了分形理论就不一样了，因为人体内到处都是分形，我们可以使用分形数学来量化，描述和诊断，以达到治愈疾病的目的。</p><p>其中，我们可以根据健康肺和患病肺之间分形维数的不同，对疾病采取自动检测。</p><p>又比如说，在工程学上，工程师会采用分形理论构建高强度电缆，从而实现巨型悬索桥的建造。</p><p><a href="https://mp.weixin.qq.com/s/QGxiShT2swPv5YAejl5B3Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QGxiShT2swPv5YAejl5B3Q</a></p>]]></content>
      
      
      <categories>
          
          <category> 超级数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1008 Elevator</title>
      <link href="/2020/02/17/PAT-1008-Elevator/"/>
      <url>/2020/02/17/PAT-1008-Elevator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805511923286016" target="_blank" rel="noopener">1008 Elevator </a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定电梯上行下行以及等待需要处理的时间，给定电梯所要执行的序列，计算处理完这个序列所要花费的时间</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; iN;</span><br><span class="line">    <span class="keyword">int</span> iFloor;</span><br><span class="line">    <span class="keyword">int</span> iLastFloor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iFloor;</span><br><span class="line">        <span class="keyword">int</span> iStep = iFloor - iLastFloor;</span><br><span class="line">        <span class="keyword">if</span>(iStep &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iCost += iStep * <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            iCost -= iStep * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iLastFloor = iFloor;</span><br><span class="line"></span><br><span class="line">        iCost += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; iCost &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1007 Maximum Subsequence Sum</title>
      <link href="/2020/02/17/PAT-1007-Maximum-Subsequence-Sum/"/>
      <url>/2020/02/17/PAT-1007-Maximum-Subsequence-Sum/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">1007 Maximum Subsequence Sum</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数列，计算每个这个序列最大子序列的和</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>计算每个点为终点的最大子序列和<br>maxSeqSum[i] = max(num[i], maxSeqSum[i - 1] + num[i])</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST_MAX_SUM_SEQUENCE</span>&#123;</span> <span class="comment">//记录最大子序列和</span></span><br><span class="line">    <span class="keyword">int</span> iStartIndex;</span><br><span class="line">    <span class="keyword">int</span> iEndIndex;</span><br><span class="line">    <span class="keyword">int</span> iSum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iK;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> szNum[iK];</span><br><span class="line">    ST_MAX_SUM_SEQUENCE stMaxSumSequence[iK]; <span class="comment">//记录每个位置子序列和</span></span><br><span class="line">    ST_MAX_SUM_SEQUENCE stMaxSum; <span class="comment">//记录和最大的子序列</span></span><br><span class="line">    stMaxSum.iStartIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSum.iEndIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;szNum[<span class="number">0</span>];</span><br><span class="line">    stMaxSum.iSum = szNum[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iStartIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iEndIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iSum = szNum[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; iK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; szNum[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(szNum[i] + stMaxSumSequence[i - <span class="number">1</span>].iSum &gt;= szNum[i])</span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSumSequence[i].iStartIndex = stMaxSumSequence[i - <span class="number">1</span>].iStartIndex;</span><br><span class="line">            stMaxSumSequence[i].iEndIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iSum = szNum[i] + stMaxSumSequence[i - <span class="number">1</span>].iSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSumSequence[i].iStartIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iEndIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iSum = szNum[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stMaxSum.iSum &lt; stMaxSumSequence[i].iSum)</span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSum.iStartIndex = stMaxSumSequence[i].iStartIndex;</span><br><span class="line">            stMaxSum.iEndIndex = stMaxSumSequence[i].iEndIndex;</span><br><span class="line">            stMaxSum.iSum = stMaxSumSequence[i].iSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stMaxSum.iSum &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[iK - <span class="number">1</span>] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; stMaxSum.iSum &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[stMaxSum.iStartIndex] &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[stMaxSum.iEndIndex] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1006 Sign In and Sign Out</title>
      <link href="/2020/02/17/PAT-1006-Sign-In-and-Sign-Out/"/>
      <url>/2020/02/17/PAT-1006-Sign-In-and-Sign-Out/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805516654460928" target="_blank" rel="noopener">1006 Sign In and Sign Out</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一些列学生到达和离开时间，找到最早到和最晚走的学生</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>太简单</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iM;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iM);</span><br><span class="line">    <span class="built_in">string</span> strStudentId;</span><br><span class="line">    <span class="built_in">string</span> strSignIn;</span><br><span class="line">    <span class="built_in">string</span> strSignOut;</span><br><span class="line">    <span class="built_in">string</span> strMinSignInId;</span><br><span class="line">    <span class="built_in">string</span> strMinSignInTime = <span class="string">"24:00:00"</span>;</span><br><span class="line">    <span class="built_in">string</span> strMinSignOutId;</span><br><span class="line">    <span class="built_in">string</span> strMaxSignOutTime = <span class="string">"00:00:00"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iM; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId &gt;&gt; strSignIn &gt;&gt; strSignOut;</span><br><span class="line">        <span class="comment">//cout&lt;&lt; strMinSignInId &lt;&lt; strMinSignOutId &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(strMinSignInTime &gt;= strSignIn)</span><br><span class="line">        &#123;</span><br><span class="line">            strMinSignInId = strStudentId;</span><br><span class="line">            strMinSignInTime = strSignIn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strMaxSignOutTime &lt;= strSignOut)</span><br><span class="line">        &#123;</span><br><span class="line">            strMinSignOutId = strStudentId;</span><br><span class="line">            strMaxSignOutTime = strSignOut;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; strMinSignInId &lt;&lt; <span class="string">" "</span> &lt;&lt; strMinSignOutId &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1005 Spell It Right</title>
      <link href="/2020/02/17/PAT-1005-Spell-It-Right/"/>
      <url>/2020/02/17/PAT-1005-Spell-It-Right/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805519074574336" target="_blank" rel="noopener">1005 Spell It Right</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数，求解这个数各个数位相加的结果，结果输出英文</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>数位求和相加</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> szIntergerToEnglish[<span class="number">10</span>] =&#123;<span class="string">"zero"</span>,<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span>,<span class="string">"six"</span>,<span class="string">"seven"</span>,<span class="string">"eight"</span>,<span class="string">"nine"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szNum[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, szNum);</span><br><span class="line"><span class="keyword">int</span> iSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">strlen</span>(szNum); i++)</span><br><span class="line">&#123;</span><br><span class="line">    iSum += szNum[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> szPrintNum[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> iSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(iSum != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    szPrintNum[iSize] = iSum % <span class="number">10</span>;</span><br><span class="line">    iSum = iSum / <span class="number">10</span>;</span><br><span class="line">    iSize++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;szIntergerToEnglish[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; szIntergerToEnglish[szPrintNum[iSize - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = iSize - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">" "</span> &lt;&lt; szIntergerToEnglish[szPrintNum[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1004 Counting Leaves</title>
      <link href="/2020/02/14/PAT-1004-Counting-Leaves/"/>
      <url>/2020/02/14/PAT-1004-Counting-Leaves/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>就是求解树结构的每一层的叶子节点的树木，使用宽度搜索</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mapNodeLevel; <span class="comment">//记录节点所在层数</span></span><br><span class="line"><span class="keyword">int</span> iMaxLevel = <span class="number">0</span>; <span class="comment">//记录最大层数</span></span><br><span class="line"><span class="keyword">int</span> szNoLeafNode[<span class="number">100</span>]; <span class="comment">//记录每层没有孩子的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>, M;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; mapTree;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strRoot;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; strRoot;</span><br><span class="line">        <span class="keyword">int</span> iK;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iK;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecChild;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; iK; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> strChild;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; strChild;</span><br><span class="line">            vecChild.push_back(strChild);</span><br><span class="line">        &#125;</span><br><span class="line">        mapTree[strRoot] = vecChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; queNode;</span><br><span class="line">    queNode.push(<span class="string">"01"</span>);</span><br><span class="line">    mapNodeLevel[<span class="string">"01"</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(queNode.empty() != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strFrontNode = queNode.front();</span><br><span class="line">        queNode.pop();</span><br><span class="line">        <span class="keyword">if</span>(mapTree[strFrontNode].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            szNoLeafNode[mapNodeLevel[strFrontNode]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        iMaxLevel = <span class="built_in">max</span>(iMaxLevel, mapNodeLevel[strFrontNode]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapTree[strFrontNode].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mapNodeLevel[mapTree[strFrontNode][i]] = mapNodeLevel[strFrontNode] + <span class="number">1</span>;</span><br><span class="line">            queNode.push(mapTree[strFrontNode][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, szNoLeafNode[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= iMaxLevel; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, szNoLeafNode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1003_Emergency</title>
      <link href="/2020/02/13/PAT-1003-Emergency/"/>
      <url>/2020/02/13/PAT-1003-Emergency/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">1003 Emergency</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定每个城市间的距离和每个城市可获得的助手数量，寻找最短的路径以及能获得最多的助手数</p><a id="more"></a><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题就是求解最短路径，只是在求解的过程中需要记录有几个最短路径，以及在所有最短路径中权重最大的值。<br>求解最短路径使用的是Dijkstra算法，在这道题中，需要做一下变化记录下最短路径数，和最大权重</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, C1, C2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N &gt;&gt;M &gt;&gt;C1 &gt;&gt; C2;</span><br><span class="line">    <span class="keyword">int</span> hands[N]; <span class="comment">// 城市助手数量</span></span><br><span class="line">    <span class="keyword">int</span> roads[N][N]; <span class="comment">// 两座城市的路费</span></span><br><span class="line">    <span class="keyword">int</span> visited[N]; <span class="comment">//该城市是否已经访问</span></span><br><span class="line">    <span class="keyword">int</span> shortRoads[N]; <span class="comment">//最短路径长度</span></span><br><span class="line">    <span class="keyword">int</span> shortRoadsNum[N]; <span class="comment">//最短路径数量</span></span><br><span class="line">    <span class="keyword">int</span> maxHands[N]; <span class="comment">//到该城市最多的人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;hands[i];</span><br><span class="line">        visited[i] = <span class="number">0</span>; <span class="comment">//初始化所有城市未访问</span></span><br><span class="line">        shortRoads[i] = <span class="number">-1</span>; <span class="comment">//初始化所有城市最短路径都不存在</span></span><br><span class="line">        shortRoadsNum[i] = <span class="number">0</span>; <span class="comment">// 初始化所有的城市最短路径数量为0</span></span><br><span class="line">        maxHands[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            roads[i][j] = <span class="number">-1</span>; <span class="comment">//初始化两座城市不可达</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c1, c2, L;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; L;</span><br><span class="line">        roads[c1][c2] = L;</span><br><span class="line">        roads[c2][c1] = L;</span><br><span class="line">    &#125;</span><br><span class="line">    shortRoads[C1] = <span class="number">0</span>;</span><br><span class="line">    shortRoadsNum[C1] = <span class="number">1</span>;</span><br><span class="line">    maxHands[C1] = hands[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nowMinRoadCity = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> nowMinRoad = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="comment">//寻找当前距离最小的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="number">0</span> &amp;&amp; shortRoads[j] != <span class="number">-1</span>)<span class="comment">//目前不可达的城市不考虑</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nowMinRoad == <span class="number">-1</span> || nowMinRoad &gt; shortRoads[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nowMinRoad = shortRoads[j];</span><br><span class="line">                    nowMinRoadCity = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nowMinRoad == <span class="number">-1</span>) <span class="comment">//如果没找到未访问过的城市的最小路径则结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//        cout&lt;&lt;"nowMinRoadCity:" &lt;&lt; nowMinRoadCity &lt;&lt;endl;</span></span><br><span class="line">        visited[nowMinRoadCity] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="comment">//在最小节点的基础上更新路径</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="number">0</span>) <span class="comment">//</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(shortRoads[j] == <span class="number">-1</span>) <span class="comment">//当前城市处于不可达的状态</span></span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">if</span>(roads[nowMinRoadCity][j] != <span class="number">-1</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       shortRoads[j] = shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j];</span><br><span class="line">                       shortRoadsNum[j] = shortRoadsNum[nowMinRoadCity] ;</span><br><span class="line">                       <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                       &#123;</span><br><span class="line">                           maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(roads[nowMinRoadCity][j] != <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(shortRoads[j] &gt; shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            shortRoads[j] = shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j];</span><br><span class="line">                            shortRoadsNum[j] = shortRoadsNum[nowMinRoadCity];</span><br><span class="line">                            <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(shortRoads[j] == shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            shortRoadsNum[j] += shortRoadsNum[nowMinRoadCity];</span><br><span class="line">                            <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">//                cout&lt;&lt; "shortRoads " &lt;&lt;j &lt;&lt; " " &lt;&lt;shortRoads[j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; shortRoadsNum[C2]&lt;&lt; <span class="string">" "</span> &lt;&lt; maxHands[C2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PAT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-镜像基础操作</title>
      <link href="/2020/02/12/docker-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/12/docker-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>列出镜像<br>docker images</p></li><li><p>查看镜像<br>docker inspect</p></li><li><p>删除镜像<br>docker rmi</p></li><li><p>查找镜像<br>docker search</p></li><li><p>拉去镜像<br>docker pull</p></li><li><p>推送镜像<br>docker push</p></li></ol><p>例子docker push qlassroom_ai_dev</p><ol start="7"><li>构建镜像<br>docker commit</li></ol><p>利用dockerfile 构建镜像<br>docker build</p><ol start="8"><li><p>dockerfile 构建镜像</p></li><li><p>docker tag 规范镜像名字<br>docker tag qlassroom_ai_dev:latest 872204778/qlassroom_dev:v1<br>qlassroom_ai_dev 为原镜像名称<br>latest: 为原镜像标签</p></li></ol><p>872204778： 用户名<br>qlassroom_dev：新镜像名<br>v1:新标签</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影-肖申克的救赎</title>
      <link href="/2020/02/11/%E5%BD%B1-%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/"/>
      <url>/2020/02/11/%E5%BD%B1-%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E.jpeg" alt="肖申克的救赎"><br>2020-02-10，大约是23:30 我看完了肖申克的救赎，总共用了两天时间，分三段看完的。<br>  看这部电影的初衷就是想看看评分如此之高，备受好评的电影是怎么做到的。经典为何为经典。<br>看的过程中并没有全身心的投入去看，因为像这种偏文艺的电影，我现在还不能做到心无旁骛的陶醉其中，然而虽然看的时候有点懈怠，但是经典的电影还是在不经意间引起我的深思。<br>  首先是主人公作为Andy作为一个在社会上有头有脸的人物，却沦为阶下囚，并受到了些凌辱。这样我想到，适应环境，利用规则，才是生存或者更好生活的的法则。狱警可以肆无忌惮的对囚徒进行殴打，因为在这个小小的“王国”下，他们就是规则的制定者。他们可以毫无理由的分配给囚徒各种工作，即使很地下的工作，在囚徒看来都可能是一种荣幸。</p><p>  其次是知识的作用，Andy有知识，他利用他的知识能力在狱中可以得到与其他囚徒不一样的待遇，同时他又利用他的知识能力来教化其他狱友。从某点上来考虑，这个情节很激励人心，教化自己普渡他人，这是一个自带光芒的人啊，然而转念一想，这情节有些突兀。在一个没有自由，或者说是在一个狭小的几乎会永远生活在这没有“文明”的地方，真的会有人崇尚知识吗。这就好比生活在三维世界的人，可能只是四维生物的打工仔，我们所谓的知识，只是四维生物赏赐给我们的低级的趣味。</p><p>  Brooks从监狱里出来之后，选择了自杀，因为他很难再适应外面世界的规则。</p><p>  以后再看一次</p><hr><p>下面为阅读的影评<br>肖申克的救赎与信念，自由，友谊有关。</p><h5 id="【信念】"><a href="#【信念】" class="headerlink" title="【信念】"></a>【信念】</h5><p>Red说，希望是危险的东西，是精神苦闷的根源。重重挤压下的牢狱里待了三十年的他的确有资格这么说。因为从进来的那一天起，狱长就说过「把灵魂交给上帝，把身体交给我」。 他除了能弄来香烟和印着裸女的扑克牌，其他任何异动在这个黑暗的高墙之内似乎都无法生长。</p><p>然而，Andy却告诉他，「记住，希望是好事——甚至也许是人间至善而美好的事永不消失」。</p><p>所以Andy能够用二十年挖开瑞德认为六百年都无法凿穿隧洞。当Andy终于排除五百码恶臭的污水管道，站在瓢泼大雨中情不自禁的时候，我们仿佛看到信念刺穿重重黑幕，在暗夜中打了一道夺目的霹雳。亮光之下，我们怯懦的灵魂在Andy张开的双臂下现行，并且颤抖。</p><p><em>庸常生活里的我们，似乎已经习惯了按步就按，习惯了先说「不可能」，习惯了没有奇迹，习惯了习惯了。</em></p><p>我们应该试着留住一些信念，在他们丧失殆尽之前。它们也许最终无法实现，也许无法让我们或者更有意义的活着，甚至对于我们自己而言，它们只会愈加给我们带来更多的虚无感。然而我知道我有多需要这样的虚伪与自欺，因为你可以说我在做梦，但我不会是仅有的一个。</p><h5 id="【自由】"><a href="#【自由】" class="headerlink" title="【自由】"></a>【自由】</h5><p>我到今天也不明白，那两个意大利的女人在唱什么。事实上，我也不想去明白。有些东西不说更好。我想那是非笔墨可形容的美貌，然而却令你如此心伤。</p><p>那声音飞扬，高远入云，超过任何在禁锢中的囚犯的梦。仿佛一只美丽的小鸟，飞入这灰色的鸟笼，让那些围墙消失，另铁窗中的所有犯人，感到一刻的自由。</p><p>当Andy不顾一切的在监狱的喇叭里放《费加罗的婚礼》时。正在广场上防风的囚徒们和那些狱警，它们静立当地，抛却所有愤懑，狠毒，怨恨，沐浴着从未觉得如此自由的阳光。莫扎特的乐声铺洒在这些人的身上，来自俗世的美妙音符似乎将他们都濯洗的纯净无比。</p><p><em>强者自救，圣者渡人。</em> 修屋顶的时候，Andy为大家争取来啤酒，事实上是为大家争取到的那种像修缮自家的屋顶一般自由的存在，所以他不喝酒，微笑却带着巨大的幸福。播放《费加罗的婚礼》也是要唤醒它们已经丧失殆尽的自由感。</p><p>然而强者终究是少数。自由面前，更多人选择禁锢。在监狱图书馆待了五十年的Brooks，为了不被假释，竟然想通过伤害狱友来达到留在监狱的目的。自由本就是人们向往和追求的东西。可是Brooks却早已在监狱的规则下规则了自己，没有规则，他无法生存。</p><p>「监狱的高墙是在是很有趣。刚入狱时，你痛恨周围的高墙；慢慢的，你习惯生活在其中，最终你会发现自己不得不依靠它来生存。这就是体制化」假Red之口，斯蒂芬金直指卑微</p><p>Brooks得到了身体的自由，灵魂却早已经无法挽回的体制化。他终于没有能摆脱对自由无法适应的困境，悬梁自尽。而睿智如瑞德，在出狱之后也悲哀的发现，自己竟然连撒尿都要向经理报告，否则一滴都挤不出来。他也考虑如何违规以便回到监狱，甚至考虑与Brooks一样离开。</p><p>要么忙着生活，要么忙着等死。步履匆匆的人们也许应该偶尔驻足，跳出来看看自己的模样。我们终会知道，<em>习惯与服从规则的人们将付出巨大的代价来习惯本来属于每一个人的自由</em></p><h5 id="【友谊】"><a href="#【友谊】" class="headerlink" title="【友谊】"></a>【友谊】</h5><p>Red和Andy那种置放在高墙之下的友谊，似乎比我们纷繁俗世中的友情来的更加纯粹和干净。他们都是内敛的人，然而洞悉一切，心意切合。他们终于相会在太平洋小岛的阳光沙滩上。</p>]]></content>
      
      
      <categories>
          
          <category> 影 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-基本容器操作</title>
      <link href="/2020/02/11/docker-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/11/docker-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h3><ol><li><p>启动容器<br>docker run IMAGE [COMMAND] [ARG…]<br>例： 启动容器并输出hello world<br>docker run ubuntu echo “hello world”</p></li><li><p>启动交互式容器<br>docker run -i -t IMAGE /bin/bash<br>例：<br>docker run -i -t ubuntu /bin/bash</p></li><li><p>查看容器列表<br>docker ps</p></li><li><p>查看容器详情<br>docker inspect</p></li><li><p>重新启动已经停止的容器<br>docker start -i</p></li><li><p>删除停止的容器<br>docker rm cool_sammet</p></li><li><p>以守护形式运行容器<br>docker run -i -t IMAGE /bin/bash<br>CTRL + Q 退出</p></li><li><p>再次进入守护形式运行的容器<br>docker attach</p></li><li><p>使用run 启动守护形式容器<br>docker run -d IMAGE [COMMAND] [ARG…]<br>例：docker run –name dc1 -d ubuntu /bin/sh -c “while true; do echo hello world; sleep 1; done”</p></li><li><p>查看容器日志<br>docker logs [-f] [-t] [–tail] 容器名</p></li><li><p>查看容器的进程<br>docker top 容器名</p></li><li><p>在运行容器中启动新的进程<br>docker exec [-d][-i][-t] 容器名 [COMMAND][ARG…]<br>例：docker exec -i -t dc1 /bin/bash</p></li><li><p>停止守护容器<br>docker stop 发送信号给容器，等待其停止<br>docker kill 直接停止容器</p></li><li><p>容器保存为镜像<br>docker commit 容器名 镜像名</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PAT-1002 A+B for Polynomials</title>
      <link href="/2020/02/11/PAT-1002-A-B-for-Polynomials/"/>
      <url>/2020/02/11/PAT-1002-A-B-for-Polynomials/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">1002 A+B for Polynomials</a></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定两个多项式的系数和项,将他们合并</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h2 id="将系数相同的项累加，累加后若该项为0则删除"><a href="#将系数相同的项累加，累加后若该项为0则删除" class="headerlink" title="将系数相同的项累加，累加后若该项为0则删除"></a>将系数相同的项累加，累加后若该项为0则删除</h2><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><ol><li>项为0的不输出</li><li>按照系数大小逆向输出</li></ol><hr><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; poly;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> poly_i = <span class="number">0</span>; poly_i &lt; <span class="number">2</span>; poly_i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">int</span> N;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> Ni;</span><br><span class="line">          <span class="keyword">double</span> aN;</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt; Ni &gt;&gt; aN;</span><br><span class="line">          <span class="keyword">if</span>(poly.<span class="built_in">find</span>(Ni) != poly.<span class="built_in">end</span>())</span><br><span class="line">          &#123;</span><br><span class="line">              poly[Ni] += aN;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              poly[Ni] = aN;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(poly[Ni] == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              poly.erase(Ni); <span class="comment">// 删除项为0</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; poly.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;::reverse_iterator rit;</span><br><span class="line">  <span class="keyword">for</span>(rit = poly.rbegin(); rit != poly.rend(); rit++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, rit-&gt;first, rit-&gt;second); <span class="comment">//保留1位小数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tf-keras和keras</title>
      <link href="/2020/02/10/tf2-keras%E5%92%8Ckeras/"/>
      <url>/2020/02/10/tf2-keras%E5%92%8Ckeras/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>keras 是什么</p><ul><li>基于python的高级神经网络API</li><li>以Tensorflow，CNTK或者Theano为后段运行，keras必须有后端才可以运行</li><li>极方便与快速实验，帮助用户以最少的时间验证自己的想法<br>Tensorflow-keras是什么<ul><li>Tensorflow对keras API的规范实现</li><li>比以Tensorflow为后段的keras，Tensorflow-keras与Tensorflow结合更加紧密</li><li>实现在tf.keras空间下</li></ul></li></ul><p>Tf-keras 和 keras的联系</p><ul><li>基于同一套API<ul><li>keras程序可以通过导入方式转换为tf.keras程序</li><li>反之不成立，因为tf.keras有其他特性<ul><li>相同的JSON和HDF5模型序列化格式和语义</li></ul></li></ul></li></ul><p>Tf-keras 和 keras的区别</p><ul><li>Tf.keras全面支持eager mode<ul><li>只是用keras.Sequential和keras.Model时没有影响</li><li>自动以的Model内部运算逻辑时没有影响<ul><li>Tf低层API可以使用keras的model.fit等抽象</li></ul></li></ul></li><li>Tf.keras支持基于tf.data的模型训练</li><li>Tf.keras支持TPU训练</li><li>Tf.keras支持tf.distribution的分布式策略</li><li>Tf.keras可以与Tensorflow中的estimator集成</li><li>Tf.keras可以保存为SaveModel</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tensorflow2.0 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习-概率分布</title>
      <link href="/2020/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"/>
      <url>/2020/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>疫情下的元宵节</title>
      <link href="/2020/02/09/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%85%83%E5%AE%B5%E8%8A%82/"/>
      <url>/2020/02/09/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%85%83%E5%AE%B5%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 2020年正月十五-元宵节</p><p> 今年春节非比寻常，在武汉瘟疫肆虐的情况下，每个人都被限制在了室内。出门都是口罩护身。往日的走街串巷，拜亲戚，聚会的习俗都被瘟疫压制了。</p><p> 这是2020年正月16的疫情数据。<br> <img class="epidemic_data.jpeg [width] [height] &quot;title text&quot; &quot;alt text&quot;"></p><p> <img src="epidemic_data.jpeg" alt="患病人数"><br> <img src="epidemic_data_map.jpeg" alt="各省统计"><br> 总确诊人数将近4万了，很恐怖的数据了。<br> 湖北，广东，浙江都已经变黑了，河南今天也变黑了。</p><p> <img src="we.jpeg" alt="我们"><br> 在这样的疫情下，我和他在一起过的元宵节，带着口罩背对着正月十五的月亮，在一起就很开心</p>]]></content>
      
      
      <categories>
          
          <category> 文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二维码登陆原理</title>
      <link href="/2020/02/09/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E9%99%86%E5%8E%9F%E7%90%86/"/>
      <url>/2020/02/09/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E9%99%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><ol><li><p>网页端和服务器配合逻辑<br>首先用户打开网站登陆界面时，向服务器发送获取登陆二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，过期后，用户登陆二维码需要进行刷新重新获取。</p><p>同时，将这个key值和本公司的验证码字符串合在一起，生成一个二维码图片，将后将二维码图片和uuid一起返回给浏览器。</p><p>浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次登陆是否成功的请求。请求中携带有uuid作为当前页面的标识符。</p></li><li><p>手机端与服务器端配合逻辑<br>浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：打开扫一扫进行登陆。</p><p>用户扫描二维码后，就可以得到一个验证码和一个uuid。</p><p>手机端访问服务器，参数中会有token，手机端服务器可以从中得到用户的userId。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登陆请求。</p><p>服务器收到登陆请求后，返回登陆确认信息给手机端。</p><p>手机端收到返回后，进行登陆确认。确认后再次返送请求，服务器拿到userId和uuid后，将用户的userId作为value存入redis</p></li><li><p>登陆确认后，浏览器逻辑</p></li></ol><p>浏览器每秒发送时候登陆成功的请求，确认登陆成功后，可以获取登陆用户的userId。</p><p>流程图如下：<br><img src="qrcode_login.jpg" alt="qrcode login"></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>李文亮医生，再见</title>
      <link href="/2020/02/07/%E6%9D%8E%E6%96%87%E4%BA%AE%E5%8C%BB%E7%94%9F%E5%86%8D%E8%A7%81/"/>
      <url>/2020/02/07/%E6%9D%8E%E6%96%87%E4%BA%AE%E5%8C%BB%E7%94%9F%E5%86%8D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我走了-带着一张训诫书！"><a href="#我走了-带着一张训诫书！" class="headerlink" title="我走了,带着一张训诫书！"></a>我走了,带着一张训诫书！</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=491833132&auto=1&height=66"></iframe><iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=e90721dc87291f4510c03309e249411a&tvId=12381616400&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="100%"></iframe><p>  <img src="LWL.jpg" alt="李文亮医生"><br>  天还没亮，我走了</p><p>  我走的时候，渡口很黑，无人相送，只有几朵雪花落在我的眼底。我一思念，它们便从我的眼眶滑落。</p><p>  黑夜真黑，黑的让我想不起万家灯火。我一生追求光，我自诩很明亮，但我拼尽全力，却什么都没点亮</p><p>  谢谢你们，昨夜冒着风雪来看我的人！谢谢你们整夜不眠，像守望亲人一样把我守望！可是脆弱人间，没有奇迹。</p><p>  我原本平凡而渺小，有一天我被上帝选中，托我将他的旨意转告苍生。</p><p>  我小心翼翼的说了，于是，有人劝我不要惊扰太平，他们说：你没看见满城繁华开得正艳吗！</p><p>  为了让全世界相信现世安稳，我只好守口如瓶，还用鲜红的指印保证 – 我说的话都是童话，带花冠的致命皇后从来不曾下凡作乱。</p><p>  就这样，天下继续熙熙攘攘，谁也不知道，巨大的悲伤即将把城门紧锁。</p><p>  后来，上帝大怒，山河失色，我也病了。再后来，我的家人都病了。我们就像千万片雪花一样，你一片，我一片，各自凋零。</p><p>  我曾以为，只待春江水暖，我和家人便能再度重相逢。到那时，我们就坐在鹅黄的油菜花田，把花儿一朵一朵的数，把日子一分一秒地过。</p><p>  等啊等啊，我只等来了昨夜小雪，上帝摸摸我的头，爱怜地说：乖，跟我走吧，人间不值得！</p><p>  我一听就泪如雨下，虽然人间苦寒，上帝温暖。但我怕过了奈何桥，偶尔回望吾乡，再也望不见一家老小。</p><p>  其实，我的风骨早就被拍死在一张保证书上。我继续阳光朗照地活着，歌颂生命，赞美松柏，那是因为我对这土地爱得深沉。而今，我的肉身也死了。</p><p>  在我成为一粒尘埃之前，我又静静地怀想了一遍故乡的黑土白云。多想回到小时候啊，风是尽情飞舞的，雪是洁白无瑕的。</p><p>  活着真好，可我死了。我再也无法抚摸亲人的脸庞，再也无法带孩子去看东湖春晓，再也无法陪父母去看武大的樱花，再也无法把风筝放到白云深处。</p><p>  我曾依稀梦见我尚未出世的孩子，他一出生就眼含热泪，在人潮人海中把我寻找。对不起，孩子！我知道你只想要一个平凡的父亲，而我却做了一个平民英雄。</p><p>  天快亮了，我要走了。带着一张保证书，那是我此生唯一的行囊。</p><p>  谢谢世间所有懂我怜我爱我的人，我知道你们都在黎明等候，等我越过山丘！可是，我太累了。</p><p>  此生，我不想重于泰山，也不怕轻于鸿毛。我唯一的心愿，就是希望冰雪消融之后，众生依然热爱大地，依然相信祖国。</p><p>  等到春雷滚滚，如果有人还想纪念我，请给我立一个小小的墓碑吧！不必伟岸，只须证明我曾来过这个世界，有名有姓，无知无畏。</p><p>  那么，我的墓志铭只需一句话：他为苍生说过话</p>]]></content>
      
      
      <categories>
          
          <category> 文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>模版方法 Template</p><ul><li>动机: 某项任务有稳定的整体结构，但是各个子步骤有很多改变的需求</li><li>定义: 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以不改变一个算法的结构重定义该算法的特定步骤（只见树木不见森林）</li><li>处理思路: 利用虚函数的多态性</li></ul></li><li><p>策略模式 Strategy</p><ul><li>动机：在软件构件过程中，某些对象使用的算法可能多种多样，使用率小的算法也是一种性能负担</li><li>定义：定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户程序而变化</li><li>处理方法： 利用多态性</li></ul></li><li><p>观察者模式 Observer/Event</p><ul><li>动机：软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”，一个对象发生状态改变，所有依赖对象都将得到通知</li><li>定义：定义对象间一种一对多的依赖关系，以便一个对象的状态改变时，所有依赖于它的对象都得到通知和更新</li></ul></li><li><p>装饰模式 Decorator</p><ul><li>动机: 过度的使用继承来拓展对象的功能，由于继承为类型引入的静态特质，使得这种拓展方式缺乏灵活性，并且随着子类的增多，各种子类的组合会导致更多的子类膨胀</li><li>定义： 动态给一个对象增加额外的职责</li></ul></li><li><p>桥模式 Brige</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> technology </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
