<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>numpy-常用接口简述</title>
    <url>/2020/03/04/numpy-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用来存取多维对象数据</p>
<h4 id="numpy数组创建"><a href="#numpy数组创建" class="headerlink" title="numpy数组创建"></a>numpy数组创建</h4><p>arr = np.array([1,2,3])</p>
<h5 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h5><p>获取数据的维度</p>
<h4 id="dype"><a href="#dype" class="headerlink" title="dype"></a>dype</h4><p>获取数组的类型</p>
<h4 id="ndim"><a href="#ndim" class="headerlink" title="ndim"></a>ndim</h4><p>最外层维度</p>
<h4 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros()"></a>np.zeros()</h4><pre><code> np.ones()
 np.empty()
 np.arrage()
</code></pre><h4 id="astype"><a href="#astype" class="headerlink" title="astype()"></a>astype()</h4><p>  数据类型转换</p>
<h4 id="矢量化"><a href="#矢量化" class="headerlink" title="矢量化"></a>矢量化</h4><p>数组在不用写循环的情况下就能进行批量运算</p>
<h4 id="numpy数组的索引和切片"><a href="#numpy数组的索引和切片" class="headerlink" title="numpy数组的索引和切片"></a>numpy数组的索引和切片</h4><h4 id="二维数组的访问方式"><a href="#二维数组的访问方式" class="headerlink" title="二维数组的访问方式"></a>二维数组的访问方式</h4><h4 id="花式索引Fancy-indexing"><a href="#花式索引Fancy-indexing" class="headerlink" title="花式索引Fancy indexing"></a>花式索引Fancy indexing</h4><p>利用整数数组进行索引</p>
<h4 id="T-transpose"><a href="#T-transpose" class="headerlink" title="T, transpose"></a>T, transpose</h4><p>数组转置，轴兑换</p>
<h4 id="条件逻辑转数组"><a href="#条件逻辑转数组" class="headerlink" title="条件逻辑转数组"></a>条件逻辑转数组</h4><p>np.where</p>
<h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>sum mean std min max argmin argmax</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>sort</p>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>np.save np.load<br>numpy读取磁盘上的文本数据或者二进制数据<br>默认情况下会以未压缩的原始二进制格式保存在拓展名为.npy的文件中</p>
<h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p>dot 矩阵乘法<br>trace 计算对角线元素的和<br>det 计算矩阵的行列式<br>eig 计算矩阵特征值和特征向量<br>inv 计算矩阵的逆</p>
]]></content>
  </entry>
  <entry>
    <title>python-高阶函数</title>
    <url>/2020/03/04/python-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><p>func = lambda x: x + x</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><h4 id="python三大推导公式"><a href="#python三大推导公式" class="headerlink" title="python三大推导公式"></a>python三大推导公式</h4>]]></content>
  </entry>
  <entry>
    <title>算法-不用库函数计算立方根</title>
    <url>/2020/03/03/%E7%AE%97%E6%B3%95-%E4%B8%8D%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E7%AB%8B%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近遇到一道题<br>题目描述这样<br>计算一个数字的立方根，不使用库函数<br>麻烦的一点是输入是double类型<br>假若规定输入的是整形，那很好做了，遍历计算就好，但是浮点型有点懵，遍历是不行了,因为每一步的跨度是不知道的。<br>有想过先算原来浮点型的精度位数，然后以精度为遍历，貌似可行。但是感觉有点硬，不够优雅.<br>最后上网查看一下比较正常的做法，恍然大雾，忘了泰勒级数了</p>
<p>求解 $ f(x) = x^3 = 0 $<br>令<br>$ f(x)  =  x^3 - a  = 0 $<br>利用泰勒展开，即f(x)在$x_0$处的函数值为<br>$ f(x) = f(x_0) + f \prime(x_0)(x - x_0) = x_0^3 - a + 3x_0^2(x - x_0) $<br>$ x = \frac{2x_0^2 - a}{3x_0^2} $</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">abs</span>(x*x*x - n) &gt; <span class="number">1e-9</span>)</span><br><span class="line">        x = x - ((x*x*x - n) / (<span class="number">3</span>*x*x));</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是用二分法求解</p>
]]></content>
  </entry>
  <entry>
    <title>TF2-线性模型实战</title>
    <url>/2020/03/03/TF2-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 实战单输入神经元线性模型<br> <a id="more"></a><br> 线性模型</p>
<script type="math/tex; mode=display">y = 1.477 * x + 0.089</script><ol>
<li>采样数据<br>添加误差自变量 $ \epsilon $<script type="math/tex; mode=display">y = 1.477 * x + 0.089 + \epsilon , \epsilon ~ N(0, 0.0.01)</script></li>
</ol>
<p>通过循环进行100次，每次从区间[-10,10]的均匀分布U(0,1)中随机采样x<br>同时从N(0, 0.1^2)随机采样噪声 $ \epsilon $<br>得到y<br>保存到Numpy数组中，得到$ D^{train} $</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    x = np.random.uniform(<span class="number">-10.</span>, <span class="number">10.</span>)</span><br><span class="line">    eps = np.random.normal(<span class="number">0.</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = <span class="number">1.477</span> * x + <span class="number">0.089</span> + eps</span><br><span class="line">    data.append([x, y])</span><br><span class="line">data = np.array(data)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>DL-深度学习简述</title>
    <url>/2020/03/03/DL-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度学习应用"><a href="#深度学习应用" class="headerlink" title="深度学习应用"></a>深度学习应用</h2><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><h4 id="图片识别-Image-Classification"><a href="#图片识别-Image-Classification" class="headerlink" title="图片识别 Image Classification"></a>图片识别 Image Classification</h4><p>  神经网络输入为图片数据,输出值为当前样本属于每个类别的概率<br>  VGG系列, Inception系列, ResNet系列</p>
<h4 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测 Object Detection"></a>目标检测 Object Detection</h4><p>  通过算法自动检测出图片汇中物体的大致位置,并分类出物体信息<br>  RCNN， Fast RCNN， Mask RCNN，SSD，YOLO系列</p>
<h4 id="语义分割-Semantic-Segmentation"><a href="#语义分割-Semantic-Segmentation" class="headerlink" title="语义分割 Semantic Segmentation"></a>语义分割 Semantic Segmentation</h4><p>  通过算法自动分割并识别图片中的内容，可以将语义分割理解成每个像素点的分类问题，分析每个像素点属于物体的类别<br>  FCN， U-net， SegNet， DeepLab</p>
<h4 id="视频理解-Video-Understanding"><a href="#视频理解-Video-Understanding" class="headerlink" title="视频理解 Video Understanding"></a>视频理解 Video Understanding</h4><p>  视频分类，行为检测，视频主体抽取<br>  C3D，TSN， DOVF， TS_LSTM</p>
<h4 id="图片生成-Image-Generation"><a href="#图片生成-Image-Generation" class="headerlink" title="图片生成 Image Generation"></a>图片生成 Image Generation</h4><p>  通过学习真实图片的分布，获得高逼真的生成图片<br>  VAE系列，GAN系列</p>
<h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><h4 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h4><p>  Seq2Seq，BERT，GPT， GPT-2</p>
<h4 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h4><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><h4 id="虚拟游戏"><a href="#虚拟游戏" class="headerlink" title="虚拟游戏"></a>虚拟游戏</h4><h4 id="机器人-Roboitcs"><a href="#机器人-Roboitcs" class="headerlink" title="机器人 Roboitcs"></a>机器人 Roboitcs</h4><h4 id="自动驾驶-Autonomous-Driving"><a href="#自动驾驶-Autonomous-Driving" class="headerlink" title="自动驾驶 Autonomous Driving"></a>自动驾驶 Autonomous Driving</h4><h3 id="深度学习主流框架"><a href="#深度学习主流框架" class="headerlink" title="深度学习主流框架"></a>深度学习主流框架</h3><ul>
<li>TensorFlow<br>Google 推出 TensorFlow 2 正式版本，将以动态图优先模式运行，从而能够避免</li>
</ul>
<ul>
<li><p>PyTorch<br>是 Facebook 基于原有的 Torch 框架推出的采用 Python 作为主要开发语言的深度学习框架。采用命令式编程，使得搭建网络和 调试网络非常方便。</p>
</li>
<li><p>Keras<br>是一个基于 Theano 和 TensorFlow 等框架提供的底层运算而实现的高层框架， 提供了大量方便快速训练，测试的高层接口，对于常见应用来说，使用 Keras 开发效 率非常高。但是由于没有底层实现，需要对底层框架进行抽象，运行效率不高，灵活 性一般。</p>
</li>
<li><p>Torch<br>是一个非常优秀的科学计算库，基于较冷门的编程语言 Lua 开发。Torch 灵活性 较高，容易实现自定义网络层，这也是 PyTorch 继承获得的优良基因。但是由于 Lua 语言使用人群较小，Torch 一直未能获得主流应用。</p>
</li>
<li><p>Caffe<br>主要面向使用卷积神经网络的应用场合，并 不适合其他类型的神经网络的应用。Caffe 的主要开发语言是 C++，也提供 Python 语 言等接口，支持 GPU 和 CPU。<br>Caffe2 目前已经融入到 PyTorch 库中。</p>
</li>
<li><p>Scikit-learn<br>是一个完整的面向机器学习算法的计算库，内建了常见的传统机器学习算 法支持，文档和案例也较为丰富，但是 Scikit-learn 并不是专门面向神经网络而设计 的，不支持 GPU 加速，对神经网络相关层实现也较欠缺。</p>
</li>
<li><p>MXNET<br>由华人博士陈天奇和李沐等人开发，已经是亚马逊公司的官方深度学习框 架。采用了命令式编程和符号式编程混合方式，灵活性高，运行速度快，文档和案例 也较为丰富。</p>
</li>
<li><p>Theano<br>是最早的深度学习框架之一，由 Yoshua Bengio 和 Ian Goodfellow 等人开发， 是一个基于 Python 语言、定位底层运算的计算库，Theano 同时支持 GPU 和 CPU 运 算。由于 Theano 开发效率较低，模型编译时间较长，同时开发人员转投 TensorFlow 等原因，Theano 目前已经停止维护。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DL</category>
      </categories>
  </entry>
  <entry>
    <title>NLP-自然语言处理简述</title>
    <url>/2020/03/03/NLP-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="机器翻译"><a href="#机器翻译" class="headerlink" title="机器翻译"></a>机器翻译</h4><h4 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h4>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>CV-计算机视觉简述</title>
    <url>/2020/03/03/CV-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="图片识别-Image-Classification"><a href="#图片识别-Image-Classification" class="headerlink" title="图片识别 Image Classification"></a>图片识别 Image Classification</h4><p>  神经网络输入为图片数据,输出值为当前样本属于每个类别的概率<br>  VGG系列, Inception系列, ResNet系列</p>
<h4 id="目标检测-Object-Detection"><a href="#目标检测-Object-Detection" class="headerlink" title="目标检测 Object Detection"></a>目标检测 Object Detection</h4><p>  通过算法自动检测出图片汇中物体的大致位置,并分类出物体信息<br>  RCNN， Fast RCNN， Mask RCNN，SSD，YOLO系列</p>
<h4 id="语义分割-Semantic-Segmentation"><a href="#语义分割-Semantic-Segmentation" class="headerlink" title="语义分割 Semantic Segmentation"></a>语义分割 Semantic Segmentation</h4><p>  通过算法自动分割并识别图片中的内容，可以将语义分割理解成每个像素点的分类问题，分析每个像素点属于物体的类别<br>  FCN， U-net， SegNet， DeepLab</p>
<h4 id="视频理解-Video-Understanding"><a href="#视频理解-Video-Understanding" class="headerlink" title="视频理解 Video Understanding"></a>视频理解 Video Understanding</h4><p>  视频分类，行为检测，视频主体抽取<br>  C3D，TSN， DOVF， TS_LSTM</p>
<h4 id="图片生成-Image-Generation"><a href="#图片生成-Image-Generation" class="headerlink" title="图片生成 Image Generation"></a>图片生成 Image Generation</h4><p>  通过学习真实图片的分布，获得高逼真的生成图片<br>  VAE系列，GAN系列</p>
]]></content>
  </entry>
  <entry>
    <title>self-个人技术栈</title>
    <url>/2020/03/03/self-%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>语言类:<br> C++, Python, Java, Matlab, Js, C#, Delphi, VB, Swif</p>
<p>框架类:<br>  前端:<br>    React, Redux<br>  后端:<br>    Django, Spring MVC</p>
<p>服务器:<br>  Tomcat, Nginx, uWSGI</p>
<p>机器学习框架:<br>  TF2, pytorch, paddle paddle</p>
<p>数据库：<br>  Mysql, Sql server, Postsql, DBF</p>
<p>应用开发：<br>  智能卡片内系统开发, Windows服务</p>
<p>文档类：<br>  Latex, MarkDown</p>
<p>工具:<br>  Ubuntu, Docker</p>
]]></content>
  </entry>
  <entry>
    <title>ML-机器学习简述</title>
    <url>/2020/03/03/ML-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过历史数据学习到一个模型，通过模型预测未来<br>f: x-&gt;y</p>
<h4 id="机器学习分类："><a href="#机器学习分类：" class="headerlink" title="机器学习分类："></a>机器学习分类：</h4><ul>
<li><p>有监督学习:<br>有监督学习的数据集包含了样本x与样本的标签y，算法学习需要学习到映射 $ f_{\theta}: x \rightarrow y$,其中 $ f_{\theta} $代表模型函数 $ \theta $为模型参数。在训练时, 通过计算模型的预测值$ f_{\theta}(x) $ 与真实标签 $ y $之间的误差来优化网络参数$ \theta $, 使得网络的下一次预测更精准。如线性回归, 逻辑回归, 支持向量机, 随机森林</p>
</li>
<li><p>无监督学习:<br>只有样本$x$的数据集, 算法本身需要自行发现数据的模态。如自编码器，生成对抗网络</p>
</li>
<li><p>强化学习: 通过与环境进行交互来学习解决问题的策略。强化学习并没有明确的”正确的”动作监督信号,算法需要与环境进行交互,获取环境反馈的滞后的奖励。如DQN, PPO</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
  </entry>
  <entry>
    <title>进程线程详解</title>
    <url>/2020/03/03/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。<br>11.操作系统的设计，因此可以归结为三点：</p>
<p>以多进程形式，允许多个任务同时运行；</p>
<p>以多线程形式，允许单个任务分成不同的部分运行；</p>
<p>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>
<p>这个类比可以很形象的说明进程与线程的区别。<br>当然面试的时候你不可能说上这一堆，面试官估计要跟你急，时间宝贵，我们需要用最精简的语言说出两者的概念以及区别。<br>你可以这样分点回答（面试时需要逻辑条理清晰、语言简洁、直中要害）：<br>（1）进程<br>进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。<br>（2）线程<br>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<br>（3）联系<br>线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（4）区别：理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）<br>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位<br>在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）<br>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。<br>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p>扩展阅读<br>为什么需要设计线程？<br>在传统进程模型中，进程的内涵可分为下面两个方面：<br>调度、执行的基本单位：每个进程都有自己的运行状态、优先级、寄存器等，是OS调度的基本单位。<br>资源所有权：包括程序、数据、文件等资源。一个进程拥有对这些资源的所有权，OS则提供保护功能，避免不同进程之间的资源冲突。<br>既然是两个独立的功能，可不可以把它们分离呢？这就出现了线程（thread）的概念：<br>执行与调度的基本单位：thread<br>资源所有权：process<br>那么执行与调度的基本单位是线程，这样设置有什么好处？<br>计算机操作系统里面有两个重要概念：并发和隔离。<br>并发是为了尽量让硬件利用率高，线程是为了在系统层面做到并发。线程上下文切换效率比进程上下文切换会高很多，这样可以提高并发效率。<br>隔离也是并发之后要解决的重要问题，计算机的资源一般是共享的，隔离要能保障崩溃了这些资源能够被回收，不影响其他代码的使用。所以说一个操作系统只有线程没有进程也是可以的，只是这样的系统会经常崩溃而已，操作系统刚开始发展的时候和这种情形很像。<br>所以：线程和并发有关系，进程和隔离有关系。线程基本是为了代码并发执行引入的概念，因为要分配cpu时间片，暂停后再恢复要能够继续和没暂停一样继续执行；进程相当于一堆线程加上线程执行过程中申请的资源，一旦挂了，这些资源都要能回收，不影响其他程序。</p>
<p>作者：风平浪静如码<br>链接：<a href="https://juejin.im/post/5e5cb893f265da570d736388" target="_blank" rel="noopener">https://juejin.im/post/5e5cb893f265da570d736388</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>ML-误差函数</title>
    <url>/2020/03/02/ML-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>损失函数（loss function）是用来估量模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数,通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。</p>
<h4 id="损失函数分类"><a href="#损失函数分类" class="headerlink" title="损失函数分类"></a>损失函数分类</h4><p>损失函数一般分为分类和回归两类<br>回归会预测给出一个数值结果而分类则会给出一个标签。<br><img src="%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="损失函数分类"></p>
<h4 id="常用回归损失函数"><a href="#常用回归损失函数" class="headerlink" title="常用回归损失函数"></a>常用回归损失函数</h4><ol>
<li><p>均方误差MSE, 平方损失 – L2损失<br>是回归损失函数中最常用的误差，它是预测值与目标值之间差值的平方和<br>公式: $ MSE = \frac{\sum_{i=1}^{n}(y_i-y_i^p)^2}{n} $<br>特点: 平方损失函数是光滑的，可以用梯度下降法求解，但是，当预测值和真实值差异较大时，它的惩罚力度较大，因此对异常点较为敏感。</p>
</li>
<li><p>平均绝对误差 – L1损失<br>常用的回归损失函数，它是目标值与预测值之差绝对值的和，表示了预测值的平均误差幅度，而不需要考虑误差的方向<br>公式: $ MAE = \frac{|y_i - y_i^p|}{n} $<br>特点: 绝对损失函数对异常点不那么敏感，其鲁棒性比平方损失更强一些，但是它在f = y 处不可导.</p>
</li>
<li><p>Huber损失 – 平滑平均绝对误差<br>相比于平方损失来说对于异常值不敏感，但它同样保持了可微的特性。它基于绝对误差但在误差很小的时候变成了平方误差。<br>公式: <img src="Huber.png" alt="Huber"><br>特点: Huber损失函数在 ∣f−y∣较小时为平方损失，在较大时为线性损失，且处处可导，对异常点鲁棒性较好</p>
</li>
<li><p>log-cosh损失函数<br>公式: $ L(f,y) = \log(cosh(f-y)) $ $ cosh(x) = (e^x + e^{-x})/2 $<br>特点: log-cosh损失函数比均方损失函数更加光滑，具有huber损失函数的所有优点，且二阶可导。因此可以使用牛顿法来优化计算，但是在误差很大情况下，一阶梯度和Hessian会变成定值，导致牛顿法失效。</p>
</li>
<li><p>分位数损失函数<br>公式: $ L(f,y) = \sum_{y_i&lt;f_i}(1-\gamma)|y_i - f_i| + \sum_{y_i \beq f_i} \gamma|y_i - f_i| $<br>特点: 预测的是目标的取值范围而不是值, $ \gamma $是所需的分位数,其值介于0-1之间</p>
</li>
</ol>
<h4 id="常用分类损失函数"><a href="#常用分类损失函数" class="headerlink" title="常用分类损失函数"></a>常用分类损失函数</h4><ol>
<li><p>0-1损失函数<br>预测值和目标值不相等为1，否则为0<br>公式: <img src="01%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt="0-1损失函数"><br>特点: 0-1损失函数可以直观的刻画分类的错误率，但是因为其非凸，非光滑的特点，使得算法很难对其进行直接优化</p>
</li>
<li><p>Hinge损失函数(SVM)<br>公式: $ L(f,y) = max(0, 1 - fy) $<br>特点: Hinge损失函数是0-1损失函数的一个代理损失函数，也是其紧上界，当 fy≥0,fy≥0 时，不对模型做惩罚。因为在fy = 1处不可导, 因此不能用梯度下降算法对其优化,只能用次梯度下降法</p>
</li>
<li><p>对数损失函数（logarithmic loss）LR<br>样本预测值和实际值的误差符合高斯分布，使用极大似然估计的方法，取对数得到损失函数<br>经典的对数损失函数包括entropy和softmax，一般在做分类问题的时候使用<br>公式: $ L(Y, P(Y|X)) = -\logP(Y|X) $<br>特点:Logistic损失函数是0-1损失函数的另一个代理损失函数，它也是0-1损失函数的凸上界，且该函数处处光滑。但是该损失函数对所有样本点都惩罚，因此对异常值更加敏感</p>
</li>
<li><p>交叉商损失函数Cross-Entropy<br>公式: $ L(f,y) = -log_2(\frac{1+fy}{2}) $<br>特点: 交叉熵损失函数也是0-1损失函数的光滑凸上界</p>
</li>
<li><p>指数损失函数(AdaBoost)<br>公式: $ L(f,y) = e^{-fy}$<br>特点: 指数损失函数是AdaBoost里使用的损失函数，同样地，它对异常点较为敏感，鲁棒性不够</p>
</li>
</ol>
<h4 id="损失函数的选择"><a href="#损失函数的选择" class="headerlink" title="损失函数的选择"></a>损失函数的选择</h4><p>损失函数的选取依赖于参数的数量、异常值、机器学习算法、梯度下降的效率、导数求取的难易和预测的置信度等若干方面。</p>
<p>tf.keras.losses.BinaryCrossentropy(from_logits = True)<br>其中，当模型最后一层没有经过激活函数时from_logits设置为True，否则为False。<br>因为logits表示网络的直接输出 。如果网络输出的结果经过了sigmoid或者softmax的概率化，那么from_logits=False就表示把已经概率化了的输出，重新映射回原值。如果网络输出的结果没经过概率化，则from_logits=True，表示不进行任何操作。</p>
]]></content>
  </entry>
  <entry>
    <title>ML-激活函数</title>
    <url>/2020/03/02/ML-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="激活函数的概念"><a href="#激活函数的概念" class="headerlink" title="激活函数的概念"></a>激活函数的概念</h4><p>神经网络中的每个神经元节点接受上一层神经元的输出值作为本神经元的输入值，并将输入值传递给下一层，输入层神经元节点会将输入属性值直接传递给下一层（隐层或输出层）。在多层神经网络中，上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。</p>
<h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><p>不使用激活函数的话，神经网络的每层都只是做线性变换，多层输入叠加后也还是线性变换。因为线性模型的表达能力通常不够，所以这时候就体现了激活函数的作用了，激活函数可以引入非线性因素。</p>
<h4 id="激活函数分类"><a href="#激活函数分类" class="headerlink" title="激活函数分类"></a>激活函数分类</h4><p>  饱和激活函数和非饱和激活函数<br>  <img src="%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%88%86%E7%B1%BB.png" alt="激活函数分类"></p>
<h4 id="饱和定义"><a href="#饱和定义" class="headerlink" title="饱和定义"></a>饱和定义</h4><p>假设 $ h(x) $ 是一个激活函数</p>
<ol>
<li>若 $ \lim_{n\rightarrow+\infty} h^{\prime}(x) =  0 $ 称为右饱和</li>
<li>若 $ \lim_{n\rightarrow-\infty} h^{\prime}(x) =  0 $ 称为左饱和</li>
<li>当一个函数既满足左饱和又满足右饱称之为饱和函数</li>
</ol>
<h4 id="饱和激活函数-Saturated"><a href="#饱和激活函数-Saturated" class="headerlink" title="饱和激活函数(Saturated)"></a>饱和激活函数(Saturated)</h4><p>  Sigmoid和tanh是饱和激活函数</p>
<h4 id="非饱和激活函数-Non-Saturated"><a href="#非饱和激活函数-Non-Saturated" class="headerlink" title="非饱和激活函数(Non-Saturated)"></a>非饱和激活函数(Non-Saturated)</h4><p>  ReLU(修正线性单元)及其变体则是“非饱和激活函数</p>
<h4 id="非饱和激活函数优势"><a href="#非饱和激活函数优势" class="headerlink" title="非饱和激活函数优势"></a>非饱和激活函数优势</h4><ol>
<li>能解决所谓的“梯度消失”问题。</li>
<li>它能加快收敛速度。</li>
</ol>
<h4 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h4><ol>
<li><p>Sigmoid<br>公式为: $ f(x) = \frac{1}{1 + e^{-x}} $<br>函数图像: <img src="Sigmoid%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Sigmoid"><br>导函数图像: <img src="Sigmoid%E5%AF%BC%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Sigmoid导函数"><br>特点:</p>
<ol>
<li>sigmoid函数饱和使梯度消失。我们从导函数图像中可以看出sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋近于0。这样，几乎就没有梯度信号通过神经元传递到前面层的梯度更新中，因此这时前面层的权值几乎没有更新，这就叫梯度消失。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</li>
<li>sigmoid函数输出不是“零为中心”(zero-centered)。一个多层的sigmoid神经网络，如果你的输入x都是正数，那么在反向传播中w的梯度传播到网络的某一处时，权值的变化是要么全正要么全负。</li>
<li>指数函数的计算是比较消耗计算资源的.</li>
</ol>
</li>
<li><p>tanh<br>tanh函数跟sigmoid还是很像的，实际上，tanh是sigmoid的变形,</p>
<p>公式为: $ tanh(x) = \frac{1-e^{-2x}}{1+e^{-2x}} = 2sigmoid(2x)-1$<br>函数图像: <img src="tanh%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="tanh函数图像"><br>优点:</p>
<ol>
<li>tanh解决了sigmoid的输出非“零为中心”的问题<br>缺点：</li>
<li>依然有sigmoid函数过饱和的问题</li>
<li>指数函数的计算是比较消耗计算资源的.</li>
</ol>
</li>
<li><p>ReLU修正线性单元<br>公式为: $ f(x) = max(0, x) $<br>函数图像: <img src="ReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Relu"><br>优点:</p>
<ol>
<li>ReLU解决了梯度消失的问题，至少x在正区间内，神经元不会饱和</li>
<li>由于ReLU线性、非饱和的形式，在SGD中能够快速收敛</li>
<li>算速度要快很多。ReLU函数只有线性关系，不需要指数计算，不管在前向传播还是反向传播，计算速度都比sigmoid和tanh快<br>缺点：</li>
<li>ReLU的输出不是“零为中心”</li>
<li>随着训练的进行，可能会出现神经元死亡，权重无法更新的情况。这种神经元的死亡是不可逆转的死亡</li>
</ol>
</li>
<li><p>Leaky ReLU<br>Leaky ReLU是给所有负值赋予一个非零的斜率。<br>公式为: <img src="LeakyReLU.png" alt="Leaky ReLU"><br>函数图像: <img src="LeakyReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="Leaky ReLU"></p>
<p>优点:</p>
<ol>
<li>神经元不会出现死亡</li>
<li>神经元不会饱和</li>
<li>在SGD收敛很快</li>
<li>计算速度快<br>缺点:</li>
<li>参数 $ \alpha $ 需要先验知识,人工赋值</li>
</ol>
</li>
<li><p>RReLU 随机修正线性单元</p>
<p>公式为: <img src="RReLU.png" alt="RReLU"><br>函数图像: <img src="RReLU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="RReLU函数图像"><br>特点:</p>
<ol>
<li>在训练过程中，α是从一个高斯分布中随机出来的值，然后再在测试过程中进行修正。在测试阶段，把训练过程中所有的取个平均值。</li>
<li>数学形式与PReLU类似，但RReLU是一种非确定性激活函数，其参数是随机的</li>
</ol>
</li>
<li><p>ELU 指数线性单元<br>它试图将激活函数的输出平均值接近零，从而加快学习速度。同时，它还能通过正值的标识来避免梯度消失的问题。<br>公式为: <img src="ELU.png" alt="ELU"><br>函数图像为: <img src="ELU%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8F.png" alt="ELU函数图像"></p>
<p>优点：</p>
<ol>
<li>ELU包含了ReLU的所有优点。</li>
<li>神经元不会出现死亡的情况。</li>
<li>ELU激活函数的输出均值是接近于零的。<br>缺点:</li>
<li>指数计算效率低</li>
</ol>
</li>
</ol>
<h4 id="如何选择激活函数"><a href="#如何选择激活函数" class="headerlink" title="如何选择激活函数"></a>如何选择激活函数</h4><p>  在实践过程中更多还是需要结合实际情况，考虑不同激活函数的优缺点综合使用。</p>
<ol>
<li>通常来说，不能把各种激活函数串起来在一个网络中使用。</li>
<li>如果使用ReLU，那么一定要小心设置学习率(learning rate),并且要注意不要让网络中出现很多死亡神经元。如果死亡神经元过多的问题不好解决，可以试试Leaky ReLU、PReLU、或者Maxout。</li>
<li>尽量不要使用sigmoid激活函数，可以试试tanh，不过感觉tanh的效果会比不上ReLU和Maxout。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>tf-BatchNormalization</title>
    <url>/2020/03/02/tf2-BatchNormalization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>keras.layers.normalization.BatchNormalization()</p>
<p>该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1</p>
<p>BN层的作用<br> (1)加速收敛<br>（2）控制过拟合，可以少用或不用Dropout和正则<br>（3）降低网络对初始化权重不敏感<br>（4）允许使用较大的学习率</p>
<p>机器学习领域有个很重要的假设：IID独立同分布假设，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障。BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</p>
<p>BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓白化，就是对输入数据分布变换到0均值，单位方差的正态分布——那么神经网络会较快收敛，</p>
]]></content>
  </entry>
  <entry>
    <title>tf2-tensorflow2学习之路</title>
    <url>/2020/03/02/tf2-tensorflow2%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>TF2三大功能</p>
<ol>
<li><p>加速计算</p>
</li>
<li><p>自动梯度</p>
</li>
<li><p>常用神经网络接口</p>
</li>
</ol>
<p>[tf.keras 内置数据集] (<a href="https://keras.io/zh/datasets/" target="_blank" rel="noopener">https://keras.io/zh/datasets/</a>)</p>
<h4 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h4><ol>
<li>keras和tf.keras</li>
</ol>
<h4 id="常用API说明"><a href="#常用API说明" class="headerlink" title="常用API说明"></a>常用API说明</h4><ol>
<li>tf.data.Dataset.from_tensor_slices</li>
<li>keras.layers.normalization.BatchNormalization</li>
<li>tf.ones_like 和 tf.zeros_like</li>
</ol>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ol>
<li>fashion-mnist分类实战</li>
<li>GAN手写数字生成实战</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>NLP学习之路</title>
    <url>/2020/03/02/AI-NLP%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NLP = NLU + NLG</p>
<ul>
<li>NLU: 语音/文本 -&gt; 意思</li>
<li>NLG: 意思-&gt; 文本</li>
</ul>
<p>机器翻译系统实现</p>
<p>Decoding Algarithm<br> Viterb</p>
<p>NLP 应用案例</p>
<ul>
<li>Question Answering问答系统（IBM）</li>
<li>Sentiment Analysis情感分析</li>
<li>Machine Translation 机器翻译</li>
<li>Text Summarization 自动摘要</li>
<li>Chatbot 聊天机器人</li>
<li>Information Extraction 信息抽取</li>
</ul>
<p>自然语言处理技术的四个维度</p>
<ul>
<li>Semantic 语义</li>
<li>Syntax 句子结构</li>
<li>Morphology 单词 NER 命名实体识别</li>
<li>Phonetics 声音</li>
</ul>
<p>NLP关键技术</p>
<ul>
<li>Word Segmentation （分词）</li>
<li>Part-of-Speech 词性</li>
<li>Named Entity Recognition 命名实体识别</li>
<li>Dependency Parsing 依存分析</li>
<li>Relation Extraction 关系抽取</li>
</ul>
<p>文本处理过程</p>
<p>原始文本 -&gt; 分词(Segmentation) -&gt; 清洗(Cleaning)(无用的标签， 特殊符号，停用词，大小写转换) -&gt; 标准化(Normalization) -&gt; 特征提取 -&gt; 建模 -&gt; 评估</p>
<ol>
<li>Word Segmentation</li>
<li>Spell Correction</li>
<li>Filtering Words Stop Words Removal</li>
<li>Stemming</li>
</ol>
<p>Word Segmentation Tools</p>
<ul>
<li>Jieba分词</li>
<li>SnowNLP</li>
<li>LTP</li>
<li>HanNLP</li>
</ul>
<p>分词工具实现：</p>
<ul>
<li>基于匹配规则的方法<br>最大匹配(Max Matching) 前向最大匹配(forward-max matching) 后向最大匹配(backward-max matching)</li>
<li>基于概率统计的方法<br>Incorporate Semantic(考虑语义)<br>language model 维特比算法<br>LM，HMM，CRF</li>
</ul>
<p>Spell Correction(拼写错误纠正)<br>  计算编辑距离 insert delete replace</p>
<p>Flitering Words<br>  把停用词和出现频率低的词过滤</p>
<p>Stemming/lemmatization 相同含义单词合并<br>    Porter Stemmer 算法</p>
<p>文本表示 Word Representation<br>  词表示   one-hot representation<br>  句子表示 Boolean representation<br>          Count-based representation<br>          tfidf(w) = tf(d, w) <em> idf(w)<br>              tf(d,w)表示文档d中w的词频<br>              idf(w)考虑单词的重要性 logN/N(w) N语料库中的文档总数 N(w)词语w出现在多少个文档<br>句子相似度 Sentence Similarity<br>  欧式距离: d = |s1 - s2|<br>  余弦相似度: d = (s1 </em> s2)/(|s1| * |s2|)</p>
<p>one-hot representation 缺点<br>  没办法表示单词间语义的相似度<br>  Sparsity 稀疏性</p>
<p>分布式表示法 Distributed Representation<br>  词向量(word vectors)</p>
<p>词向量表达句子向量</p>
<ol>
<li>平均法则</li>
<li>LSTM/RNN</li>
</ol>
<p>训练词向量的常用模型<br>  Skip-Gram<br>  G-lone<br>  CBow<br>  RNN/LSTM<br>  MF</p>
<p>Noisy Channel Model<br>  p(text|source) 等比 p(source|text)p(text)<br>  应用场景<br>    语音识别  P(文本｜语音信号) 等比 P(语音信号｜文本) <em> P(文本)<br>    机器翻译 P（中文｜英文） 等比 P(英文｜中文) </em> P(中文)<br>    拼写纠错  P(正确写法｜错误写法) 等比 P（错误写法｜正确写法） <em> P(正确写法)<br>    OCR<br>    密码破译  P(明文｜暗文) 等比 P(暗文｜明文) </em> P(明文)</p>
<p>语言模型 Language Model<br>  作用：是否一句话从语法上是通顺的</p>
<p>  Chain Rule<br>    p(w1,w2, w3,w4,w5,…wn) = p(w1) <em> p(w2|w1) </em> p(w3|w1w2)….p(wn|w1w2…wn_1)</p>
<p>  Markov Assumption 马尔可夫假设 解决稀疏问题<br>    1st order ｜ 2st order ｜ 3rd order</p>
<p>语言模型分类：<br>  Unigram： 每个单词是独立个体，相互独立 P(w1, w2, w3, w4 … wn) = p(w1) <em> p(w2) </em> p(w3) … p(wn)<br>  Bigran: 1st order Markov Assumption P(w1, w2, w3, w4 … wn) = p(w1) <em> p(w2|w1) </em> p(w3|w2) … p(wn|wn_1)<br>  N-gram:</p>
<p>  使用Estimating Probability 计算每个单词的概率，但是会出现概率0项，可做平滑</p>
<p>如何评估语言模型<br>  $ Perplexity = 2^{-(x)} $</p>
<p>处理未出现在字典中的词</p>
<ol>
<li>Add-one Smoothing (Laplace Smoothing)<br> $ P_{ADD-1}(w_i|w_{i-1}) = \frac{c(w_{i-1}, w_i) + 1}{c(w_i) + V} $</li>
<li>Add-k Smoothing<br> $ P_{ADD-1}(w_i|w_{i-1}) = \frac{c(w_{i-1}, w_i) + k}{c(w_i) + kV} $<br> 如何选择k<ol>
<li>k = 1，2，3尝试</li>
<li>优化 f(k) 使用Preplexity优化</li>
</ol>
</li>
<li>Interpolation<br>   $p(w_n|w_{n-1}, w_{n-1}) = \lambda_1 p(w_n| w_{n-1}, w_{n-2}) + \lambda_2 p(w_n| w_{n-1} + \lambda_3 p(w_n)$<br>   $ \lambda_1 + \lambda_2 + \lambda_3  = 1$</li>
<li>Good-Turning Smoothing<br>   缺点：</li>
</ol>
<p>语言模型</p>
<p>numpy<br>多维对象数组<br>每一个numpy的数组都有一个shape和一个叫dtype的方法<br>  shape获取数据的维度<br>  dype 获取数组的类型</p>
<p>pandas</p>
<p>贪心算法 每次选择当前最好的 局部最优<br>DP 全局最优</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>tf2-学习记录</title>
    <url>/2020/03/01/tf2-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[tf.keras 内置数据集] (<a href="https://keras.io/zh/datasets/" target="_blank" rel="noopener">https://keras.io/zh/datasets/</a>)</p>
<p>tf.data.Dataset.from_tensor_slices (<a href="https://blog.csdn.net/Dr_jiabin/article/details/93366661" target="_blank" rel="noopener">https://blog.csdn.net/Dr_jiabin/article/details/93366661</a>)</p>
<p>keras.layers.BatchNormalization()</p>
<p>keras.layers.LeakyReLU()</p>
<p>from_logits</p>
<p>tf.keras.losses.BinaryCrossentropy(from_logits = True)</p>
<p>tf.one_like</p>
<p>tf.zeros_like</p>
]]></content>
  </entry>
  <entry>
    <title>tf2-from_tensor-slices说明</title>
    <url>/2020/03/01/tf2-from-tensor-slices%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="tf-data-Dataset-from-tensor-slices"><a href="#tf-data-Dataset-from-tensor-slices" class="headerlink" title="tf.data.Dataset.from_tensor_slices"></a>tf.data.Dataset.from_tensor_slices</h4><h4 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h4><p>  一个元组、列表和张量</p>
<h4 id="出参"><a href="#出参" class="headerlink" title="出参"></a>出参</h4><p>  得到数据集,类型为TensorSliceDataset</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>是把给定的元组、列表和张量等数据进行特征切片。切片的范围是从最外层维度开始的。如果有多个特征进行组合，那么一次切片是把每个组合的最外维度的数据切开，分成一组一组的。</p>
<p>假设我们现在有两组数据，分别是特征和标签，我们假设每两个特征对应一个标签。之后把特征和标签组合成一个tuple，那么我们的想法是让每个标签都恰好对应2个特征，而且像直接切片，比如：[f11, f12] [t1]。f11表示第一个数据的第一个特征，f12表示第1个数据的第二个特征，t1表示第一个数据标签。那么tf.data.Dataset.from_tensor_slices就是做了这件事情：</p>
<figure class="highlight python"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">features, labels = (np.random.sample((<span class="number">6</span>, <span class="number">3</span>)),  <span class="comment"># 模拟6组数据，每组数据3个特征</span></span><br><span class="line">                    np.random.sample((<span class="number">6</span>, <span class="number">1</span>)))  <span class="comment"># 模拟6组数据，每组数据对应一个标签，注意两者的维数必须匹配</span></span><br><span class="line"></span><br><span class="line">print((features, labels))  <span class="comment">#  输出下组合的数据</span></span><br><span class="line">data = tf.data.Dataset.from_tensor_slices((features, labels))</span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>tf2-GAN</title>
    <url>/2020/03/01/tf2-GAN%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E7%94%9F%E6%88%90%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="实战使用keras的mnist数据集-使用GAN生成手写数据图片"><a href="#实战使用keras的mnist数据集-使用GAN生成手写数据图片" class="headerlink" title="实战使用keras的mnist数据集,使用GAN生成手写数据图片"></a>实战使用keras的mnist数据集,使用GAN生成手写数据图片</h4><p>使用生成器模型生成手写图片<br>使用判别器模型对真图片进行真判断对生成的图片进行假判断</p>
<h4 id="定义生成器模型"><a href="#定义生成器模型" class="headerlink" title="定义生成器模型"></a>定义生成器模型</h4><p>生成器用来将随机数生成手写数据图片<br>生成器使用三层结构<br>输入层和中间层使用BatchNormalization进行标准化,使用LeakyReLU进行激活<br>输出层使用tanh激活<br>最后将输出数据改为28 * 28 * 1 的形状</p>
<figure class="highlight plain"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line">def generator_model():</span><br><span class="line">    model &#x3D; tf.keras.Sequential()</span><br><span class="line">    model.add(keras.layers.Dense(256, input_shape &#x3D; (100,), use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(512, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(28 * 28 * 1, use_bias &#x3D; False, activation &#x3D; &#39;tanh&#39;))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Reshape((28, 28, 1)))</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>

<h4 id="定义判别器模型"><a href="#定义判别器模型" class="headerlink" title="定义判别器模型"></a>定义判别器模型</h4><p>判别器用来对输入图片进行判别<br>判别器使用三层网络结构<br>第一层将图片数据延展并输入到一个全连接层，使用BatchNormalization标准化，使用LeakyReLU激活<br>第二层是个全连接层，同样使用使用BatchNormalization标准化，使用LeakyReLU激活<br>第三层输出判别的结果</p>
<figure class="highlight plain"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line">def discriminator_model():</span><br><span class="line">    model &#x3D; keras.Sequential()</span><br><span class="line">    model.add(keras.layers.Flatten())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(512, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(256, use_bias &#x3D; False))</span><br><span class="line">    model.add(keras.layers.BatchNormalization())</span><br><span class="line">    model.add(keras.layers.LeakyReLU())</span><br><span class="line"></span><br><span class="line">    model.add(keras.layers.Dense(1))</span><br><span class="line"></span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>


<h3 id="GAN-生成对抗网络"><a href="#GAN-生成对抗网络" class="headerlink" title="GAN 生成对抗网络"></a>GAN 生成对抗网络</h3><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><pre><code>* 图像生成
* 图像增强
* 风格化
* 艺术的图像创作</code></pre><h3 id="GAN定义"><a href="#GAN定义" class="headerlink" title="GAN定义"></a>GAN定义</h3><p>GAN 包含两部分生成器generator与判别器discriminator,<br>    * 生成器主要用来学习真实图像分布从而让自身生成的图像更加真实，以骗过判别器<br>    * 判别器对接收的图片进行真假判断</p>
<h3 id="GAN-设计"><a href="#GAN-设计" class="headerlink" title="GAN 设计"></a>GAN 设计</h3><ul>
<li><p>生成器网络</p>
</li>
<li><p>判别器网络（例如 5层CNN)</p>
</li>
</ul>
<p>自编码器<br>基本去燥自编ma<br>卷积去燥自编码器</p>
<p>GAN自定义</p>
]]></content>
      <categories>
        <category>TF2</category>
      </categories>
  </entry>
  <entry>
    <title>音-Supermarket-Flowers</title>
    <url>/2020/02/27/%E9%9F%B3-Supermarket-Flowers/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次听这首歌是某在中午扇贝新闻推荐的视频,第一次听没感觉什么，演唱者也不好看，然而听完第一次莫名想回味。然后就一发不可收拾。<br>当时也恰逢世界杯，坐地铁去LB那看球赛，很欢乐的一段时间，然而现在都过去了，再听这首歌有种伤感。然后在网易云音乐买了它</p>
<p>I took the supermarket flowers from the windowsill<br>I threw the day old tea from the cup<br>Packed up the photo album Matthew had made<br>Memories of a life that’s been loved</p>
<p>Took the get well soon cards ans stuffed animals<br>Poured the old ginger beer down the sink<br>Dad always told me,”Don’t you cry when you’re down”<br>But mum, there’s a tear every time that I blink</p>
<p>Oh I’m in pieces, it’s tearing me up, but I know<br>A heart that’s broke is a heart that’s been loved<br>So I’ll sing Hallelujah<br>You were an angle in the shape of my mun<br>When I fell down you’d be here holding me up<br>Spread your wings as you go</p>
<p>And when God takes you back<br>We’ll say Hallelujah<br>You’re home</p>
<p>I fluffed the pillows,made the beds, stacked the chairs up<br>Folded your nightgowns neatly in a case<br>John says he’d drive then put his hand on my cheek<br>And wiped a tear from the side of my face</p>
<p>I hope that I can see the world as you did cause I know<br>A life with love is a life that’s been lived</p>
]]></content>
      <categories>
        <category>音</category>
      </categories>
  </entry>
  <entry>
    <title>DB-数据库写提速</title>
    <url>/2020/02/27/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99%E6%8F%90%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://juejin.im/post/5e538d7ff265da5715630e8d?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5e538d7ff265da5715630e8d?utm_source=gold_browser_extension</a></p>
]]></content>
  </entry>
  <entry>
    <title>DB-数据库索引</title>
    <url>/2020/02/27/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://juejin.im/post/5e575cb56fb9a07c951cdb39?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5e575cb56fb9a07c951cdb39?utm_source=gold_browser_extension</a></p>
<p>自从两年前了解到的索引以来的，就一直想写一篇有关索引的文章。然而我是个拖延癌症患者，一拖就是两年，不愧是我。该篇文章算是自己的笔记，欢迎批评。<br>概述<br>索引是什么？很多书和文章都会使用图书的目录来类比。目录的目的就是用方便我们查找具体内容的位置，具体的章节的范围。与此类似，MySQL中索引的用途是帮助我们加速查询以及排序。<br>在InnoDB中的索引类型有哈希索引、B+树索引、全文索引。哈希索引在InnoDB中设计为自适应的，不展开讨论。在InnoDB1.12之后有了全文索引，也是应用倒排，还没踩过坑(据说不支持中文)，有时间可以研究一下。<br>本篇主要讨论B+树索引。<br>B+树<br>学习MySQL的索引，必须得先了解其原理，否则很多问题将一头雾水。下文将讲述索引数据结构的原理，而不涉及其复杂的具体实现。<br>在谈B+树之前，不妨先思考，为什么索引能加快查询？为什么要用B+树作为索引而不用B树？哈希索引查询复杂度为O(1)为什么又不用哈希索引？<br>BST和AVL<br>在了解B树和B+树之前，先了解一下二叉搜索树(BST)和平衡二叉树(AVL)。<br>在顺序存储结构中(如数组)，最快的情况是第一个就是目标值，最坏的情况是最后一个是目标值，假设有n个元素，用大O标记法平均的时间复杂度为O(n)。<br>使用二叉搜索树可以有效的优化搜索时间。利用二叉搜索树的特性左子节点比父节点小、右子节点比父节点大，可以很方便的进行二分查找，有效优化的搜索时间。</p>
<p>正常情况下，我们使用二叉搜索树可以了，但如果出现以下的情况，二叉搜索树反而起不到效果，搜索的平均时间复杂度依旧为O(n)。</p>
<p>引入平衡二叉树，深度差不超过1，从而保证不倾斜，或者说更矮，保证其搜索效率。<br>B树和B+树<br>既然平衡二叉树已经可以加快查询了，但实际上InnoDB并不会使用。在思考B树和B+树的相关问题的时候，离不开一个问题——磁盘IO。索引文件存储在磁盘，假设有平衡二叉树树高30，那么你可能要扫描30次磁盘才能完成搜索。<br>对于需要磁盘IO的情况，使用平衡二叉树依旧比较糟糕，所以需要引入多路树，即B树和B+树，使得树更“矮”。</p>
<p>如果上述B树改成二叉树，那么树的高度就大了很多，换而言之就需要更多次的磁盘IO。<br>B+树是B树的变种。B+树的非叶子结点不存储数据，并且所有的叶子节点以双向链表的形式相连。</p>
<p>现在的索引模型基本都是B+树。<br>相对于B树来说，B+树的搜索更加稳定，因为B树有的数据是分布在非叶子节点上的。<br>B树的叶子节点以链表的形式相连且按照规则排了序，通过B+索引，可以更加方便的获取范围数据。<br>这也是不使用哈希索引的原因。虽然哈希索引搜索的时间复杂度为O(1)，但大部分时候我们并不会只查询一条记录，这种时候使用哈希索引就比较乏力了。<br>聚集索引<br>聚集索引，亦可称为主键索引。一张表只存在一个聚集索引。<br>聚集索引是根据其主键作为排序规则的B+树，搜索时根据其主键进行搜索。<br>其中叶子节点上存储着整条记录的数据。<br>InnoDB的B+树在磁盘中的存储是以数据页的形式，在树中间进行插入和删除操作涉及列“页分裂”和“页合并”的复杂过程(关于这点我个人也讲不明白，但可以类比AVL树的旋转去理解)，十分耗性能，而直接插入尾部是比较快捷的方式，所以在很多的规范中写道，当使用InnoDB引擎的时候，强烈建议用一个与业务无关的自增id作为主键。<br>此外，删除也是一样的，很多时候会要求做伪删除，不仅仅只是为了数据分析，更是为了索引的性能。<br>非聚集索引<br>非聚集索引又称辅助索引，以非主键列来建立。非聚集索引可以有多个。非聚集索引和聚集索引的区别在于，非聚集索引的叶子节点并不存储整条记录的数据，而是存储指向的主键的指针。所以，当利用非主键索引进行搜索时，还需要通过主键索引获取整条数据。<br>单值索引<br>单值索引就是在数据表单个列上建立单个值。<br>CREATE INDEX index_name ON table_name(column);<br>复制代码与主键索引类似，单值索引按照所指定列排序建立二叉树。当利用单值搜索到目标后，再通过主键索引去读取整条数据。<br>唯一索引<br>唯一索引与单值索引区别不大，只是唯一索引的值不会重复。<br>唯一索引除了能提高一些效率以外，有时也用来保证列的唯一性，如用户的手机号身份证等。这里不做过多赘述。<br>联合索引<br>创建联合索引时指定多列即可。<br>CREATE INDEX index_name ON table_name(column1, columm2, column3 [,…])<br>复制代码联合索引会按照建立索引时的顺序，对每个字段进行排序。即第一个字段排完序，接着排第二个字段，第三…</p>
<p>覆盖索引<br>在前面提到，非聚集索引搜索记录时还需要通过的主键索引，但如果查找的列刚刚好是联合索引的字段，那就没有必要去再去搜索主键索引，直接取叶子节点值即可，这就是覆盖索引。<br>为什么不用select *，原因就在此，不仅仅是为了减少读取更多列带来的开销，也是为了能够使用上覆盖索引。使用覆盖索引可以减少磁盘IO，有效提高性能。<br>下文将讲述有关联合索引的更多细节。<br>最左前缀原则<br>上文了解了联合索引，知道了联合索引的节点数据是按照建索引的顺序依次排序，由此我们引出了最左前缀原则，联合索引中，如果要用上索引字段，前面的字段不能跳过。如果上图的例子，假设是找column2=“ccc”的记录，大概的sql如下<br>SELECT some_column FROM table_name WHERE column2=”ccc”<br>复制代码这种情况下索引是用不上的，因为索引是先排序的column1，再排序column2，直接通过column2搜索，B+树并不知道怎么搜索。<br>索引失效<br>除了上述的最左前缀原则下索引的失效，还有其他索引失效情况。</p>
<p>使用MySQL内置函数运算的列索引会失效。</p>
<p>使用!=，is null，is not null 索引会失效。<br>比如你查找id != 500的记录，相当把扫描id<500，以及id >500的记录，本质上全表扫描没啥区别。</p>
<p>范围查询后的列无法使用。<br>还是用上图的例子，假设查询 column1 &lt;= 4的情况<br>SELECT some_column FROM table_name WHERE column1 &lt;= 4<br>复制代码因为column1是排了序的，索引联合索引column1还是可以使用上的，但column1是范围数据，在这范围内column2并不有序。</p>
<p>以通配符开头的模糊查询(LIKE “%string”)。<br>值得一提的是，LIKE “string%”是能用上索引的，类似于范围查询，查询从string开头的最小字符串到stirng开头的最大字符串。知道了LIKE “string%”是能用上索引的就能理解为什么LIKE “%string”为什么用不上索引了。</p>
<p>还有其他情况的情况，可用MySQL的查询分析器进行分析。<br>InooDB使用的锁是行锁，但如果在更新时索引失效了，行锁会变成表锁，在开发中应该避免。<br>索引使用tip</p>
<p>常用来分组和排序的字段可建立索引。<br>索引的作用是查询和排序，order by和group by是可以用上索引的，如果排序的有多字段，也是按照最左前缀原则。</p>
<p>经常用来查询的字段可建索引。</p>
<p>更新频繁的字段不要建立索引。<br>频繁更新的字段如果建立来索引，更新时不仅更新数据，而且索引的B+树也会发生变化，开销比较大，得不偿失。</p>
<p>选择性小的列不要建立索引。<br>比如说性别字段，只有男或女或未知，百万数据里只有这三个值，建立索引毫无意义。</p>
<p>索引尽量使用等值匹配。</p>
<p>尽量使用覆盖索引。</p>
<p>小结<br>通过建立索引，可以有效的加速数据库的查询和排序。当谈及的数据库优化时，索引优化肯定跑不了。索引的使用有各业界大佬总结的技巧，但很多东西不是绝对的，不能以偏概全，在大数据以及复杂业务下，索引的维护算是玄学，需要不断寻找最佳的索引方案。</p>
]]></content>
  </entry>
  <entry>
    <title>算法-位运算</title>
    <url>/2020/02/27/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="奇偶判断"><a href="#奇偶判断" class="headerlink" title="奇偶判断"></a>奇偶判断</h4><p>if( n &amp; 2 == 1){<br>    dosomething();<br>}</p>
<h4 id="利用n-amp-n-1-消去n最后的一位1"><a href="#利用n-amp-n-1-消去n最后的一位1" class="headerlink" title="利用n &amp; (n - 1)消去n最后的一位1"></a>利用n &amp; (n - 1)消去n最后的一位1</h4><p>(1)、判断一个正整数n是否为2的幂次方<br>如果一个数是 2 的幂次方，意味着 n 的二进制表示中，只有一个位 是1，其他都是0。我举个例子，例如<br>2^0 = 0…..0001<br>2^1 = 0…..0010<br>2^2 = 0….0100<br>那么我们完全可以对n执行n = n &amp; (n - 1)，执行之后结果如果不为 0，则代表 n 不是 2 的幂次方，代码如下</p>
<p>(2）判断正整数n的二进制表示中有多少个 1<br>我们可以用不断着执行 n &amp; (n - 1)，每执行一次就可以消去一个 1，当 n 为 0 时，计算总共执行了多少次即可</p>
<h4 id="异或-运算的妙用"><a href="#异或-运算的妙用" class="headerlink" title="异或(^)运算的妙用"></a>异或(^)运算的妙用</h4><p>特性一：两个相同的数相互异或，运算结果为 0，例如 n ^ n = 0<br>特性二：任何数和 0 异或，运算结果不变，例如 n ^ 0 = n<br>特性三：支持交换律和结合律，例如 x ^ ( y ^ x) = (x ^ y) ^ x</p>
<p>  案例1：只出现一次是数</p>
]]></content>
  </entry>
  <entry>
    <title>DB-MySQl一些概念</title>
    <url>/2020/02/27/DB-MySQl%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库ACID, 数据库锁，数据库索引，数据库安全性, 数据库完整性</p>
<a id="more"></a>
<h3 id="数据库事务的ACID"><a href="#数据库事务的ACID" class="headerlink" title="数据库事务的ACID"></a>数据库事务的ACID</h3><ul>
<li><p>原子性(Atomicity): 指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<ol>
<li>案例: A转账给B 100 元<br><img src="ACID_A.png" alt="原子性"></li>
<li>分析: 在事务中的A扣款和B加款要么都执行成功,要么都不执行。</li>
<li>解决方案: 在数据库管理系统（DBMS）中，默认情况下一条SQL就是一个单独事务，事务是自动提交的。只有显式的使用start transaction开启一个事务，才能将一个代码块放在事务中执行。保障事务的原子性是数据库管理系统的责任，为此许多数据源采用日志机制。例如，SQL Server使用一个预写事务日志，在将数据提交到实际数据页面前，先写在事务日志上。mysql使用 undo log，是当事务回滚时能够撤销所有已经成功执行的 sql 语句。</li>
</ol>
</li>
<li><p>一致性(Consistency): 是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<ol>
<li>案例: 数据库存在约束A和B的总金额为200</li>
<li>分析: 在执行转账任务结束后,也应遵守此约束。</li>
<li>解决方案:<br>保障事务的一致性，可以从以下两个层面入手<br>(1) 数据库机制层面<br>在一个事务执行之前和之后，数据会符合你设置的约束（唯一约束，外键约束,Check约束等)和触发器设置。mysql使用 redo log和Buffer Pool，Buffer Pool存储待写入数据库的数据，redo log记录事务的操作<br>(2) 业务层面<br>使用业务逻辑保证数据一致</li>
</ol>
</li>
<li><p>隔离性(Isolation): 指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。<br>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p>
<ol>
<li>解决方案：利用加锁和阻塞来保证事务之间不同等级的隔离性。</li>
</ol>
</li>
<li><p>持久性(Durability): 指事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。<br>解决方案: SQL SERVER通过对事务中对数据库的改变在写入到数据库之前，首先写入到事务日志中。而事务日志是按照顺序排号的（LSN）。当数据库崩溃或者服务器断点时，重启动SQL SERVER，SQLSERVER首先会检查日志顺序号，将本应对数据库做更改而未做的部分持久化到数据库，从而保证了持久性。</p>
</li>
</ul>
<h4 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h4><ul>
<li>共享锁：又叫S锁或者读锁，加了共享锁的数据对象可以被其他事务读取，但不能修改， 通常是该数据对象被读取完毕，锁立即被释放</li>
<li>排他锁：又叫X锁或者写锁，当数据对象被加上排它锁时，一个事务必须得到锁才能对该数据对象进行访问，一直到事务结束锁才被释放。 在此之间其他的事务不能对它读取和修改</li>
<li>行锁: 行级别的锁</li>
<li>表锁: 表级别的锁</li>
</ul>
<h4 id="数据库的索引的数据结构"><a href="#数据库的索引的数据结构" class="headerlink" title="数据库的索引的数据结构"></a>数据库的索引的数据结构</h4><p>B+树</p>
<h4 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h4><p>权限控制和数据备份</p>
<h4 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h4><p>通过一些约定和规范来限制数据库的存储内容，比如主键、唯一键、非空等要求来限制字段的取值。</p>
]]></content>
  </entry>
  <entry>
    <title>DB-MySQL存储引擎</title>
    <url>/2020/02/27/DB-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>MySQL存储引擎也称作表类型是指，MySQL使用的不同的存储技术将数据存储在文件（或者内存）中。<br>这些技术指不同的存储机制、索引技巧、锁定水平等。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>需要根据不同的应用场景选择不同的数据引擎<br>例如：研究大量的临时数据需要选择内存存储引擎<br>     需要处理事务型的业务需要选择支持事务性的数据库</p>
<h4 id="常用引擎及其特性"><a href="#常用引擎及其特性" class="headerlink" title="常用引擎及其特性"></a>常用引擎及其特性</h4><p>MyISAM： 拥有较高的插入，查询速度，但不支持事务<br>InnoDB：事务型数据库的首选引擎，支持ACID事务，支持行级锁定<br>CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引</p>
]]></content>
  </entry>
  <entry>
    <title>ML-softmax 理解</title>
    <url>/2020/02/25/ML-softmax/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="softmax-含义"><a href="#softmax-含义" class="headerlink" title="softmax 含义"></a>softmax 含义</h4><p>softmax把一些输入映射为0-1之间的实数，并且归一化保证和为1，因此多分类的概率之和也刚好为1。</p>
<p>首先简单理解softmax的含义。顾名思义，softmax由两个单词组成，其中一个是max。对于max我们都很熟悉，比如有两个变量a,b。如果a&gt;b，则max为a，反之为b。<br>另外一个单词为soft。max存在的一个问题是什么呢？如果将max看成一个分类问题，就是非黑即白，最后的输出是一个确定的变量。更多的时候，我们希望输出的是取到某个分类的概率，或者说，我们希望分值大的那一项被经常取到，而分值较小的那一项也有一定的概率偶尔被取到，所以我们就应用到了soft的概念，即最后的输出是每个分类被取到的概率。</p>
<h4 id="softmax-计算"><a href="#softmax-计算" class="headerlink" title="softmax 计算"></a>softmax 计算</h4><p>计算过程如下图<br><img src="softmax.jpg" alt="softmx"></p>
<p>假设有一个数组V，$ V_i $表示V中的第i个元素，那么这个元素的softmax值为:<br>$$ s_i = \frac{e^i}{\sum_{j = 1} ^{i}e^j} $$<br>该元素的softmax值，就是该元素的指数与所有元素指数和的比值。</p>
<p>这个定义可以说很简单，也很直观。那为什么要定义成这个形式呢？原因主要如下。</p>
<p>1.softmax设计的初衷，是希望特征对概率的影响是乘性的。<br>2.多类分类问题的目标函数常常选为cross-entropy。即 $ L = - \sum_{k} t_k \cdot \ln P(y = k)$，其中目标类的 $ t_k $为1，其余类的$ t_k $为0。</p>
<h4 id="softmax求导"><a href="#softmax求导" class="headerlink" title="softmax求导"></a>softmax求导</h4><p>在多分类问题中，我们经常使用交叉熵作为损失函数<br>$$ Loss = - \sum{t_i} \ln{y_i} $$<br>其中，$ t_i $表示真实值，$ y_i $表示求出的softmax值。<br>当预测第i个时，可以认为$ t_i = 1 $。此时损失函数变成了:<br>$$ Loss_i = −\ln {y_i} $$</p>
<p>接下来对$ Loss $求导。根据定义：<br>$$ y_i = \frac{e^i} {\sum_j e_j} $$</p>
<p>我们已经将数值映射到了0-1之间，并且和为1，则有：<br>$$ \frac{e^i} {\sum_j e^j} = 1 - \frac{ \sum_{j \neq i} e^j} { \sum_j e^j} $$</p>
<p>求导</p>
]]></content>
  </entry>
  <entry>
    <title>TF2-fashion_mnist_分类模型</title>
    <url>/2020/02/25/tf2-fashion-mnist-%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用三层全联接层对图片进行分类</p>
<figure class="highlight python"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(x_train_all, y_train_all), (x_test, y_test) = fashion_mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分为测试集和训练集</span></span><br><span class="line">x_valid, x_train = x_train_all[:<span class="number">5000</span>], x_train_all[<span class="number">5000</span>:]</span><br><span class="line">y_valid, y_train = y_train_all[:<span class="number">5000</span>], y_train_all[<span class="number">5000</span>:]</span><br><span class="line"></span><br><span class="line">print(x_valid.shape, y_valid.shape)</span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 归一化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">x_train_scaled = scaler.fit_transform(</span><br><span class="line">    x_train.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">x_valid_scaled = scaler.transform(</span><br><span class="line">    x_valid.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">x_test_scaled = scaler.transform(</span><br><span class="line">    x_test.astype(np.float32).reshape(<span class="number">-1</span>, <span class="number">1</span>)).reshape(<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">print(np.max(x_train_scaled), np.min(x_train_scaled))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_single_image</span><span class="params">(img_arr)</span>:</span></span><br><span class="line">    plt.imshow(img_arr, cmap=<span class="string">"binary"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">show_single_image(x_train[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_imgs</span><span class="params">(n_rows, n_cols, x_data, y_data, class_names)</span>:</span></span><br><span class="line">    plt.figure(figsize = (n_cols * <span class="number">1.4</span>, n_rows * <span class="number">1.6</span>))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n_rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n_cols):</span><br><span class="line">            index = n_cols * row + col</span><br><span class="line">            plt.subplot(n_rows, n_cols, index + <span class="number">1</span>)</span><br><span class="line">            plt.imshow(x_data[index], cmap = <span class="string">"binary"</span>, interpolation = <span class="string">"nearest"</span>)</span><br><span class="line">            plt.axis(<span class="string">'off'</span>)</span><br><span class="line">            plt.title(class_names[y_data[index]])</span><br><span class="line">    plt.show()</span><br><span class="line">class_names = [<span class="string">'T-shirt'</span>, <span class="string">'Trouser'</span>, <span class="string">'Pullover'</span>, <span class="string">'Dress'</span>, <span class="string">'Coat'</span>, <span class="string">'Sandal'</span>, <span class="string">'Shirt'</span>, <span class="string">'Sneaker'</span>, <span class="string">'Bag'</span>, <span class="string">'Ankle boot'</span>]</span><br><span class="line"></span><br><span class="line">show_imgs(<span class="number">3</span>, <span class="number">5</span>, x_train, y_train, class_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape = [<span class="number">28</span>, <span class="number">28</span>]),</span><br><span class="line">    keras.layers.Dense(<span class="number">300</span>, activation = <span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">100</span>, activation = <span class="string">'relu'</span>),</span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>, activation = <span class="string">'softmax'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">model.compile(loss = <span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              optimizer = <span class="string">"sgd"</span>,</span><br><span class="line">              metrics=[<span class="string">"accuracy"</span>])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">history = model.fit(x_train, y_train, epochs = <span class="number">10</span>, validation_data = (x_valid, y_valid))</span><br><span class="line"></span><br><span class="line">history.history</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curves</span><span class="params">(history)</span>:</span></span><br><span class="line">    pd.DataFrame(history.history).plot(figsize=(<span class="number">8</span>,<span class="number">5</span>))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_ylim(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_learning_curves(history)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TF2</category>
      </categories>
  </entry>
  <entry>
    <title>分类</title>
    <url>/2020/02/25/%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>PAT-1014 Waiting in Line</title>
    <url>/2020/02/24/PAT-1014-Waiting-in-Line/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936" target="_blank" rel="noopener">1014 Waiting in Line</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一队列人到银行办理业务, 每个人办理业务时长不同, 银行有几个服务窗口，每个服务窗口允许固定的人数排队，排满之后，后面的人只能等着在办理的人结束，才能去排队。<br>哪个队列走就可以去排那个队列，银行的营业时间是8:00-17:000<br><a id="more"></a></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这道题就是一个排队入队出队问题，问题的难点怎样确定去排哪个队。<br>类似于多核CPU任务调度的问题</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个结构体来记录每个窗口的信息<br>ST_WINDOW{<br>    int iTopFinishTime;<br>    int iTotalTime;<br>    queue<int> quePeopleId;<br>};<br>iTopFinishTime 表示队列中最顶端的人何时服务结束<br>iTotalTime 表示这个队列总共服务的时长<br>quePeopleId 表示当前队列中的人<br>这样每次只需要找到当前所有窗口最小的iTopFinishTime，就是下次可排队的窗口</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST_WINDOW</span>&#123;</span>  <span class="comment">//模拟服务窗口</span></span><br><span class="line">    <span class="keyword">int</span> iTopFinishTime;</span><br><span class="line">    <span class="keyword">int</span> iTotalTime;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; quePeopleId;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iM, iK, iQ;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; iN &gt;&gt; iM &gt;&gt; iK &gt;&gt; iQ;</span><br><span class="line">    ST_WINDOW stWindow[iN]; <span class="comment">//服务窗口</span></span><br><span class="line">    <span class="keyword">int</span> szProcessTime[iK]; <span class="comment">//每个客户处理的时间</span></span><br><span class="line">    <span class="keyword">int</span> szFinishTime[iK]; <span class="comment">//每个客户结束处理时间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iK; iIndex ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; szProcessTime[iIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iProcessingNum = <span class="built_in">min</span>(iN * iM, iK); <span class="comment">//可进入服务窗口排队的人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span> ; iIndex &lt; iProcessingNum; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        stWindow[iIndex % iN].quePeopleId.push(iIndex);</span><br><span class="line">        <span class="keyword">if</span>(iIndex &lt; iN)</span><br><span class="line">        &#123;</span><br><span class="line">            stWindow[iIndex % iN].iTopFinishTime = szProcessTime[iIndex];</span><br><span class="line">            stWindow[iIndex % iN].iTotalTime = szProcessTime[iIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stWindow[iIndex % iN].iTotalTime = stWindow[iIndex % iN].iTotalTime + szProcessTime[iIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        szFinishTime[iIndex] = stWindow[iIndex % iN].iTotalTime ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = iProcessingNum; iIndex &lt; iK; iIndex++) <span class="comment">//需要等待进入排队的人</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iMinTopFinishTimeWindow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找最小的顶端服务时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jIndex = <span class="number">1</span>; jIndex &lt; iN; jIndex ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(stWindow[iMinTopFinishTimeWindow].iTopFinishTime &gt; stWindow[jIndex].iTopFinishTime)</span><br><span class="line">            &#123;</span><br><span class="line">                iMinTopFinishTimeWindow = jIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].quePeopleId.pop();</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].quePeopleId.push(iIndex);</span><br><span class="line">        <span class="keyword">int</span> iToProcePeopleId = stWindow[iMinTopFinishTimeWindow].quePeopleId.front();</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].iTopFinishTime += szProcessTime[iToProcePeopleId];</span><br><span class="line">        stWindow[iMinTopFinishTimeWindow].iTotalTime += szProcessTime[iIndex];</span><br><span class="line">        szFinishTime[iIndex] = stWindow[iMinTopFinishTimeWindow].iTotalTime ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> iQueryId;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iQ; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; iQueryId;</span><br><span class="line">        <span class="keyword">if</span>(szFinishTime[iQueryId - <span class="number">1</span>] - szProcessTime[iQueryId - <span class="number">1</span>]&gt;= <span class="number">540</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Sorry"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:%02d"</span>, <span class="number">8</span> + (szFinishTime[iQueryId - <span class="number">1</span>]) / <span class="number">60</span> , (szFinishTime[iQueryId - <span class="number">1</span>] ) % <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iIndex&lt;iQ<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1010 Radix</title>
    <url>/2020/02/24/PAT-1010-Radix/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805507225665536" target="_blank" rel="noopener">1010 Radix</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定两个数，并告诉其中一个数的进制数，然后判断是否存在一个进制使得两个数相等</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这题题目很好理解,就是做起来真难受,各种部分正确<br>总体思路就是使用二分法找进制,按照进制转换成数字.<br>其中二分的下限是所有进制数中最大数加1，上限是此数本身。<br>要考虑数位益处的问题，溢出后其数符号位为负</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串按进制转换为长整型</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">str2RadixNum</span><span class="params">(<span class="built_in">string</span> strNum, <span class="keyword">long</span> <span class="keyword">long</span> llRadix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> pT = strNum.<span class="built_in">begin</span>(); pT != strNum.<span class="built_in">end</span>(); pT++)</span><br><span class="line">    &#123;</span><br><span class="line">        llNum = llNum * llRadix + (<span class="built_in">isdigit</span>(*pT) ? (*pT - <span class="string">'0'</span>) : (*pT - <span class="string">'a'</span> + <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> llNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分法寻找进制</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">findNumRadix</span><span class="params">(<span class="built_in">string</span> strNum, <span class="keyword">long</span> <span class="keyword">long</span> llTagNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> strMaxChar = *max_element(strNum.<span class="built_in">begin</span>(), strNum.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llLow = (<span class="built_in">isdigit</span>(strMaxChar) ? strMaxChar - <span class="string">'0'</span> : strMaxChar - <span class="string">'a'</span> + <span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llHigh = <span class="built_in">max</span>(llLow,llTagNum);</span><br><span class="line">    <span class="keyword">while</span>(llLow &lt;= llHigh)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llMedium = (llLow + llHigh) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llMediumRadixNum = str2RadixNum(strNum, llMedium);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(llMediumRadixNum &lt; <span class="number">0</span> || llMediumRadixNum &gt; llTagNum) <span class="comment">//防止溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            llHigh = llMedium - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(llMediumRadixNum &lt; llTagNum)</span><br><span class="line">        &#123;</span><br><span class="line">            llLow = llMedium + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> llMedium;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> strN1;</span><br><span class="line">    <span class="built_in">string</span> strN2;</span><br><span class="line">    <span class="keyword">int</span> iTag;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llRadix;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt; strN1 &gt;&gt; strN2 &gt;&gt; iTag &gt;&gt; llRadix)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llTagNum = iTag == <span class="number">1</span> ? str2RadixNum(strN1, llRadix) : str2RadixNum(strN2, llRadix);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> llResult = iTag == <span class="number">1</span> ? findNumRadix(strN2, llTagNum) : findNumRadix(strN1, llTagNum);</span><br><span class="line">        llResult == <span class="number">-1</span> ? <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt;<span class="built_in">endl</span> : <span class="built_in">cout</span>&lt;&lt; llResult &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PAT-1015 Reversible Primes</title>
    <url>/2020/02/22/PAT-1015-Reversible-Primes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805495863296000" target="_blank" rel="noopener">1015 Reversible Primes</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数以及它的进制数，判断数本身以及它的数位的逆是不是都是质数<br><a id="more"></a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>按照题目来判断原数是不是质数，数位逆转后再判断是不是质数</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是质数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> iNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iNum &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(iNum == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> iHalf = iNum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> iDivisorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= iHalf; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iNum % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数位反转</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> iNum, <span class="keyword">int</span> iD)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iReverse = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(iNum != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iReverse = iReverse * iD + iNum % iD;</span><br><span class="line">        iNum = iNum / iD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iReverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iD;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt; iN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(iN &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; iD;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(iN) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(reverse(iN, iD)) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"No"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Django-数据迁移问题</title>
    <url>/2020/02/21/Django-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> Django在迁移数据库数据时一些方法步骤，以及在导出安全删除数据时的处理方法</p>
 <a id="more"></a>
<ol>
<li><p>清空数据表<br>python manage.py flush</p>
</li>
<li><p>使用Django框架的倒入导出<br>python manage.py dumpdata [APP_NAME] &gt; [EXPOER_FILE_NAME]<br>python manage.py loaddata [EXPOER_FILE_NAME]<br>不指定应用名称则会导出所有数据表，包括一些系统数据表<br>所以在导出时尽量只指定有关业务应用的名称<br>例如:<br>有personnels和customers两个应用要导出数据时<br>python manage.py dumpdata personnels customers &gt; data.json</p>
</li>
</ol>
<p>导入数据<br>python manage.py loaddata data.json</p>
<ol>
<li>当使用安全删除策略时可能面临的导出问题<br>若业务删除操作写的很标准，关联数据都可以逻辑删除的话，执行上述导出导入就可以实现数据的迁移<br>但时可能由于业务复杂，表关联复杂，导致一些数据逻辑删除后，其关联表数据还在。这样在执行原来导出时，那些逻辑删除的数据会导不出来，在执行导入时就会导致某些PK找不到数据<br>如下解决方法是再导出时，将所有数据，包括逻辑删除的数据一并导出<br>这里是修改了框架对于数据查询的代码<br>修改框架manager.py的get_queryset函数中的<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">queryset._safedelete_visibility = DELETED_VISIBLE </span><br></pre></td></tr></table></figure>
然后执行导出命令</li>
</ol>
<p>说明<br>在寻找解决方法的过程实际上是想到python manage.py dumpdata命令也是要查询数据的，万变不离其宗，他一定回去查数据表中的数据，未修改框架代码时，他默认是过滤掉了逻辑删除的数据，所以这里只要找到调用数据库查询的接口，把逻辑删除查询命令改掉就可以，经过查找就是这个了。</p>
]]></content>
  </entry>
  <entry>
    <title>PAT-1013 Battle Over Cities</title>
    <url>/2020/02/21/PAT-1013-Battle-Over-Cities/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">1013 Battle Over Cities</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一些列城市的道路关系，然后去掉一个城市，求解最少需要多少条路才能连通</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题就是求连通域的个数<br>使用深搜，搜索几次就是几个连通域<br>注意：最后一个样例可能会超时,用C的输入输出</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iN, iM, iK;</span><br><span class="line"><span class="keyword">bool</span> szVisited[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">bool</span> szRoute [<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> iCity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    szVisited[iCity] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iN; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(szRoute[iCity][iIndex] == <span class="literal">true</span> &amp;&amp; szVisited[iIndex] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(iIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;iN, &amp;iM, &amp;iK);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iM; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iCity1;</span><br><span class="line">        <span class="keyword">int</span> iCity2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iCity1 &gt;&gt; iCity2;</span><br><span class="line">        szRoute[iCity1 - <span class="number">1</span>][iCity2 - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        szRoute[iCity2 - <span class="number">1</span>][iCity1 - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> iIndex = <span class="number">0</span>; iIndex &lt; iK; iIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> iCity;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iCity);</span><br><span class="line">        <span class="built_in">fill</span>(szVisited, szVisited + iN, <span class="literal">false</span>);</span><br><span class="line">        szVisited[iCity - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> jIndex = <span class="number">0</span>; jIndex &lt; iN; jIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(szVisited[jIndex] == <span class="literal">true</span>) <span class="comment">//访问过的城市不再访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(jIndex);</span><br><span class="line">            iResult ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, iResult - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1012 The Best Rank</title>
    <url>/2020/02/21/PAT-1012-The-Best-Rank/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480" target="_blank" rel="noopener">1012 The Best Rank</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一些列学生在给定科目的得分情况，计算每个学生排名最好的科目，或者平均分排名最好</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题目要求给出每个学生A,C,M,E的分数,计算每个学生名次最好的科目,且4个科目的重要程度为A&gt;C&gt;M&gt;E<br>求解过程是将每科的分数单独排序,计算出每个科目分数所在的名次,并用map存下该分数的名次,然后可以直接通过学生的分数得到所在名次</p>
<p>对于A平均分排序,因为浮点数不适合做key值,所以我采用总分排名</p>
<p>注意：相同分数的名次相同,其后的名次则为累计名次</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STUDENT_GRADE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> C;</span><br><span class="line">    <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">int</span> A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> szTest[<span class="number">4</span>] = &#123;<span class="string">'C'</span>, <span class="string">'M'</span>, <span class="string">'E'</span>, <span class="string">'A'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN, iM;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;iN &gt;&gt;iM;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecGrade[<span class="number">4</span>]; <span class="comment">//记录每种科目的所有分数,并排序</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapGradeIndex[<span class="number">4</span>]; <span class="comment">//记录分数在该科目中的位次</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, STUDENT_GRADE&gt; mapStudentGrade; <span class="comment">//记录学生的分数</span></span><br><span class="line">    <span class="built_in">string</span> strStudentId;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iN; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iC, iM, iE;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId &gt;&gt; iC &gt;&gt; iM &gt;&gt; iE;</span><br><span class="line">        STUDENT_GRADE stTudentGrade;</span><br><span class="line">        stTudentGrade.C = iC;</span><br><span class="line">        stTudentGrade.M = iM;</span><br><span class="line">        stTudentGrade.E = iE;</span><br><span class="line">        stTudentGrade.A = iC + iM + iE;</span><br><span class="line">        mapStudentGrade[strStudentId] = stTudentGrade;</span><br><span class="line">        vecGrade[<span class="number">0</span>].push_back(iC);</span><br><span class="line">        vecGrade[<span class="number">1</span>].push_back(iM);</span><br><span class="line">        vecGrade[<span class="number">2</span>].push_back(iE);</span><br><span class="line">        vecGrade[<span class="number">3</span>].push_back(stTudentGrade.A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个科目的分数进行排序,并计算出位次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(vecGrade[i].<span class="built_in">begin</span>(), vecGrade[i].<span class="built_in">end</span>(), cmp1); <span class="comment">//从大到小倒叙排列</span></span><br><span class="line">        <span class="keyword">int</span> iNextRank = <span class="number">1</span>; <span class="comment">//下一个名次的位次</span></span><br><span class="line">        <span class="keyword">int</span> iLastNum = <span class="number">301</span>; <span class="comment">//总分最大为300,所以这里取301</span></span><br><span class="line">        <span class="comment">//计算位次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vecGrade[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(iLastNum &gt; vecGrade[i][j]) <span class="comment">//上一名的分数大于本轮次分数,名次顺延续</span></span><br><span class="line">            &#123;</span><br><span class="line">                mapGradeIndex[i][vecGrade[i][j]] = iNextRank;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mapGradeIndex[i][vecGrade[i][j]] = mapGradeIndex[i][vecGrade[i][j]]; <span class="comment">//和上一名分数相同,则名次也相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            iLastNum = vecGrade[i][j]; <span class="comment">//保留本轮分数</span></span><br><span class="line">            iNextRank ++; <span class="comment">// 记录分数位次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iM; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId;</span><br><span class="line">        <span class="keyword">if</span>(mapStudentGrade.<span class="built_in">find</span>(strStudentId) == mapStudentGrade.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"N/A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iTest = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> iRank = mapGradeIndex[<span class="number">3</span>][mapStudentGrade[strStudentId].A];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">0</span>][mapStudentGrade[strStudentId].C])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">0</span>][mapStudentGrade[strStudentId].C];</span><br><span class="line">            iTest = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">1</span>][mapStudentGrade[strStudentId].M])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">1</span>][mapStudentGrade[strStudentId].M];</span><br><span class="line">            iTest = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(iRank &gt; mapGradeIndex[<span class="number">2</span>][mapStudentGrade[strStudentId].E])</span><br><span class="line">        &#123;</span><br><span class="line">            iRank = mapGradeIndex[<span class="number">2</span>][mapStudentGrade[strStudentId].E];</span><br><span class="line">            iTest = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; iRank &lt;&lt; <span class="string">" "</span>&lt;&lt; szTest[iTest] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>CS-多线程综述</title>
    <url>/2020/02/21/CS-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>SLAM-学习笔记</title>
    <url>/2020/02/20/SLAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第三讲 三维空间刚体运动<br>3.1 点，向量和坐标系，旋转矩阵</p>
<ul>
<li>表示</li>
<li>运算(加减, 内积, 外积)</li>
</ul>
<p>第三讲 三维空间的刚体运动</p>
<ul>
<li><p>两个不同的坐标系变化  T = 旋转 + 平移</p>
<p>旋转<br>设某坐标系D1(e1, e2, e3)发生一次旋转，变成了D2(e1’, e2’, e3’)</p>
<p>旋转矩阵： 1. R是一个正交矩阵 2. R的行列式为+1</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>音-一荤一素</title>
    <url>/2020/02/20/%E9%9F%B3-%E4%B8%80%E8%8D%A4%E4%B8%80%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日出又日落 深处再深处<br>一张小方桌 有一荤一素<br><img src="一荤一素.jpeg" alt="一荤一素"><br><a id="more"></a></p>
<p>日出又日落 深处再深处<br>一张小方桌 有一荤一素<br>一个身影从容地忙忙碌碌<br>一双手让这时光有了温度<br>太年轻地人 他总是不满足<br>固执地不愿停下 远行的脚步<br>望着高高的天走了长长的路<br>忘了回头看 她有没有哭<br>月儿明 风儿轻<br>可是你在敲打我的窗棂<br>听到这你就别担心<br>其实我过的还可以<br>月儿明 风儿轻<br>你又可曾来过我的梦里<br>一定是你来时太小心<br>知道我睡得很轻</p>
<p>音评：<br>第一次听这首歌是在歌手上听到的，一直喜欢听毛不易的歌曲，很安静。这首歌更是听的深入我心，听的过程很有画面<br>，很多回忆涌来，不知道怎么的我就长大了，现在还能想到童年的几个片段。<br>那应该是中午刚过，我躲在鸡房那个老房子门口，那时应该是个冬天，挺冷的，没有去上学。我在门口躲风等着妈妈去集市回来。现在还能体会到当时的感觉。<br>还有一个片段是跟着妈妈去集市卖鸡蛋，忘了那时是几年级了，反正当时觉得自己挺大的。<br>现在想到这些莫名的酸楚</p>
<h2 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h2><p>你传的照片，是我离家时的床铺<br>你说好久了，屋子都没人住<br>我总有办法打断你的叮嘱<br>多数是不耐烦，少数是想哭</p>
<p>我总说自己要减轻你的辛苦<br>要自己去闯自己的路<br>以为自己足够光彩夺目<br>却被你一眼看穿艰辛苦楚</p>
<p>传说上帝无法亲力亲为所有的守护<br>派仙女下凡，做人间的公主<br>从此，<br>一切美好，在茶米油盐中驻足</p>
<hr>
<p>一荤配一素，一汤配一饭<br>平常日子里，不仅也不慢<br>你给我港湾，我给你期盼<br>走时抬头望天，忍住泪珠涟涟<br>忘了回头看，他人形只影单<br>远行，是孤寂的身影<br>送别，是难耐的情绪<br>他乡，是未知的故里<br>忘了有多久没回到这个港湾<br>忘了她的期盼<br>回去吧，停下远行的脚步<br>月儿正明，风儿正轻，吃一顿热腾腾的饭</p>
]]></content>
      <categories>
        <category>音</category>
      </categories>
  </entry>
  <entry>
    <title>内修-打造自己的个人品牌</title>
    <url>/2020/02/20/%E5%86%85%E4%BF%AE-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="如何打造个人品牌"><a href="#如何打造个人品牌" class="headerlink" title="如何打造个人品牌"></a>如何打造个人品牌</h4><p>干好本职工作， 写作， 演讲</p>
<ul>
<li>热爱本职工作<ol>
<li>主动思考一些问题，遇到难题「我可以学」这是无穷力量。</li>
<li>把公司当作自己的事业</li>
<li>等哪天若是真跳槽了，不用多想，同事对你的背书一定是嘎嘎的棒。这都是长期积累的「馈赠」。<br><img src="%E7%8E%8B%E5%85%B4.jpg" alt="内修-打造自己的个人品牌"></li>
</ol>
</li>
<li>写作<ol>
<li>搞清写作的目的</li>
<li>写就对了，干就完了</li>
<li>积极寻求反馈，鼓励读者或朋友给建议和反馈，改正提升<br><img src="%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5.jpg" alt="内修-打造自己的个人品牌"></li>
</ol>
</li>
<li>演讲<ol>
<li>台上一分钟，台下十年功</li>
<li>抓住核心，不用面面俱到</li>
<li>多看一些优秀朋友的演讲</li>
<li>一定要有Q&amp;A环节，积极寻求思想的碰撞，获得更多志同道合的朋友<br><img src="%E5%AD%A6%E4%B9%A0%E9%87%91%E5%AD%97%E5%A1%94.jpg" alt="内修-打造自己的个人品牌"></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>内修</category>
      </categories>
  </entry>
  <entry>
    <title>影-海上钢琴师</title>
    <url>/2020/02/19/%E5%BD%B1-%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="%E6%B5%B7%E4%B8%8A%E9%92%A2%E7%90%B4%E5%B8%88.jpeg" alt="海上钢琴师"><br>首先表态，这影片一看就是经典影片的样子</p>
<p>看的过程有点松散，分了几段看完的，看完后在我印象中的几个片段，</p>
<ol>
<li>胖子卖小号，</li>
<li>船员爸爸捡到了1900</li>
<li>船员爸爸被铁链砸中去世</li>
<li>1900莫名开始弹钢琴还很厉害</li>
<li>大陆上的著名钢琴师前来挑战，被血虐。</li>
<li>1900遇到个女孩，还有什么关系</li>
<li>胖子来找1900</li>
<li>船炸了</li>
</ol>
<hr>
<p>关于钢琴，关于镜头，关于彼岸，关于1900</p>
<p>众人叫他天才，众人为之疯狂。1900，从拥有这个不平凡的名字起，就注定是个不平凡的人。目光，掌声和荣耀，平凡人可能终其一生都得不到的东西，对于天才的1900就像空气一样稀松平常。</p>
<p>但目光，掌声和荣耀并不能令人幸福，也不长久。电影里有一个镜头：人们围绕在1900身边为音乐起舞的时候，有人看见了自由女神，一下子所有的人呼啦啦作鸟兽散，只剩下1900孤寂的身影。再多的荣耀也挽救不了孤独，此刻他非天才，是个可怜的被遗弃者。</p>
<p>天才其实是世界上最不幸的人。所有的天才都是异类。而再体面的异类都不会被人真正地爱。那些为1900的琴声瞠目结舌的人，在琴声终结的时候，他们也就砸吧着嘴散去。1900这样天才更像个宠物。人们喜欢它，呵护它，痴迷它，但它跑到马路中间迎面驰来飞车，谁也不会扑过去用自己的身体挡住。</p>
]]></content>
      <categories>
        <category>影</category>
      </categories>
  </entry>
  <entry>
    <title>Django-查询优化方法</title>
    <url>/2020/02/19/Django-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近负责的项目后台访问接口贼慢，有时候慢到没有反应的地步，经过多方排查最终把问题源头确定到数据库性性能上。<br>因为通过尝试，同样的数据同样的代码使用本地数据库和使用云数据库查询速度相差将近百倍。然而提升云数据库性能需要资金，资金不充裕只能从后台代码下手，这个不需要资金支持。</p>
<p>首先因为访问数据库很慢，所以尽量减少对数据库的操作。参看django框架和自己的思考主要优化方面如下:</p>
<ol>
<li>后台代码层面<br>1.1. 查询时尽量使用关联表查询，少请求服务器，<br>1.2. 减少在循环中对数据库的请求<br>1.3. select_related通过多表join关联查询，一次性获得所有数据，通过降低数据库查询次数来提升性能</li>
</ol>
<ol>
<li>数据表设计方面</li>
</ol>
<ol>
<li>项目结构方面</li>
</ol>
<p>1.</p>
<ol>
<li><p>使用value,value_list指明查询的字段<br>StuChoiceRes.objects.values(“choice_ans”, “score”, “is_correct”).</p>
</li>
<li><p>使用values_list查询时，若只有一个字段，则flat置为True<br>StuTaskQuestionRes.objects.values_list(“exampaper_question”, flat = True)</p>
</li>
</ol>
<p>然而经过以上操作提升的速度也并不可观,所以只能使用终极大招，缓存<br>对于需要频繁使用且数据量很大的表，在查询时去redis缓存中找，若没有找到则此时建立一个。<br>需要注意的是，使用缓存要保证缓存数据和数据表数据一致，这里采用的策略是在执行更新操作时更新相应的缓存数据</p>
<p>4.</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1054 The Dominant Color</title>
    <url>/2020/02/19/PAT-1054-The-Dominant-Color/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768" target="_blank" rel="noopener">1054 The Dominant Color</a></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>用一个值记录当前色号的数量，当收到不同于当前色号的值时则数量减1，当收到相同的色号，数量加1，当数量减为0时，则切换色号</p>
<a id="more"></a>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> iDominantColor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iDominantColorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iColor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; iColor;</span><br><span class="line">            <span class="keyword">if</span>(iDominantColorCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iDominantColor = iColor;</span><br><span class="line">                iDominantColorCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(iDominantColor == iColor)</span><br><span class="line">                &#123;</span><br><span class="line">                    iDominantColorCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    iDominantColorCount--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iDominantColor&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PAT-1011 World Cup Betting</title>
    <url>/2020/02/18/PAT-1011-World-Cup-Betting/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805504927186944" target="_blank" rel="noopener">1011 World Cup Betting</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>根据分数计算规则计算得分</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> szGameResult[<span class="number">3</span>] = &#123;<span class="string">'W'</span>, <span class="string">'T'</span>, <span class="string">'L'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> fRadio = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> maxGameRadio = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> fGameRadio;</span><br><span class="line">        <span class="keyword">int</span> iGameRadioIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; fGameRadio;</span><br><span class="line">            <span class="keyword">if</span>(fGameRadio &gt; maxGameRadio)</span><br><span class="line">            &#123;</span><br><span class="line">                maxGameRadio = fGameRadio;</span><br><span class="line">                iGameRadioIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; szGameResult[iGameRadioIndex] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        fRadio *= maxGameRadio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> fBet = (fRadio * <span class="number">0.65</span> - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, fBet);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>docker-实战部署django服务器</title>
    <url>/2020/02/18/docker-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2django%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="django-基本环境安装"><a href="#django-基本环境安装" class="headerlink" title="django 基本环境安装"></a>django 基本环境安装</h2><ol>
<li><p>docker pull ubuntu:18.04<br>拉一个ubuntu 18.04版本的镜像，开始使用14.04版本在django包时疯狂报错，慎用</p>
</li>
<li><p>docker run -it -p 8000:8000 ubuntu:18.04<br>使用ubuntu:18.04启动一个容器<br>其中-p 8000:8000最好在启动容器的时候指定，否则容器启动后很难修改</p>
</li>
<li><p>apt-get update<br>更新apt-get</p>
</li>
<li><p>apt-get vim<br>安装vim</p>
</li>
<li><p>apt-get install python3.6<br>安装python3.6</p>
</li>
<li><p>apt-get install python3-pip<br>安装pip3</p>
</li>
<li><p>修改pip3的源，速度会很快<br>vim ~/.pip/pip.conf  //修改pip源<br>输入以下pip源：<br>[global]<br>index-url = <a href="http://pypi.douban.com/simple" target="_blank" rel="noopener">http://pypi.douban.com/simple</a><br>trusted-host = pypi.douban.com<br>disable-pip-version-check = true<br>timeout = 120</p>
</li>
<li><p>ln -s /usr/bin/python3.6 python<br>给python3创建python的软连接，直接使用python命令</p>
</li>
<li><p>pip3 install django==2.2.5<br>安装2.2.5版本的django</p>
</li>
</ol>
<p>此时django环境已经初步完成可测试一下环境是否可用</p>
<h2 id="django-测试基本环境"><a href="#django-测试基本环境" class="headerlink" title="django 测试基本环境"></a>django 测试基本环境</h2><ol>
<li><p>django-admin startproject DockerDjangoTest<br>创建一个django项目</p>
</li>
<li><p>python manager.py runserver 0.0.0.0:8000<br>启动django服务</p>
</li>
</ol>
<p>此时可以使用浏览器访问””，访问到django欢迎界面就好<br>也可以使用容器的ip访问</p>
<h2 id="部署生产"><a href="#部署生产" class="headerlink" title="部署生产"></a>部署生产</h2><ol>
<li><p>pip3 install uwsgi<br>安装uwsgi</p>
</li>
<li><p>配置uwsgi文件</p>
</li>
</ol>
<p>‘’’<br>[uwsgi]<br>chdir = /home/ubuntu/qlassroom-ai/backend #后台代码路径<br>module = backend.wsgi #后台.wsgi文件 即/backend/wsgi.py<br>master = True<br>processes = 4<br>max-requests = 5000<br>harakiri = 60<br>socket = 0.0.0.0:8888  #内网ip + 端口号<br>uid = root<br>gid = root<br>pidfile = /home/ubuntu/qlassroom-ai-uwsgi/master.pid<br>daemonize = /home/ubuntu/qlassroom-ai-uwsgi/mysite.log<br>vacuum = True<br>‘’’</p>
<ol start="3">
<li><p>apt-get install nginx<br>安装nginx</p>
</li>
<li><p>配置nginx</p>
</li>
</ol>
<p>service nginx restart;<br>killall -9 uwsgi<br>uwsgi –ini /home/ubuntu/DockerDjangoTest/docker-django-test-uwsgi.ini;<br>tail -100f /var/log/nginx/access.log;</p>
<p>aws 172.31.18.194:8888</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>英-文_Growing_Neural_Cellular_Automata</title>
    <url>/2020/02/18/%E8%8B%B1-%E6%96%87-Growing-Neural-Cellular-Automata/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://distill.pub/2020/growing-ca/" target="_blank" rel="noopener">Growing Neural Cellular Automata</a><br>神经细胞自动生长机</p>
<p>Differentiable Model of Morphogenesis<br>形态变化的微分模型</p>
<p>Most multicellular organisms begin their life as a single egg cell - a single cell whose progeny reliably self-assemble into highly complex anatomies with many organs and tissues in precisely the same arrangement each time.<br>大多数多细胞有机体生命起源于一个单细胞-单细胞的后代每次都可靠的自组装成高度复杂的解剖结构,其中许多器官和机构每次都使用完全同样的组织方式。</p>
<p>The ability to build their own bodies is probably the most fundamental skill every living creature possesses.<br>构建自己的躯体或许是每个物种具有的最基本的技能</p>
<p>Morphogenesis (the process of an organism’s shape development) is one of the most striking examples of a phenomenon called self-organisation<br>形态进化(一个有机体形体发展的过程)是称为自组织现象最明显的例子</p>
<p>Cells, the tiny building blocks of bodies, communicate with their neighbors to decide the shape of organs and body plans, where to grow each organ, how to interconnect them, and when to eventually stop.<br>细胞，人体的最小组成部分，通过和相邻细胞间的交流来决定机体的形状和人体的计划，每个器官生长的位置，他们之间如何交流，什么时候停止生长。</p>
<p>Understanding the interplay of the emergence of complex outcomes from simple rules and homeostatic feedback loops is an active area of research<br>从简单的规则和稳态的反馈回路中理解复杂结果出现的交互作用是一个活跃的研究领域</p>
<p>What is clear is that evolution has learned to exploit the laws of physics and computation to implement the highly robust morphogenetic software that runs on genome-encoded cellular hardware.<br>显而易见的是进化已经学习到利用物理规律和计算力来完成运行在记忆编码细胞的硬件上高度健壮的软件</p>
<p>This process is extremely robust to perturbations.</p>
<p>Even when the organism is fully developed, some species still have the capability to repair damage - a process known as regeneration.<br>即使当有机体完全发育，某些物种仍然具有自我修复损害的能力，这个叫做复生的过程</p>
<p>Some creatures, such as salamanders, can fully regenerate vital organs, limbs, eyes, or even parts of the brain! Morphogenesis is a surprisingly adaptive process.<br>某些生物，比如salamanders，可以完全再生重要的组织，腿，眼睛，甚至是部分大脑！形态变化是一个很惊奇的适应的过程。</p>
<p>Sometimes even a very atypical development process can result in a viable organism - for example, when an early mammalian embryo is cut in two, each half will form a complete individual - monozygotic twins!<br>有时，即使一个非常不同寻常的发育过程也能产生一个活得机体。例如，当一个早期的哺乳动物被切分成两个时，每个部分都将形成一个完整的个体，单卵双胞胎</p>
]]></content>
      <categories>
        <category>英-文</category>
      </categories>
  </entry>
  <entry>
    <title>超级数学建模-几个分形函数</title>
    <url>/2020/02/17/%E8%B6%85%E7%BA%A7%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%87%A0%E4%B8%AA%E5%88%86%E5%BD%A2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  两千多年来，几何学的研究主要集中在欧几里得几何上。<br>  正因为如此，欧氏几何中由直线或曲线、平面或曲面、平直体或曲体所构成的各种几何形状，一直是人类认识自然物体形状的有力工具，还是各种学科的理论基础</p>
]]></content>
      <categories>
        <category>超级数学</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1008 Elevator</title>
    <url>/2020/02/17/PAT-1008-Elevator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805511923286016" target="_blank" rel="noopener">1008 Elevator </a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定电梯上行下行以及等待需要处理的时间，给定电梯所要执行的序列，计算处理完这个序列所要花费的时间</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iN;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; iN;</span><br><span class="line">    <span class="keyword">int</span> iFloor;</span><br><span class="line">    <span class="keyword">int</span> iLastFloor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> iCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iFloor;</span><br><span class="line">        <span class="keyword">int</span> iStep = iFloor - iLastFloor;</span><br><span class="line">        <span class="keyword">if</span>(iStep &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iCost += iStep * <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            iCost -= iStep * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iLastFloor = iFloor;</span><br><span class="line"></span><br><span class="line">        iCost += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; iCost &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PAT-1007 Maximum Subsequence Sum</title>
    <url>/2020/02/17/PAT-1007-Maximum-Subsequence-Sum/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168" target="_blank" rel="noopener">1007 Maximum Subsequence Sum</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数列，计算每个这个序列最大子序列的和</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>计算每个点为终点的最大子序列和<br>maxSeqSum[i] = max(num[i], maxSeqSum[i - 1] + num[i])</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ST_MAX_SUM_SEQUENCE</span>&#123;</span> <span class="comment">//记录最大子序列和</span></span><br><span class="line">    <span class="keyword">int</span> iStartIndex;</span><br><span class="line">    <span class="keyword">int</span> iEndIndex;</span><br><span class="line">    <span class="keyword">int</span> iSum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iK;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> szNum[iK];</span><br><span class="line">    ST_MAX_SUM_SEQUENCE stMaxSumSequence[iK]; <span class="comment">//记录每个位置子序列和</span></span><br><span class="line">    ST_MAX_SUM_SEQUENCE stMaxSum; <span class="comment">//记录和最大的子序列</span></span><br><span class="line">    stMaxSum.iStartIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSum.iEndIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;szNum[<span class="number">0</span>];</span><br><span class="line">    stMaxSum.iSum = szNum[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iStartIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iEndIndex = <span class="number">0</span>;</span><br><span class="line">    stMaxSumSequence[<span class="number">0</span>].iSum = szNum[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; iK; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; szNum[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(szNum[i] + stMaxSumSequence[i - <span class="number">1</span>].iSum &gt;= szNum[i])</span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSumSequence[i].iStartIndex = stMaxSumSequence[i - <span class="number">1</span>].iStartIndex;</span><br><span class="line">            stMaxSumSequence[i].iEndIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iSum = szNum[i] + stMaxSumSequence[i - <span class="number">1</span>].iSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSumSequence[i].iStartIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iEndIndex = i;</span><br><span class="line">            stMaxSumSequence[i].iSum = szNum[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stMaxSum.iSum &lt; stMaxSumSequence[i].iSum)</span><br><span class="line">        &#123;</span><br><span class="line">            stMaxSum.iStartIndex = stMaxSumSequence[i].iStartIndex;</span><br><span class="line">            stMaxSum.iEndIndex = stMaxSumSequence[i].iEndIndex;</span><br><span class="line">            stMaxSum.iSum = stMaxSumSequence[i].iSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stMaxSum.iSum &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[iK - <span class="number">1</span>] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; stMaxSum.iSum &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[stMaxSum.iStartIndex] &lt;&lt; <span class="string">" "</span> &lt;&lt; szNum[stMaxSum.iEndIndex] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1006 Sign In and Sign Out</title>
    <url>/2020/02/17/PAT-1006-Sign-In-and-Sign-Out/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805516654460928" target="_blank" rel="noopener">1006 Sign In and Sign Out</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一些列学生到达和离开时间，找到最早到和最晚走的学生</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>太简单</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iM;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;iM);</span><br><span class="line">    <span class="built_in">string</span> strStudentId;</span><br><span class="line">    <span class="built_in">string</span> strSignIn;</span><br><span class="line">    <span class="built_in">string</span> strSignOut;</span><br><span class="line">    <span class="built_in">string</span> strMinSignInId;</span><br><span class="line">    <span class="built_in">string</span> strMinSignInTime = <span class="string">"24:00:00"</span>;</span><br><span class="line">    <span class="built_in">string</span> strMinSignOutId;</span><br><span class="line">    <span class="built_in">string</span> strMaxSignOutTime = <span class="string">"00:00:00"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iM; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; strStudentId &gt;&gt; strSignIn &gt;&gt; strSignOut;</span><br><span class="line">        <span class="comment">//cout&lt;&lt; strMinSignInId &lt;&lt; strMinSignOutId &lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(strMinSignInTime &gt;= strSignIn)</span><br><span class="line">        &#123;</span><br><span class="line">            strMinSignInId = strStudentId;</span><br><span class="line">            strMinSignInTime = strSignIn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(strMaxSignOutTime &lt;= strSignOut)</span><br><span class="line">        &#123;</span><br><span class="line">            strMinSignOutId = strStudentId;</span><br><span class="line">            strMaxSignOutTime = strSignOut;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; strMinSignInId &lt;&lt; <span class="string">" "</span> &lt;&lt; strMinSignOutId &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1005 Spell It Right</title>
    <url>/2020/02/17/PAT-1005-Spell-It-Right/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805519074574336" target="_blank" rel="noopener">1005 Spell It Right</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个数，求解这个数各个数位相加的结果，结果输出英文</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>数位求和相加</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> szIntergerToEnglish[<span class="number">10</span>] =&#123;<span class="string">"zero"</span>,<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span>,<span class="string">"six"</span>,<span class="string">"seven"</span>,<span class="string">"eight"</span>,<span class="string">"nine"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szNum[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, szNum);</span><br><span class="line"><span class="keyword">int</span> iSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">strlen</span>(szNum); i++)</span><br><span class="line">&#123;</span><br><span class="line">    iSum += szNum[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> szPrintNum[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> iSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(iSum != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    szPrintNum[iSize] = iSum % <span class="number">10</span>;</span><br><span class="line">    iSum = iSum / <span class="number">10</span>;</span><br><span class="line">    iSize++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(iSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;szIntergerToEnglish[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; szIntergerToEnglish[szPrintNum[iSize - <span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = iSize - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">" "</span> &lt;&lt; szIntergerToEnglish[szPrintNum[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1004 Counting Leaves</title>
    <url>/2020/02/14/PAT-1004-Counting-Leaves/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>就是求解树结构的每一层的叶子节点的树木，使用宽度搜索</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mapNodeLevel; <span class="comment">//记录节点所在层数</span></span><br><span class="line"><span class="keyword">int</span> iMaxLevel = <span class="number">0</span>; <span class="comment">//记录最大层数</span></span><br><span class="line"><span class="keyword">int</span> szNoLeafNode[<span class="number">100</span>]; <span class="comment">//记录每层没有孩子的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>, M;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; mapTree;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strRoot;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt; strRoot;</span><br><span class="line">        <span class="keyword">int</span> iK;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; iK;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vecChild;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; iK; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> strChild;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt; strChild;</span><br><span class="line">            vecChild.push_back(strChild);</span><br><span class="line">        &#125;</span><br><span class="line">        mapTree[strRoot] = vecChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; queNode;</span><br><span class="line">    queNode.push(<span class="string">"01"</span>);</span><br><span class="line">    mapNodeLevel[<span class="string">"01"</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(queNode.empty() != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strFrontNode = queNode.front();</span><br><span class="line">        queNode.pop();</span><br><span class="line">        <span class="keyword">if</span>(mapTree[strFrontNode].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            szNoLeafNode[mapNodeLevel[strFrontNode]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        iMaxLevel = <span class="built_in">max</span>(iMaxLevel, mapNodeLevel[strFrontNode]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapTree[strFrontNode].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mapNodeLevel[mapTree[strFrontNode][i]] = mapNodeLevel[strFrontNode] + <span class="number">1</span>;</span><br><span class="line">            queNode.push(mapTree[strFrontNode][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, szNoLeafNode[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= iMaxLevel; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, szNoLeafNode[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1003_Emergency</title>
    <url>/2020/02/13/PAT-1003-Emergency/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">1003 Emergency</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定每个城市间的距离和每个城市可获得的助手数量，寻找最短的路径以及能获得最多的助手数</p>
<a id="more"></a>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>此题就是求解最短路径，只是在求解的过程中需要记录有几个最短路径，以及在所有最短路径中权重最大的值。<br>求解最短路径使用的是Dijkstra算法，在这道题中，需要做一下变化记录下最短路径数，和最大权重</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><figcaption><span>line_number: true</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, C1, C2;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N &gt;&gt;M &gt;&gt;C1 &gt;&gt; C2;</span><br><span class="line">    <span class="keyword">int</span> hands[N]; <span class="comment">// 城市助手数量</span></span><br><span class="line">    <span class="keyword">int</span> roads[N][N]; <span class="comment">// 两座城市的路费</span></span><br><span class="line">    <span class="keyword">int</span> visited[N]; <span class="comment">//该城市是否已经访问</span></span><br><span class="line">    <span class="keyword">int</span> shortRoads[N]; <span class="comment">//最短路径长度</span></span><br><span class="line">    <span class="keyword">int</span> shortRoadsNum[N]; <span class="comment">//最短路径数量</span></span><br><span class="line">    <span class="keyword">int</span> maxHands[N]; <span class="comment">//到该城市最多的人数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;hands[i];</span><br><span class="line">        visited[i] = <span class="number">0</span>; <span class="comment">//初始化所有城市未访问</span></span><br><span class="line">        shortRoads[i] = <span class="number">-1</span>; <span class="comment">//初始化所有城市最短路径都不存在</span></span><br><span class="line">        shortRoadsNum[i] = <span class="number">0</span>; <span class="comment">// 初始化所有的城市最短路径数量为0</span></span><br><span class="line">        maxHands[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            roads[i][j] = <span class="number">-1</span>; <span class="comment">//初始化两座城市不可达</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c1, c2, L;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; L;</span><br><span class="line">        roads[c1][c2] = L;</span><br><span class="line">        roads[c2][c1] = L;</span><br><span class="line">    &#125;</span><br><span class="line">    shortRoads[C1] = <span class="number">0</span>;</span><br><span class="line">    shortRoadsNum[C1] = <span class="number">1</span>;</span><br><span class="line">    maxHands[C1] = hands[C1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nowMinRoadCity = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> nowMinRoad = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="comment">//寻找当前距离最小的节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="number">0</span> &amp;&amp; shortRoads[j] != <span class="number">-1</span>)<span class="comment">//目前不可达的城市不考虑</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nowMinRoad == <span class="number">-1</span> || nowMinRoad &gt; shortRoads[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nowMinRoad = shortRoads[j];</span><br><span class="line">                    nowMinRoadCity = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nowMinRoad == <span class="number">-1</span>) <span class="comment">//如果没找到未访问过的城市的最小路径则结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//        cout&lt;&lt;"nowMinRoadCity:" &lt;&lt; nowMinRoadCity &lt;&lt;endl;</span></span><br><span class="line">        visited[nowMinRoadCity] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) <span class="comment">//在最小节点的基础上更新路径</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[j] == <span class="number">0</span>) <span class="comment">//</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(shortRoads[j] == <span class="number">-1</span>) <span class="comment">//当前城市处于不可达的状态</span></span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">if</span>(roads[nowMinRoadCity][j] != <span class="number">-1</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       shortRoads[j] = shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j];</span><br><span class="line">                       shortRoadsNum[j] = shortRoadsNum[nowMinRoadCity] ;</span><br><span class="line">                       <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                       &#123;</span><br><span class="line">                           maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(roads[nowMinRoadCity][j] != <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(shortRoads[j] &gt; shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            shortRoads[j] = shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j];</span><br><span class="line">                            shortRoadsNum[j] = shortRoadsNum[nowMinRoadCity];</span><br><span class="line">                            <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(shortRoads[j] == shortRoads[nowMinRoadCity] + roads[nowMinRoadCity][j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            shortRoadsNum[j] += shortRoadsNum[nowMinRoadCity];</span><br><span class="line">                            <span class="keyword">if</span>(maxHands[j] &lt; maxHands[nowMinRoadCity] + hands[j])</span><br><span class="line">                            &#123;</span><br><span class="line">                                maxHands[j] = maxHands[nowMinRoadCity] + hands[j];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">//                cout&lt;&lt; "shortRoads " &lt;&lt;j &lt;&lt; " " &lt;&lt;shortRoads[j]&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; shortRoadsNum[C2]&lt;&lt; <span class="string">" "</span> &lt;&lt; maxHands[C2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
  </entry>
  <entry>
    <title>docker-镜像基础操作</title>
    <url>/2020/02/12/docker-%E9%95%9C%E5%83%8F%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p>列出镜像<br>docker images</p>
</li>
<li><p>查看镜像<br>docker inspect</p>
</li>
<li><p>删除镜像<br>docker rmi</p>
</li>
<li><p>查找镜像<br>docker search</p>
</li>
<li><p>拉去镜像<br>docker pull</p>
</li>
<li><p>推送镜像<br>docker push</p>
</li>
</ol>
<p>例子docker push qlassroom_ai_dev</p>
<ol start="7">
<li>构建镜像<br>docker commit</li>
</ol>
<p>利用dockerfile 构建镜像<br>docker build</p>
<ol start="8">
<li><p>dockerfile 构建镜像</p>
</li>
<li><p>docker tag 规范镜像名字<br>docker tag qlassroom_ai_dev:latest 872204778/qlassroom_dev:v1<br>qlassroom_ai_dev 为原镜像名称<br>latest: 为原镜像标签</p>
</li>
</ol>
<p>872204778： 用户名<br>qlassroom_dev：新镜像名<br>v1:新标签</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>影-肖申克的救赎</title>
    <url>/2020/02/11/%E5%BD%B1-%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="%E8%82%96%E7%94%B3%E5%85%8B%E7%9A%84%E6%95%91%E8%B5%8E.jpeg" alt="肖申克的救赎"><br>2020-02-10，大约是23:30 我看完了肖申克的救赎，总共用了两天时间，分三段看完的。<br>  看这部电影的初衷就是想看看评分如此之高，备受好评的电影是怎么做到的。经典为何为经典。<br>看的过程中并没有全身心的投入去看，因为像这种偏文艺的电影，我现在还不能做到心无旁骛的陶醉其中，然而虽然看的时候有点懈怠，但是经典的电影还是在不经意间引起我的深思。<br>  首先是主人公作为Andy作为一个在社会上有头有脸的人物，却沦为阶下囚，并受到了些凌辱。这样我想到，适应环境，利用规则，才是生存或者更好生活的的法则。狱警可以肆无忌惮的对囚徒进行殴打，因为在这个小小的“王国”下，他们就是规则的制定者。他们可以毫无理由的分配给囚徒各种工作，即使很地下的工作，在囚徒看来都可能是一种荣幸。</p>
<p>  其次是知识的作用，Andy有知识，他利用他的知识能力在狱中可以得到与其他囚徒不一样的待遇，同时他又利用他的知识能力来教化其他狱友。从某点上来考虑，这个情节很激励人心，教化自己普渡他人，这是一个自带光芒的人啊，然而转念一想，这情节有些突兀。在一个没有自由，或者说是在一个狭小的几乎会永远生活在这没有“文明”的地方，真的会有人崇尚知识吗。这就好比生活在三维世界的人，可能只是四维生物的打工仔，我们所谓的知识，只是四维生物赏赐给我们的低级的趣味。</p>
<p>  Brooks从监狱里出来之后，选择了自杀，因为他很难再适应外面世界的规则。</p>
<p>  以后再看一次</p>
<hr>
<p>下面为阅读的影评<br>肖申克的救赎与信念，自由，友谊有关。</p>
<h5 id="【信念】"><a href="#【信念】" class="headerlink" title="【信念】"></a>【信念】</h5><p>Red说，希望是危险的东西，是精神苦闷的根源。重重挤压下的牢狱里待了三十年的他的确有资格这么说。因为从进来的那一天起，狱长就说过「把灵魂交给上帝，把身体交给我」。 他除了能弄来香烟和印着裸女的扑克牌，其他任何异动在这个黑暗的高墙之内似乎都无法生长。</p>
<p>然而，Andy却告诉他，「记住，希望是好事——甚至也许是人间至善而美好的事永不消失」。</p>
<p>所以Andy能够用二十年挖开瑞德认为六百年都无法凿穿隧洞。当Andy终于排除五百码恶臭的污水管道，站在瓢泼大雨中情不自禁的时候，我们仿佛看到信念刺穿重重黑幕，在暗夜中打了一道夺目的霹雳。亮光之下，我们怯懦的灵魂在Andy张开的双臂下现行，并且颤抖。</p>
<p><em>庸常生活里的我们，似乎已经习惯了按步就按，习惯了先说「不可能」，习惯了没有奇迹，习惯了习惯了。</em></p>
<p>我们应该试着留住一些信念，在他们丧失殆尽之前。它们也许最终无法实现，也许无法让我们或者更有意义的活着，甚至对于我们自己而言，它们只会愈加给我们带来更多的虚无感。然而我知道我有多需要这样的虚伪与自欺，因为你可以说我在做梦，但我不会是仅有的一个。</p>
<h5 id="【自由】"><a href="#【自由】" class="headerlink" title="【自由】"></a>【自由】</h5><p>我到今天也不明白，那两个意大利的女人在唱什么。事实上，我也不想去明白。有些东西不说更好。我想那是非笔墨可形容的美貌，然而却令你如此心伤。</p>
<p>那声音飞扬，高远入云，超过任何在禁锢中的囚犯的梦。仿佛一只美丽的小鸟，飞入这灰色的鸟笼，让那些围墙消失，另铁窗中的所有犯人，感到一刻的自由。</p>
<p>当Andy不顾一切的在监狱的喇叭里放《费加罗的婚礼》时。正在广场上防风的囚徒们和那些狱警，它们静立当地，抛却所有愤懑，狠毒，怨恨，沐浴着从未觉得如此自由的阳光。莫扎特的乐声铺洒在这些人的身上，来自俗世的美妙音符似乎将他们都濯洗的纯净无比。</p>
<p><em>强者自救，圣者渡人。</em> 修屋顶的时候，Andy为大家争取来啤酒，事实上是为大家争取到的那种像修缮自家的屋顶一般自由的存在，所以他不喝酒，微笑却带着巨大的幸福。播放《费加罗的婚礼》也是要唤醒它们已经丧失殆尽的自由感。</p>
<p>然而强者终究是少数。自由面前，更多人选择禁锢。在监狱图书馆待了五十年的Brooks，为了不被假释，竟然想通过伤害狱友来达到留在监狱的目的。自由本就是人们向往和追求的东西。可是Brooks却早已在监狱的规则下规则了自己，没有规则，他无法生存。</p>
<p>「监狱的高墙是在是很有趣。刚入狱时，你痛恨周围的高墙；慢慢的，你习惯生活在其中，最终你会发现自己不得不依靠它来生存。这就是体制化」假Red之口，斯蒂芬金直指卑微</p>
<p>Brooks得到了身体的自由，灵魂却早已经无法挽回的体制化。他终于没有能摆脱对自由无法适应的困境，悬梁自尽。而睿智如瑞德，在出狱之后也悲哀的发现，自己竟然连撒尿都要向经理报告，否则一滴都挤不出来。他也考虑如何违规以便回到监狱，甚至考虑与Brooks一样离开。</p>
<p>要么忙着生活，要么忙着等死。步履匆匆的人们也许应该偶尔驻足，跳出来看看自己的模样。我们终会知道，<em>习惯与服从规则的人们将付出巨大的代价来习惯本来属于每一个人的自由</em></p>
<h5 id="【友谊】"><a href="#【友谊】" class="headerlink" title="【友谊】"></a>【友谊】</h5><p>Red和Andy那种置放在高墙之下的友谊，似乎比我们纷繁俗世中的友情来的更加纯粹和干净。他们都是内敛的人，然而洞悉一切，心意切合。他们终于相会在太平洋小岛的阳光沙滩上。</p>
]]></content>
      <categories>
        <category>影</category>
      </categories>
  </entry>
  <entry>
    <title>docker-基本容器操作</title>
    <url>/2020/02/11/docker-%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="容器基本操作"><a href="#容器基本操作" class="headerlink" title="容器基本操作"></a>容器基本操作</h3><ol>
<li><p>启动容器<br>docker run IMAGE [COMMAND] [ARG…]<br>例： 启动容器并输出hello world<br>docker run ubuntu echo “hello world”</p>
</li>
<li><p>启动交互式容器<br>docker run -i -t IMAGE /bin/bash<br>例：<br>docker run -i -t ubuntu /bin/bash</p>
</li>
<li><p>查看容器列表<br>docker ps</p>
</li>
<li><p>查看容器详情<br>docker inspect</p>
</li>
<li><p>重新启动已经停止的容器<br>docker start -i</p>
</li>
<li><p>删除停止的容器<br>docker rm cool_sammet</p>
</li>
<li><p>以守护形式运行容器<br>docker run -i -t IMAGE /bin/bash<br>CTRL + Q 退出</p>
</li>
<li><p>再次进入守护形式运行的容器<br>docker attach</p>
</li>
<li><p>使用run 启动守护形式容器<br>docker run -d IMAGE [COMMAND] [ARG…]<br>例：docker run –name dc1 -d ubuntu /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
</li>
<li><p>查看容器日志<br>docker logs [-f] [-t] [–tail] 容器名</p>
</li>
<li><p>查看容器的进程<br>docker top 容器名</p>
</li>
<li><p>在运行容器中启动新的进程<br>docker exec [-d][-i][-t] 容器名 [COMMAND][ARG…]<br>例：docker exec -i -t dc1 /bin/bash</p>
</li>
<li><p>停止守护容器<br>docker stop 发送信号给容器，等待其停止<br>docker kill 直接停止容器</p>
</li>
<li><p>容器保存为镜像<br>docker commit 容器名 镜像名</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>PAT-1002 A+B for Polynomials</title>
    <url>/2020/02/11/PAT-1002-A-B-for-Polynomials/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">1002 A+B for Polynomials</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定两个多项式的系数和项,将他们合并</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h2 id="将系数相同的项累加，累加后若该项为0则删除"><a href="#将系数相同的项累加，累加后若该项为0则删除" class="headerlink" title="将系数相同的项累加，累加后若该项为0则删除"></a>将系数相同的项累加，累加后若该项为0则删除</h2><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><ol>
<li>项为0的不输出</li>
<li>按照系数大小逆向输出</li>
</ol>
<hr>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; poly;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> poly_i = <span class="number">0</span>; poly_i &lt; <span class="number">2</span>; poly_i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">int</span> N;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">int</span> Ni;</span><br><span class="line">          <span class="keyword">double</span> aN;</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt; Ni &gt;&gt; aN;</span><br><span class="line">          <span class="keyword">if</span>(poly.<span class="built_in">find</span>(Ni) != poly.<span class="built_in">end</span>())</span><br><span class="line">          &#123;</span><br><span class="line">              poly[Ni] += aN;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              poly[Ni] = aN;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(poly[Ni] == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              poly.erase(Ni); <span class="comment">// 删除项为0</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt; poly.<span class="built_in">size</span>();</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;::reverse_iterator rit;</span><br><span class="line">  <span class="keyword">for</span>(rit = poly.rbegin(); rit != poly.rend(); rit++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">" %d %.1f"</span>, rit-&gt;first, rit-&gt;second); <span class="comment">//保留1位小数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>tf-keras和keras</title>
    <url>/2020/02/10/tf2-keras%E5%92%8Ckeras/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>keras 是什么</p>
<ul>
<li>基于python的高级神经网络API</li>
<li>以Tensorflow，CNTK或者Theano为后段运行，keras必须有后端才可以运行</li>
<li>极方便与快速实验，帮助用户以最少的时间验证自己的想法<br>Tensorflow-keras是什么<ul>
<li>Tensorflow对keras API的规范实现</li>
<li>比以Tensorflow为后段的keras，Tensorflow-keras与Tensorflow结合更加紧密</li>
<li>实现在tf.keras空间下</li>
</ul>
</li>
</ul>
<p>Tf-keras 和 keras的联系</p>
<ul>
<li>基于同一套API<ul>
<li>keras程序可以通过导入方式转换为tf.keras程序</li>
<li>反之不成立，因为tf.keras有其他特性<ul>
<li>相同的JSON和HDF5模型序列化格式和语义</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Tf-keras 和 keras的区别</p>
<ul>
<li>Tf.keras全面支持eager mode<ul>
<li>只是用keras.Sequential和keras.Model时没有影响</li>
<li>自动以的Model内部运算逻辑时没有影响<ul>
<li>Tf低层API可以使用keras的model.fit等抽象</li>
</ul>
</li>
</ul>
</li>
<li>Tf.keras支持基于tf.data的模型训练</li>
<li>Tf.keras支持TPU训练</li>
<li>Tf.keras支持tf.distribution的分布式策略</li>
<li>Tf.keras可以与Tensorflow中的estimator集成</li>
<li>Tf.keras可以保存为SaveModel</li>
</ul>
]]></content>
      <categories>
        <category>Tensorflow2.0</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习-概率分布</title>
    <url>/2020/02/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
  </entry>
  <entry>
    <title>疫情下的元宵节</title>
    <url>/2020/02/09/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E5%85%83%E5%AE%B5%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 2020年正月十五-元宵节</p>
<p> 今年春节非比寻常，在武汉瘟疫肆虐的情况下，每个人都被限制在了室内。出门都是口罩护身。往日的走街串巷，拜亲戚，聚会的习俗都被瘟疫压制了。</p>
<p> 这是2020年正月16的疫情数据。<br> <img class="epidemic_data.jpeg [width] [height] &quot;title text&quot; &quot;alt text&quot;"></p>
<p> <img src="epidemic_data.jpeg" alt="患病人数"><br> <img src="epidemic_data_map.jpeg" alt="各省统计"><br> 总确诊人数将近4万了，很恐怖的数据了。<br> 湖北，广东，浙江都已经变黑了，河南今天也变黑了。</p>
<p> <img src="we.jpeg" alt="我们"><br> 在这样的疫情下，我和他在一起过的元宵节，带着口罩背对着正月十五的月亮，在一起就很开心</p>
]]></content>
      <categories>
        <category>文</category>
      </categories>
  </entry>
  <entry>
    <title>二维码登陆原理</title>
    <url>/2020/02/09/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E9%99%86%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><ol>
<li><p>网页端和服务器配合逻辑<br>首先用户打开网站登陆界面时，向服务器发送获取登陆二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，过期后，用户登陆二维码需要进行刷新重新获取。</p>
<p>同时，将这个key值和本公司的验证码字符串合在一起，生成一个二维码图片，将后将二维码图片和uuid一起返回给浏览器。</p>
<p>浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次登陆是否成功的请求。请求中携带有uuid作为当前页面的标识符。</p>
</li>
<li><p>手机端与服务器端配合逻辑<br>浏览器拿到二维码后，将二维码展示到网页上，并给用户一个提示：打开扫一扫进行登陆。</p>
<p>用户扫描二维码后，就可以得到一个验证码和一个uuid。</p>
<p>手机端访问服务器，参数中会有token，手机端服务器可以从中得到用户的userId。手机端将解析到的数据和用户token一起作为参数，向服务器发送验证登陆请求。</p>
<p>服务器收到登陆请求后，返回登陆确认信息给手机端。</p>
<p>手机端收到返回后，进行登陆确认。确认后再次返送请求，服务器拿到userId和uuid后，将用户的userId作为value存入redis</p>
</li>
<li><p>登陆确认后，浏览器逻辑</p>
</li>
</ol>
<p>浏览器每秒发送时候登陆成功的请求，确认登陆成功后，可以获取登陆用户的userId。</p>
<p>流程图如下：<br><img src="qrcode_login.jpg" alt="qrcode login"></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>李文亮医生，再见</title>
    <url>/2020/02/07/%E6%9D%8E%E6%96%87%E4%BA%AE%E5%8C%BB%E7%94%9F%E5%86%8D%E8%A7%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="我走了-带着一张训诫书！"><a href="#我走了-带着一张训诫书！" class="headerlink" title="我走了,带着一张训诫书！"></a>我走了,带着一张训诫书！</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=491833132&auto=1&height=66"></iframe>

<iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=e90721dc87291f4510c03309e249411a&tvId=12381616400&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="100%"></iframe>

<p>  <img src="LWL.jpg" alt="李文亮医生"><br>  天还没亮，我走了</p>
<p>  我走的时候，渡口很黑，无人相送，只有几朵雪花落在我的眼底。我一思念，它们便从我的眼眶滑落。</p>
<p>  黑夜真黑，黑的让我想不起万家灯火。我一生追求光，我自诩很明亮，但我拼尽全力，却什么都没点亮</p>
<p>  谢谢你们，昨夜冒着风雪来看我的人！谢谢你们整夜不眠，像守望亲人一样把我守望！可是脆弱人间，没有奇迹。</p>
<p>  我原本平凡而渺小，有一天我被上帝选中，托我将他的旨意转告苍生。</p>
<p>  我小心翼翼的说了，于是，有人劝我不要惊扰太平，他们说：你没看见满城繁华开得正艳吗！</p>
<p>  为了让全世界相信现世安稳，我只好守口如瓶，还用鲜红的指印保证 – 我说的话都是童话，带花冠的致命皇后从来不曾下凡作乱。</p>
<p>  就这样，天下继续熙熙攘攘，谁也不知道，巨大的悲伤即将把城门紧锁。</p>
<p>  后来，上帝大怒，山河失色，我也病了。再后来，我的家人都病了。我们就像千万片雪花一样，你一片，我一片，各自凋零。</p>
<p>  我曾以为，只待春江水暖，我和家人便能再度重相逢。到那时，我们就坐在鹅黄的油菜花田，把花儿一朵一朵的数，把日子一分一秒地过。</p>
<p>  等啊等啊，我只等来了昨夜小雪，上帝摸摸我的头，爱怜地说：乖，跟我走吧，人间不值得！</p>
<p>  我一听就泪如雨下，虽然人间苦寒，上帝温暖。但我怕过了奈何桥，偶尔回望吾乡，再也望不见一家老小。</p>
<p>  其实，我的风骨早就被拍死在一张保证书上。我继续阳光朗照地活着，歌颂生命，赞美松柏，那是因为我对这土地爱得深沉。而今，我的肉身也死了。</p>
<p>  在我成为一粒尘埃之前，我又静静地怀想了一遍故乡的黑土白云。多想回到小时候啊，风是尽情飞舞的，雪是洁白无瑕的。</p>
<p>  活着真好，可我死了。我再也无法抚摸亲人的脸庞，再也无法带孩子去看东湖春晓，再也无法陪父母去看武大的樱花，再也无法把风筝放到白云深处。</p>
<p>  我曾依稀梦见我尚未出世的孩子，他一出生就眼含热泪，在人潮人海中把我寻找。对不起，孩子！我知道你只想要一个平凡的父亲，而我却做了一个平民英雄。</p>
<p>  天快亮了，我要走了。带着一张保证书，那是我此生唯一的行囊。</p>
<p>  谢谢世间所有懂我怜我爱我的人，我知道你们都在黎明等候，等我越过山丘！可是，我太累了。</p>
<p>  此生，我不想重于泰山，也不怕轻于鸿毛。我唯一的心愿，就是希望冰雪消融之后，众生依然热爱大地，依然相信祖国。</p>
<p>  等到春雷滚滚，如果有人还想纪念我，请给我立一个小小的墓碑吧！不必伟岸，只须证明我曾来过这个世界，有名有姓，无知无畏。</p>
<p>  那么，我的墓志铭只需一句话：他为苍生说过话</p>
]]></content>
      <categories>
        <category>文</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/01/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><p>模版方法 Template</p>
<ul>
<li>动机: 某项任务有稳定的整体结构，但是各个子步骤有很多改变的需求</li>
<li>定义: 定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以不改变一个算法的结构重定义该算法的特定步骤（只见树木不见森林）</li>
<li>处理思路: 利用虚函数的多态性</li>
</ul>
</li>
<li><p>策略模式 Strategy</p>
<ul>
<li>动机：在软件构件过程中，某些对象使用的算法可能多种多样，使用率小的算法也是一种性能负担</li>
<li>定义：定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户程序而变化</li>
<li>处理方法： 利用多态性</li>
</ul>
</li>
<li><p>观察者模式 Observer/Event</p>
<ul>
<li>动机：软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”，一个对象发生状态改变，所有依赖对象都将得到通知</li>
<li>定义：定义对象间一种一对多的依赖关系，以便一个对象的状态改变时，所有依赖于它的对象都得到通知和更新</li>
</ul>
</li>
<li><p>装饰模式 Decorator</p>
<ul>
<li>动机: 过度的使用继承来拓展对象的功能，由于继承为类型引入的静态特质，使得这种拓展方式缺乏灵活性，并且随着子类的增多，各种子类的组合会导致更多的子类膨胀</li>
<li>定义： 动态给一个对象增加额外的职责</li>
</ul>
</li>
<li><p>桥模式 Brige</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>technology</tag>
      </tags>
  </entry>
</search>
